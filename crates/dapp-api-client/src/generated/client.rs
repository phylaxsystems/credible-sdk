// @generated - This file is automatically generated. Do not edit.
// rustfmt-ignore-file

#![allow(clippy::all)]
#![allow(irrefutable_let_patterns)]
#![allow(warnings)]

# [allow (unused_imports)] pub use progenitor_client :: { ByteStream , Error , ResponseValue } ; # [allow (unused_imports)] use progenitor_client :: { encode_path , RequestBuilderExt } ; # [allow (unused_imports)] use reqwest :: header :: { HeaderMap , HeaderValue } ; # [doc = r" Types used as operation parameters and responses."] # [allow (clippy :: all)] pub mod types { # [doc = r" Error types."] pub mod error { # [doc = r" Error from a TryFrom or FromStr implementation."] pub struct ConversionError (:: std :: borrow :: Cow < 'static , str >) ; impl :: std :: error :: Error for ConversionError { } impl :: std :: fmt :: Display for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Display :: fmt (& self . 0 , f) } } impl :: std :: fmt :: Debug for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Debug :: fmt (& self . 0 , f) } } impl From < & 'static str > for ConversionError { fn from (value : & 'static str) -> Self { Self (value . into ()) } } impl From < String > for ConversionError { fn from (value : String) -> Self { Self (value . into ()) } } } # [doc = "DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress (String) ; impl :: std :: ops :: Deref for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress > for String { fn from (value : DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress) -> Self { value . 0 } } impl From < & DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress { fn from (value : & DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId (String) ; impl :: std :: ops :: Deref for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId > for String { fn from (value : DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId) -> Self { value . 0 } } impl From < & DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId { fn from (value : & DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId) -> Self { value . clone () } } impl :: std :: str :: FromStr for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork { Variant0 (String) , Variant1 (f64) , } impl From < & DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork { fn from (value : & DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork) -> Self { value . clone () } } impl std :: str :: FromStr for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } } impl std :: convert :: TryFrom < & str > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: fmt :: Display for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } } impl From < f64 > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork { fn from (value : f64) -> Self { Self :: Variant1 (value) } } # [doc = "DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , pub success : bool , } impl From < & DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse > for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse { fn from (value : & DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse) -> Self { value . clone () } } # [doc = "DeleteProjectsProjectIdAaContractAaContract"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct DeleteProjectsProjectIdAaContractAaContract (String) ; impl :: std :: ops :: Deref for DeleteProjectsProjectIdAaContractAaContract { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < DeleteProjectsProjectIdAaContractAaContract > for String { fn from (value : DeleteProjectsProjectIdAaContractAaContract) -> Self { value . 0 } } impl From < & DeleteProjectsProjectIdAaContractAaContract > for DeleteProjectsProjectIdAaContractAaContract { fn from (value : & DeleteProjectsProjectIdAaContractAaContract) -> Self { value . clone () } } impl :: std :: str :: FromStr for DeleteProjectsProjectIdAaContractAaContract { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for DeleteProjectsProjectIdAaContractAaContract { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for DeleteProjectsProjectIdAaContractAaContract { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for DeleteProjectsProjectIdAaContractAaContract { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for DeleteProjectsProjectIdAaContractAaContract { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "DeleteProjectsProjectIdAaContractResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DeleteProjectsProjectIdAaContractResponse { pub success : bool , } impl From < & DeleteProjectsProjectIdAaContractResponse > for DeleteProjectsProjectIdAaContractResponse { fn from (value : & DeleteProjectsProjectIdAaContractResponse) -> Self { value . clone () } } # [doc = "DeleteProjectsProjectIdIntegrationsPagerdutyResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"description\": \"Success message\","] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DeleteProjectsProjectIdIntegrationsPagerdutyResponse { # [doc = "Success message"] pub message : String , } impl From < & DeleteProjectsProjectIdIntegrationsPagerdutyResponse > for DeleteProjectsProjectIdIntegrationsPagerdutyResponse { fn from (value : & DeleteProjectsProjectIdIntegrationsPagerdutyResponse) -> Self { value . clone () } } # [doc = "DeleteProjectsProjectIdIntegrationsSlackResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"description\": \"Success message\","] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DeleteProjectsProjectIdIntegrationsSlackResponse { # [doc = "Success message"] pub message : String , } impl From < & DeleteProjectsProjectIdIntegrationsSlackResponse > for DeleteProjectsProjectIdIntegrationsSlackResponse { fn from (value : & DeleteProjectsProjectIdIntegrationsSlackResponse) -> Self { value . clone () } } # [doc = "DeleteProjectsProjectIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DeleteProjectsProjectIdResponse { pub success : bool , } impl From < & DeleteProjectsProjectIdResponse > for DeleteProjectsProjectIdResponse { fn from (value : & DeleteProjectsProjectIdResponse) -> Self { value . clone () } } # [doc = "DeleteProjectsSavedBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"project_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DeleteProjectsSavedBody { pub project_id : uuid :: Uuid , } impl From < & DeleteProjectsSavedBody > for DeleteProjectsSavedBody { fn from (value : & DeleteProjectsSavedBody) -> Self { value . clone () } } # [doc = "DeleteProjectsSavedResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DeleteProjectsSavedResponse { pub success : bool , } impl From < & DeleteProjectsSavedResponse > for DeleteProjectsSavedResponse { fn from (value : & DeleteProjectsSavedResponse) -> Self { value . clone () } } # [doc = "DeleteTransfersAssertionAdoptersTransferIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DeleteTransfersAssertionAdoptersTransferIdResponse { pub message : String , } impl From < & DeleteTransfersAssertionAdoptersTransferIdResponse > for DeleteTransfersAssertionAdoptersTransferIdResponse { fn from (value : & DeleteTransfersAssertionAdoptersTransferIdResponse) -> Self { value . clone () } } # [doc = "DeleteTransfersProjectsTransferIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct DeleteTransfersProjectsTransferIdResponse { pub message : String , } impl From < & DeleteTransfersProjectsTransferIdResponse > for DeleteTransfersProjectsTransferIdResponse { fn from (value : & DeleteTransfersProjectsTransferIdResponse) -> Self { value . clone () } } # [doc = "GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress (String) ; impl :: std :: ops :: Deref for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress > for String { fn from (value : GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress) -> Self { value . 0 } } impl From < & GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress { fn from (value : & GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork { Variant0 (String) , Variant1 (f64) , } impl From < & GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork { fn from (value : & GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork) -> Self { value . clone () } } impl std :: str :: FromStr for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } } impl std :: convert :: TryFrom < & str > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: fmt :: Display for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } } impl From < f64 > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork { fn from (value : f64) -> Self { Self :: Variant1 (value) } } # [doc = "GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"assertions\","] # [doc = "        \"calldata\","] # [doc = "        \"total_batches\","] # [doc = "        \"total_calldata\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"assertions\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"assertion_id\","] # [doc = "              \"calldata\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"assertion_id\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"calldata\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\""] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"calldata\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"total_batches\": {"] # [doc = "          \"type\": \"number\""] # [doc = "        },"] # [doc = "        \"total_calldata\": {"] # [doc = "          \"type\": \"number\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"calldata\","] # [doc = "        \"message\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"calldata\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"message\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse { Variant0 { assertions : Vec < GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem > , calldata : Vec < String > , total_batches : f64 , total_calldata : f64 , } , Variant1 { calldata : Vec < String > , message : String , } , } impl From < & GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse { fn from (value : & GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse) -> Self { value . clone () } } # [doc = "GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_id\","] # [doc = "    \"calldata\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"calldata\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem { pub assertion_id : String , pub calldata : Vec < String > , } impl From < & GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem > for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem { fn from (value : & GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem) -> Self { value . clone () } } # [doc = "GetAssertionAdoptersAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionAdoptersAddress (String) ; impl :: std :: ops :: Deref for GetAssertionAdoptersAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionAdoptersAddress > for String { fn from (value : GetAssertionAdoptersAddress) -> Self { value . 0 } } impl From < & GetAssertionAdoptersAddress > for GetAssertionAdoptersAddress { fn from (value : & GetAssertionAdoptersAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionAdoptersAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionAdoptersAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionAdoptersAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionAdoptersAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionAdoptersAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionAdoptersNetwork"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum GetAssertionAdoptersNetwork { Variant0 (String) , Variant1 (f64) , } impl From < & GetAssertionAdoptersNetwork > for GetAssertionAdoptersNetwork { fn from (value : & GetAssertionAdoptersNetwork) -> Self { value . clone () } } impl std :: str :: FromStr for GetAssertionAdoptersNetwork { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } } impl std :: convert :: TryFrom < & str > for GetAssertionAdoptersNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetAssertionAdoptersNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetAssertionAdoptersNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: fmt :: Display for GetAssertionAdoptersNetwork { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } } impl From < f64 > for GetAssertionAdoptersNetwork { fn from (value : f64) -> Self { Self :: Variant1 (value) } } # [doc = "GetAssertionAdoptersNoProjectManager"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionAdoptersNoProjectManager (String) ; impl :: std :: ops :: Deref for GetAssertionAdoptersNoProjectManager { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionAdoptersNoProjectManager > for String { fn from (value : GetAssertionAdoptersNoProjectManager) -> Self { value . 0 } } impl From < & GetAssertionAdoptersNoProjectManager > for GetAssertionAdoptersNoProjectManager { fn from (value : & GetAssertionAdoptersNoProjectManager) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionAdoptersNoProjectManager { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionAdoptersNoProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionAdoptersNoProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionAdoptersNoProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionAdoptersNoProjectManager { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionAdoptersNoProjectResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"error\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"code\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"details\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetAssertionAdoptersNoProjectResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub code : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub details : Option < String > , pub error : String , } impl From < & GetAssertionAdoptersNoProjectResponse > for GetAssertionAdoptersNoProjectResponse { fn from (value : & GetAssertionAdoptersNoProjectResponse) -> Self { value . clone () } } # [doc = "GetAssertionAdoptersNoProjectResponseItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"assertion_adopter_manager\","] # [doc = "    \"contract_name\","] # [doc = "    \"id\","] # [doc = "    \"network\","] # [doc = "    \"registered_assertions\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"assertion_adopter_manager\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"contract_name\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"network\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"oneOf\": ["] # [doc = "        {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"number\""] # [doc = "        }"] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"registered_assertions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetAssertionAdoptersNoProjectResponseItem { pub address : GetAssertionAdoptersNoProjectResponseItemAddress , pub assertion_adopter_manager : GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager , pub contract_name : Option < String > , pub id : String , pub network : GetAssertionAdoptersNoProjectResponseItemNetwork , pub registered_assertions : Vec < String > , } impl From < & GetAssertionAdoptersNoProjectResponseItem > for GetAssertionAdoptersNoProjectResponseItem { fn from (value : & GetAssertionAdoptersNoProjectResponseItem) -> Self { value . clone () } } # [doc = "GetAssertionAdoptersNoProjectResponseItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionAdoptersNoProjectResponseItemAddress (String) ; impl :: std :: ops :: Deref for GetAssertionAdoptersNoProjectResponseItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionAdoptersNoProjectResponseItemAddress > for String { fn from (value : GetAssertionAdoptersNoProjectResponseItemAddress) -> Self { value . 0 } } impl From < & GetAssertionAdoptersNoProjectResponseItemAddress > for GetAssertionAdoptersNoProjectResponseItemAddress { fn from (value : & GetAssertionAdoptersNoProjectResponseItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionAdoptersNoProjectResponseItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionAdoptersNoProjectResponseItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionAdoptersNoProjectResponseItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionAdoptersNoProjectResponseItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionAdoptersNoProjectResponseItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager (String) ; impl :: std :: ops :: Deref for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager > for String { fn from (value : GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager) -> Self { value . 0 } } impl From < & GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager > for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager { fn from (value : & GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionAdoptersNoProjectResponseItemNetwork"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum GetAssertionAdoptersNoProjectResponseItemNetwork { Variant0 (String) , Variant1 (f64) , } impl From < & GetAssertionAdoptersNoProjectResponseItemNetwork > for GetAssertionAdoptersNoProjectResponseItemNetwork { fn from (value : & GetAssertionAdoptersNoProjectResponseItemNetwork) -> Self { value . clone () } } impl std :: str :: FromStr for GetAssertionAdoptersNoProjectResponseItemNetwork { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } } impl std :: convert :: TryFrom < & str > for GetAssertionAdoptersNoProjectResponseItemNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetAssertionAdoptersNoProjectResponseItemNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetAssertionAdoptersNoProjectResponseItemNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: fmt :: Display for GetAssertionAdoptersNoProjectResponseItemNetwork { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } } impl From < f64 > for GetAssertionAdoptersNoProjectResponseItemNetwork { fn from (value : f64) -> Self { Self :: Variant1 (value) } } # [doc = "GetAssertionAdoptersResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"error\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"code\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"details\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetAssertionAdoptersResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub code : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub details : Option < String > , pub error : String , } impl From < & GetAssertionAdoptersResponse > for GetAssertionAdoptersResponse { fn from (value : & GetAssertionAdoptersResponse) -> Self { value . clone () } } # [doc = "GetAssertionAdoptersResponseItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"assertion_adopter_manager\","] # [doc = "    \"id\","] # [doc = "    \"network\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"assertion_adopter_manager\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"contract_name\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^\\\\d+_0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"network\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"oneOf\": ["] # [doc = "        {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"number\""] # [doc = "        }"] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"registered_assertions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"updated_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetAssertionAdoptersResponseItem { pub address : GetAssertionAdoptersResponseItemAddress , pub assertion_adopter_manager : GetAssertionAdoptersResponseItemAssertionAdopterManager , # [serde (default , skip_serializing_if = "Option::is_none")] pub contract_name : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub created_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , pub id : GetAssertionAdoptersResponseItemId , pub network : GetAssertionAdoptersResponseItemNetwork , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub registered_assertions : Vec < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub updated_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , } impl From < & GetAssertionAdoptersResponseItem > for GetAssertionAdoptersResponseItem { fn from (value : & GetAssertionAdoptersResponseItem) -> Self { value . clone () } } # [doc = "GetAssertionAdoptersResponseItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionAdoptersResponseItemAddress (String) ; impl :: std :: ops :: Deref for GetAssertionAdoptersResponseItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionAdoptersResponseItemAddress > for String { fn from (value : GetAssertionAdoptersResponseItemAddress) -> Self { value . 0 } } impl From < & GetAssertionAdoptersResponseItemAddress > for GetAssertionAdoptersResponseItemAddress { fn from (value : & GetAssertionAdoptersResponseItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionAdoptersResponseItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionAdoptersResponseItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionAdoptersResponseItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionAdoptersResponseItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionAdoptersResponseItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionAdoptersResponseItemAssertionAdopterManager"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionAdoptersResponseItemAssertionAdopterManager (String) ; impl :: std :: ops :: Deref for GetAssertionAdoptersResponseItemAssertionAdopterManager { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionAdoptersResponseItemAssertionAdopterManager > for String { fn from (value : GetAssertionAdoptersResponseItemAssertionAdopterManager) -> Self { value . 0 } } impl From < & GetAssertionAdoptersResponseItemAssertionAdopterManager > for GetAssertionAdoptersResponseItemAssertionAdopterManager { fn from (value : & GetAssertionAdoptersResponseItemAssertionAdopterManager) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionAdoptersResponseItemAssertionAdopterManager { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionAdoptersResponseItemAssertionAdopterManager { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionAdoptersResponseItemAssertionAdopterManager { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionAdoptersResponseItemAssertionAdopterManager { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionAdoptersResponseItemAssertionAdopterManager { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionAdoptersResponseItemId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^\\\\d+_0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionAdoptersResponseItemId (String) ; impl :: std :: ops :: Deref for GetAssertionAdoptersResponseItemId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionAdoptersResponseItemId > for String { fn from (value : GetAssertionAdoptersResponseItemId) -> Self { value . 0 } } impl From < & GetAssertionAdoptersResponseItemId > for GetAssertionAdoptersResponseItemId { fn from (value : & GetAssertionAdoptersResponseItemId) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionAdoptersResponseItemId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^\\d+_0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^\\d+_0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionAdoptersResponseItemId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionAdoptersResponseItemId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionAdoptersResponseItemId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionAdoptersResponseItemId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionAdoptersResponseItemNetwork"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum GetAssertionAdoptersResponseItemNetwork { Variant0 (String) , Variant1 (f64) , } impl From < & GetAssertionAdoptersResponseItemNetwork > for GetAssertionAdoptersResponseItemNetwork { fn from (value : & GetAssertionAdoptersResponseItemNetwork) -> Self { value . clone () } } impl std :: str :: FromStr for GetAssertionAdoptersResponseItemNetwork { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } } impl std :: convert :: TryFrom < & str > for GetAssertionAdoptersResponseItemNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetAssertionAdoptersResponseItemNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetAssertionAdoptersResponseItemNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: fmt :: Display for GetAssertionAdoptersResponseItemNetwork { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } } impl From < f64 > for GetAssertionAdoptersResponseItemNetwork { fn from (value : f64) -> Self { Self :: Variant1 (value) } } # [doc = "GetAssertionsAdopterAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionsAdopterAddress (String) ; impl :: std :: ops :: Deref for GetAssertionsAdopterAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionsAdopterAddress > for String { fn from (value : GetAssertionsAdopterAddress) -> Self { value . 0 } } impl From < & GetAssertionsAdopterAddress > for GetAssertionsAdopterAddress { fn from (value : & GetAssertionsAdopterAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionsAdopterAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionsAdopterAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionsAdopterAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionsAdopterAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionsAdopterAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionsEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"all\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\","] # [doc = "    \"all\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetAssertionsEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , # [serde (rename = "all")] All , } impl From < & GetAssertionsEnvironment > for GetAssertionsEnvironment { fn from (value : & GetAssertionsEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetAssertionsEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , Self :: All => write ! (f , "all") , } } } impl std :: str :: FromStr for GetAssertionsEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , "all" => Ok (Self :: All) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetAssertionsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetAssertionsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetAssertionsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl Default for GetAssertionsEnvironment { fn default () -> Self { GetAssertionsEnvironment :: All } } # [doc = "GetAssertionsNetwork"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"1\","] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum GetAssertionsNetwork { Variant0 (String) , Variant1 (f64) , } impl From < & GetAssertionsNetwork > for GetAssertionsNetwork { fn from (value : & GetAssertionsNetwork) -> Self { value . clone () } } impl Default for GetAssertionsNetwork { fn default () -> Self { GetAssertionsNetwork :: Variant0 ("1" . to_string ()) } } impl std :: str :: FromStr for GetAssertionsNetwork { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } } impl std :: convert :: TryFrom < & str > for GetAssertionsNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetAssertionsNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetAssertionsNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: fmt :: Display for GetAssertionsNetwork { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } } impl From < f64 > for GetAssertionsNetwork { fn from (value : f64) -> Self { Self :: Variant1 (value) } } # [doc = "GetAssertionsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_functions\","] # [doc = "          \"assertion_id\","] # [doc = "          \"bytecode\","] # [doc = "          \"constructor_abi_signature\","] # [doc = "          \"constructor_args\","] # [doc = "          \"contract_name\","] # [doc = "          \"linked_adopters\","] # [doc = "          \"registered_address\","] # [doc = "          \"registered_at\","] # [doc = "          \"signature\","] # [doc = "          \"source_code\","] # [doc = "          \"status\","] # [doc = "          \"submitted_at\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_functions\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "          },"] # [doc = "          \"bytecode\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"constructor_abi_signature\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"constructor_args\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {}"] # [doc = "          },"] # [doc = "          \"contract_name\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"environment\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"staging\","] # [doc = "              \"production\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"linked_adopters\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"registered_address\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ],"] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "          },"] # [doc = "          \"registered_at\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ],"] # [doc = "            \"format\": \"date-time\""] # [doc = "          },"] # [doc = "          \"signature\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"source_code\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"status\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"pending\","] # [doc = "              \"submitted\","] # [doc = "              \"registered\","] # [doc = "              \"removed\","] # [doc = "              \"failed\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"submitted_at\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"date-time\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_functions\","] # [doc = "          \"assertion_id\","] # [doc = "          \"bytecode\","] # [doc = "          \"constructor_abi_signature\","] # [doc = "          \"constructor_args\","] # [doc = "          \"contract_name\","] # [doc = "          \"linked_adopters\","] # [doc = "          \"registered_address\","] # [doc = "          \"registered_at\","] # [doc = "          \"signature\","] # [doc = "          \"source_code\","] # [doc = "          \"status\","] # [doc = "          \"submitted_at\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"activation_block\": {"] # [doc = "            \"type\": \"number\""] # [doc = "          },"] # [doc = "          \"assertion_functions\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "          },"] # [doc = "          \"bytecode\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"constructor_abi_signature\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"constructor_args\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {}"] # [doc = "          },"] # [doc = "          \"contract_name\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"deactivation_block\": {"] # [doc = "            \"type\": ["] # [doc = "              \"number\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"environment\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"staging\","] # [doc = "              \"production\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"linked_adopters\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"ponder_adopters\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"object\","] # [doc = "              \"required\": ["] # [doc = "                \"assertion_adopter_address\","] # [doc = "                \"chain_id\","] # [doc = "                \"id\","] # [doc = "                \"manager\""] # [doc = "              ],"] # [doc = "              \"properties\": {"] # [doc = "                \"assertion_adopter_address\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                },"] # [doc = "                \"chain_id\": {"] # [doc = "                  \"type\": \"number\""] # [doc = "                },"] # [doc = "                \"id\": {"] # [doc = "                  \"type\": \"string\""] # [doc = "                },"] # [doc = "                \"manager\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"registered_address\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ],"] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "          },"] # [doc = "          \"registered_at\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ],"] # [doc = "            \"format\": \"date-time\""] # [doc = "          },"] # [doc = "          \"signature\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"source_code\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"status\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"pending\","] # [doc = "              \"submitted\","] # [doc = "              \"registered\","] # [doc = "              \"removed\","] # [doc = "              \"failed\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"submitted_at\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"date-time\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum GetAssertionsResponse { Variant0 (Vec < GetAssertionsResponseVariant0Item >) , Variant1 (Vec < GetAssertionsResponseVariant1Item >) , } impl From < & GetAssertionsResponse > for GetAssertionsResponse { fn from (value : & GetAssertionsResponse) -> Self { value . clone () } } impl From < Vec < GetAssertionsResponseVariant0Item > > for GetAssertionsResponse { fn from (value : Vec < GetAssertionsResponseVariant0Item >) -> Self { Self :: Variant0 (value) } } impl From < Vec < GetAssertionsResponseVariant1Item > > for GetAssertionsResponse { fn from (value : Vec < GetAssertionsResponseVariant1Item >) -> Self { Self :: Variant1 (value) } } # [doc = "GetAssertionsResponseVariant0Item"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_functions\","] # [doc = "    \"assertion_id\","] # [doc = "    \"bytecode\","] # [doc = "    \"constructor_abi_signature\","] # [doc = "    \"constructor_args\","] # [doc = "    \"contract_name\","] # [doc = "    \"linked_adopters\","] # [doc = "    \"registered_address\","] # [doc = "    \"registered_at\","] # [doc = "    \"signature\","] # [doc = "    \"source_code\","] # [doc = "    \"status\","] # [doc = "    \"submitted_at\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_functions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    },"] # [doc = "    \"bytecode\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"constructor_abi_signature\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"constructor_args\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {}"] # [doc = "    },"] # [doc = "    \"contract_name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"linked_adopters\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"registered_address\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"registered_at\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"signature\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"source_code\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"pending\","] # [doc = "        \"submitted\","] # [doc = "        \"registered\","] # [doc = "        \"removed\","] # [doc = "        \"failed\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"submitted_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetAssertionsResponseVariant0Item { pub assertion_functions : Vec < String > , pub assertion_id : GetAssertionsResponseVariant0ItemAssertionId , pub bytecode : Option < String > , pub constructor_abi_signature : Option < String > , pub constructor_args : Vec < :: serde_json :: Value > , pub contract_name : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub environment : Option < GetAssertionsResponseVariant0ItemEnvironment > , pub linked_adopters : Vec < GetAssertionsResponseVariant0ItemLinkedAdoptersItem > , pub registered_address : Option < GetAssertionsResponseVariant0ItemRegisteredAddress > , pub registered_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , pub signature : String , pub source_code : Option < String > , pub status : GetAssertionsResponseVariant0ItemStatus , pub submitted_at : chrono :: DateTime < chrono :: offset :: Utc > , } impl From < & GetAssertionsResponseVariant0Item > for GetAssertionsResponseVariant0Item { fn from (value : & GetAssertionsResponseVariant0Item) -> Self { value . clone () } } # [doc = "GetAssertionsResponseVariant0ItemAssertionId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionsResponseVariant0ItemAssertionId (String) ; impl :: std :: ops :: Deref for GetAssertionsResponseVariant0ItemAssertionId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionsResponseVariant0ItemAssertionId > for String { fn from (value : GetAssertionsResponseVariant0ItemAssertionId) -> Self { value . 0 } } impl From < & GetAssertionsResponseVariant0ItemAssertionId > for GetAssertionsResponseVariant0ItemAssertionId { fn from (value : & GetAssertionsResponseVariant0ItemAssertionId) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionsResponseVariant0ItemAssertionId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant0ItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant0ItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionsResponseVariant0ItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionsResponseVariant0ItemAssertionId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionsResponseVariant0ItemEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetAssertionsResponseVariant0ItemEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & GetAssertionsResponseVariant0ItemEnvironment > for GetAssertionsResponseVariant0ItemEnvironment { fn from (value : & GetAssertionsResponseVariant0ItemEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetAssertionsResponseVariant0ItemEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for GetAssertionsResponseVariant0ItemEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant0ItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant0ItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetAssertionsResponseVariant0ItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetAssertionsResponseVariant0ItemLinkedAdoptersItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionsResponseVariant0ItemLinkedAdoptersItem (String) ; impl :: std :: ops :: Deref for GetAssertionsResponseVariant0ItemLinkedAdoptersItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionsResponseVariant0ItemLinkedAdoptersItem > for String { fn from (value : GetAssertionsResponseVariant0ItemLinkedAdoptersItem) -> Self { value . 0 } } impl From < & GetAssertionsResponseVariant0ItemLinkedAdoptersItem > for GetAssertionsResponseVariant0ItemLinkedAdoptersItem { fn from (value : & GetAssertionsResponseVariant0ItemLinkedAdoptersItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionsResponseVariant0ItemLinkedAdoptersItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant0ItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant0ItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionsResponseVariant0ItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionsResponseVariant0ItemLinkedAdoptersItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionsResponseVariant0ItemRegisteredAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionsResponseVariant0ItemRegisteredAddress (String) ; impl :: std :: ops :: Deref for GetAssertionsResponseVariant0ItemRegisteredAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionsResponseVariant0ItemRegisteredAddress > for String { fn from (value : GetAssertionsResponseVariant0ItemRegisteredAddress) -> Self { value . 0 } } impl From < & GetAssertionsResponseVariant0ItemRegisteredAddress > for GetAssertionsResponseVariant0ItemRegisteredAddress { fn from (value : & GetAssertionsResponseVariant0ItemRegisteredAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionsResponseVariant0ItemRegisteredAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant0ItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant0ItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionsResponseVariant0ItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionsResponseVariant0ItemRegisteredAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionsResponseVariant0ItemStatus"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"pending\","] # [doc = "    \"submitted\","] # [doc = "    \"registered\","] # [doc = "    \"removed\","] # [doc = "    \"failed\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetAssertionsResponseVariant0ItemStatus { # [serde (rename = "pending")] Pending , # [serde (rename = "submitted")] Submitted , # [serde (rename = "registered")] Registered , # [serde (rename = "removed")] Removed , # [serde (rename = "failed")] Failed , } impl From < & GetAssertionsResponseVariant0ItemStatus > for GetAssertionsResponseVariant0ItemStatus { fn from (value : & GetAssertionsResponseVariant0ItemStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetAssertionsResponseVariant0ItemStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Pending => write ! (f , "pending") , Self :: Submitted => write ! (f , "submitted") , Self :: Registered => write ! (f , "registered") , Self :: Removed => write ! (f , "removed") , Self :: Failed => write ! (f , "failed") , } } } impl std :: str :: FromStr for GetAssertionsResponseVariant0ItemStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "pending" => Ok (Self :: Pending) , "submitted" => Ok (Self :: Submitted) , "registered" => Ok (Self :: Registered) , "removed" => Ok (Self :: Removed) , "failed" => Ok (Self :: Failed) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant0ItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant0ItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetAssertionsResponseVariant0ItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetAssertionsResponseVariant1Item"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_functions\","] # [doc = "    \"assertion_id\","] # [doc = "    \"bytecode\","] # [doc = "    \"constructor_abi_signature\","] # [doc = "    \"constructor_args\","] # [doc = "    \"contract_name\","] # [doc = "    \"linked_adopters\","] # [doc = "    \"registered_address\","] # [doc = "    \"registered_at\","] # [doc = "    \"signature\","] # [doc = "    \"source_code\","] # [doc = "    \"status\","] # [doc = "    \"submitted_at\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"activation_block\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"assertion_functions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    },"] # [doc = "    \"bytecode\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"constructor_abi_signature\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"constructor_args\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {}"] # [doc = "    },"] # [doc = "    \"contract_name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"deactivation_block\": {"] # [doc = "      \"type\": ["] # [doc = "        \"number\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"linked_adopters\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"ponder_adopters\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopter_address\","] # [doc = "          \"chain_id\","] # [doc = "          \"id\","] # [doc = "          \"manager\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopter_address\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "          },"] # [doc = "          \"chain_id\": {"] # [doc = "            \"type\": \"number\""] # [doc = "          },"] # [doc = "          \"id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"manager\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"registered_address\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"registered_at\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"signature\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"source_code\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"pending\","] # [doc = "        \"submitted\","] # [doc = "        \"registered\","] # [doc = "        \"removed\","] # [doc = "        \"failed\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"submitted_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetAssertionsResponseVariant1Item { # [serde (default , skip_serializing_if = "Option::is_none")] pub activation_block : Option < f64 > , pub assertion_functions : Vec < String > , pub assertion_id : GetAssertionsResponseVariant1ItemAssertionId , pub bytecode : Option < String > , pub constructor_abi_signature : Option < String > , pub constructor_args : Vec < :: serde_json :: Value > , pub contract_name : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub deactivation_block : Option < f64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub environment : Option < GetAssertionsResponseVariant1ItemEnvironment > , pub linked_adopters : Vec < GetAssertionsResponseVariant1ItemLinkedAdoptersItem > , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub ponder_adopters : Vec < GetAssertionsResponseVariant1ItemPonderAdoptersItem > , pub registered_address : Option < GetAssertionsResponseVariant1ItemRegisteredAddress > , pub registered_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , pub signature : String , pub source_code : Option < String > , pub status : GetAssertionsResponseVariant1ItemStatus , pub submitted_at : chrono :: DateTime < chrono :: offset :: Utc > , } impl From < & GetAssertionsResponseVariant1Item > for GetAssertionsResponseVariant1Item { fn from (value : & GetAssertionsResponseVariant1Item) -> Self { value . clone () } } # [doc = "GetAssertionsResponseVariant1ItemAssertionId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionsResponseVariant1ItemAssertionId (String) ; impl :: std :: ops :: Deref for GetAssertionsResponseVariant1ItemAssertionId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionsResponseVariant1ItemAssertionId > for String { fn from (value : GetAssertionsResponseVariant1ItemAssertionId) -> Self { value . 0 } } impl From < & GetAssertionsResponseVariant1ItemAssertionId > for GetAssertionsResponseVariant1ItemAssertionId { fn from (value : & GetAssertionsResponseVariant1ItemAssertionId) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionsResponseVariant1ItemAssertionId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant1ItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant1ItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionsResponseVariant1ItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionsResponseVariant1ItemAssertionId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionsResponseVariant1ItemEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetAssertionsResponseVariant1ItemEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & GetAssertionsResponseVariant1ItemEnvironment > for GetAssertionsResponseVariant1ItemEnvironment { fn from (value : & GetAssertionsResponseVariant1ItemEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetAssertionsResponseVariant1ItemEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for GetAssertionsResponseVariant1ItemEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant1ItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant1ItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetAssertionsResponseVariant1ItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetAssertionsResponseVariant1ItemLinkedAdoptersItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionsResponseVariant1ItemLinkedAdoptersItem (String) ; impl :: std :: ops :: Deref for GetAssertionsResponseVariant1ItemLinkedAdoptersItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionsResponseVariant1ItemLinkedAdoptersItem > for String { fn from (value : GetAssertionsResponseVariant1ItemLinkedAdoptersItem) -> Self { value . 0 } } impl From < & GetAssertionsResponseVariant1ItemLinkedAdoptersItem > for GetAssertionsResponseVariant1ItemLinkedAdoptersItem { fn from (value : & GetAssertionsResponseVariant1ItemLinkedAdoptersItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionsResponseVariant1ItemLinkedAdoptersItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant1ItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant1ItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionsResponseVariant1ItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionsResponseVariant1ItemLinkedAdoptersItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionsResponseVariant1ItemPonderAdoptersItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_address\","] # [doc = "    \"chain_id\","] # [doc = "    \"id\","] # [doc = "    \"manager\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"chain_id\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"manager\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetAssertionsResponseVariant1ItemPonderAdoptersItem { pub assertion_adopter_address : GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress , pub chain_id : f64 , pub id : String , pub manager : GetAssertionsResponseVariant1ItemPonderAdoptersItemManager , } impl From < & GetAssertionsResponseVariant1ItemPonderAdoptersItem > for GetAssertionsResponseVariant1ItemPonderAdoptersItem { fn from (value : & GetAssertionsResponseVariant1ItemPonderAdoptersItem) -> Self { value . clone () } } # [doc = "GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress (String) ; impl :: std :: ops :: Deref for GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress > for String { fn from (value : GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress) -> Self { value . 0 } } impl From < & GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress > for GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress { fn from (value : & GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionsResponseVariant1ItemPonderAdoptersItemAssertionAdopterAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionsResponseVariant1ItemPonderAdoptersItemManager"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionsResponseVariant1ItemPonderAdoptersItemManager (String) ; impl :: std :: ops :: Deref for GetAssertionsResponseVariant1ItemPonderAdoptersItemManager { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionsResponseVariant1ItemPonderAdoptersItemManager > for String { fn from (value : GetAssertionsResponseVariant1ItemPonderAdoptersItemManager) -> Self { value . 0 } } impl From < & GetAssertionsResponseVariant1ItemPonderAdoptersItemManager > for GetAssertionsResponseVariant1ItemPonderAdoptersItemManager { fn from (value : & GetAssertionsResponseVariant1ItemPonderAdoptersItemManager) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionsResponseVariant1ItemPonderAdoptersItemManager { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant1ItemPonderAdoptersItemManager { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant1ItemPonderAdoptersItemManager { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionsResponseVariant1ItemPonderAdoptersItemManager { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionsResponseVariant1ItemPonderAdoptersItemManager { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionsResponseVariant1ItemRegisteredAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetAssertionsResponseVariant1ItemRegisteredAddress (String) ; impl :: std :: ops :: Deref for GetAssertionsResponseVariant1ItemRegisteredAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetAssertionsResponseVariant1ItemRegisteredAddress > for String { fn from (value : GetAssertionsResponseVariant1ItemRegisteredAddress) -> Self { value . 0 } } impl From < & GetAssertionsResponseVariant1ItemRegisteredAddress > for GetAssertionsResponseVariant1ItemRegisteredAddress { fn from (value : & GetAssertionsResponseVariant1ItemRegisteredAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetAssertionsResponseVariant1ItemRegisteredAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant1ItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant1ItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetAssertionsResponseVariant1ItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetAssertionsResponseVariant1ItemRegisteredAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetAssertionsResponseVariant1ItemStatus"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"pending\","] # [doc = "    \"submitted\","] # [doc = "    \"registered\","] # [doc = "    \"removed\","] # [doc = "    \"failed\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetAssertionsResponseVariant1ItemStatus { # [serde (rename = "pending")] Pending , # [serde (rename = "submitted")] Submitted , # [serde (rename = "registered")] Registered , # [serde (rename = "removed")] Removed , # [serde (rename = "failed")] Failed , } impl From < & GetAssertionsResponseVariant1ItemStatus > for GetAssertionsResponseVariant1ItemStatus { fn from (value : & GetAssertionsResponseVariant1ItemStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetAssertionsResponseVariant1ItemStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Pending => write ! (f , "pending") , Self :: Submitted => write ! (f , "submitted") , Self :: Registered => write ! (f , "registered") , Self :: Removed => write ! (f , "removed") , Self :: Failed => write ! (f , "failed") , } } } impl std :: str :: FromStr for GetAssertionsResponseVariant1ItemStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "pending" => Ok (Self :: Pending) , "submitted" => Ok (Self :: Submitted) , "registered" => Ok (Self :: Registered) , "removed" => Ok (Self :: Removed) , "failed" => Ok (Self :: Failed) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetAssertionsResponseVariant1ItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetAssertionsResponseVariant1ItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetAssertionsResponseVariant1ItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetCliAuthCodeResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"code\","] # [doc = "    \"deviceSecret\","] # [doc = "    \"expiresAt\","] # [doc = "    \"sessionId\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"code\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 6,"] # [doc = "      \"minLength\": 6"] # [doc = "    },"] # [doc = "    \"deviceSecret\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"expiresAt\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"sessionId\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetCliAuthCodeResponse { pub code : GetCliAuthCodeResponseCode , # [serde (rename = "deviceSecret")] pub device_secret : String , # [serde (rename = "expiresAt")] pub expires_at : chrono :: DateTime < chrono :: offset :: Utc > , # [serde (rename = "sessionId")] pub session_id : uuid :: Uuid , } impl From < & GetCliAuthCodeResponse > for GetCliAuthCodeResponse { fn from (value : & GetCliAuthCodeResponse) -> Self { value . clone () } } # [doc = "GetCliAuthCodeResponseCode"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 6,"] # [doc = "  \"minLength\": 6"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetCliAuthCodeResponseCode (String) ; impl :: std :: ops :: Deref for GetCliAuthCodeResponseCode { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetCliAuthCodeResponseCode > for String { fn from (value : GetCliAuthCodeResponseCode) -> Self { value . 0 } } impl From < & GetCliAuthCodeResponseCode > for GetCliAuthCodeResponseCode { fn from (value : & GetCliAuthCodeResponseCode) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetCliAuthCodeResponseCode { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 6usize { return Err ("longer than 6 characters" . into ()) ; } if value . len () < 6usize { return Err ("shorter than 6 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetCliAuthCodeResponseCode { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetCliAuthCodeResponseCode { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetCliAuthCodeResponseCode { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetCliAuthCodeResponseCode { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetCliAuthStatusResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"verified\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"refresh_token\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"token\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"verified\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetCliAuthStatusResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub address : Option < GetCliAuthStatusResponseAddress > , # [serde (default , skip_serializing_if = "Option::is_none")] pub refresh_token : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub token : Option < String > , pub verified : bool , } impl From < & GetCliAuthStatusResponse > for GetCliAuthStatusResponse { fn from (value : & GetCliAuthStatusResponse) -> Self { value . clone () } } # [doc = "GetCliAuthStatusResponseAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetCliAuthStatusResponseAddress (String) ; impl :: std :: ops :: Deref for GetCliAuthStatusResponseAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetCliAuthStatusResponseAddress > for String { fn from (value : GetCliAuthStatusResponseAddress) -> Self { value . 0 } } impl From < & GetCliAuthStatusResponseAddress > for GetCliAuthStatusResponseAddress { fn from (value : & GetCliAuthStatusResponseAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetCliAuthStatusResponseAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetCliAuthStatusResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetCliAuthStatusResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetCliAuthStatusResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetCliAuthStatusResponseAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetHealthResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"environment\","] # [doc = "    \"status\","] # [doc = "    \"timestamp\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"environment\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"ok\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"timestamp\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetHealthResponse { pub environment : String , pub status : GetHealthResponseStatus , pub timestamp : String , } impl From < & GetHealthResponse > for GetHealthResponse { fn from (value : & GetHealthResponse) -> Self { value . clone () } } # [doc = "GetHealthResponseStatus"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ok\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetHealthResponseStatus { # [serde (rename = "ok")] Ok , } impl From < & GetHealthResponseStatus > for GetHealthResponseStatus { fn from (value : & GetHealthResponseStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetHealthResponseStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Ok => write ! (f , "ok") , } } } impl std :: str :: FromStr for GetHealthResponseStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "ok" => Ok (Self :: Ok) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetHealthResponseStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetHealthResponseStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetHealthResponseStatus { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetIncidentsIncidentIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion\","] # [doc = "    \"assertion_adopter\","] # [doc = "    \"assertion_adopter_id\","] # [doc = "    \"assertion_id\","] # [doc = "    \"chain_id\","] # [doc = "    \"created_at\","] # [doc = "    \"environment\","] # [doc = "    \"incident_id\","] # [doc = "    \"invalidating_transactions\","] # [doc = "    \"traces_completed\","] # [doc = "    \"traces_pending\","] # [doc = "    \"transaction_count\","] # [doc = "    \"window_start\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"assertion_id\","] # [doc = "        \"description\","] # [doc = "        \"title\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"assertion_id\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"description\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"title\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertion_adopter\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"address\","] # [doc = "        \"id\","] # [doc = "        \"name\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"address\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"id\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"name\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertion_adopter_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"chain_id\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"incident_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"invalidating_transactions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"block_number\","] # [doc = "          \"calldata\","] # [doc = "          \"debug_traces\","] # [doc = "          \"from_address\","] # [doc = "          \"id\","] # [doc = "          \"incident_timestamp\","] # [doc = "          \"landed_on_chain\","] # [doc = "          \"revert_reason\","] # [doc = "          \"to_address\","] # [doc = "          \"transaction_hash\","] # [doc = "          \"value\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"block_env\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"additionalProperties\": {}"] # [doc = "          },"] # [doc = "          \"block_number\": {"] # [doc = "            \"type\": ["] # [doc = "              \"integer\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"calldata\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"debug_traces\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"object\","] # [doc = "              \"required\": ["] # [doc = "                \"environment\","] # [doc = "                \"error\","] # [doc = "                \"id\","] # [doc = "                \"status\","] # [doc = "                \"trace_content\","] # [doc = "                \"trace_format\","] # [doc = "                \"tracer_duration_ms\""] # [doc = "              ],"] # [doc = "              \"properties\": {"] # [doc = "                \"created_at\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"format\": \"date-time\""] # [doc = "                },"] # [doc = "                \"environment\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"enum\": ["] # [doc = "                    \"staging\","] # [doc = "                    \"production\""] # [doc = "                  ]"] # [doc = "                },"] # [doc = "                \"error\": {"] # [doc = "                  \"type\": ["] # [doc = "                    \"string\","] # [doc = "                    \"null\""] # [doc = "                  ]"] # [doc = "                },"] # [doc = "                \"id\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"format\": \"uuid\""] # [doc = "                },"] # [doc = "                \"status\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"enum\": ["] # [doc = "                    \"pending\","] # [doc = "                    \"in_progress\","] # [doc = "                    \"completed\","] # [doc = "                    \"failed\","] # [doc = "                    \"skipped\""] # [doc = "                  ]"] # [doc = "                },"] # [doc = "                \"trace_content\": {"] # [doc = "                  \"type\": ["] # [doc = "                    \"string\","] # [doc = "                    \"null\""] # [doc = "                  ]"] # [doc = "                },"] # [doc = "                \"trace_format\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"enum\": ["] # [doc = "                    \"ansi\","] # [doc = "                    \"plain\","] # [doc = "                    \"json\""] # [doc = "                  ]"] # [doc = "                },"] # [doc = "                \"tracer_completed_at\": {"] # [doc = "                  \"type\": ["] # [doc = "                    \"string\","] # [doc = "                    \"null\""] # [doc = "                  ],"] # [doc = "                  \"format\": \"date-time\""] # [doc = "                },"] # [doc = "                \"tracer_duration_ms\": {"] # [doc = "                  \"type\": ["] # [doc = "                    \"integer\","] # [doc = "                    \"null\""] # [doc = "                  ]"] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"from_address\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"uuid\""] # [doc = "          },"] # [doc = "          \"incident_timestamp\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"date-time\""] # [doc = "          },"] # [doc = "          \"landed_on_chain\": {"] # [doc = "            \"type\": ["] # [doc = "              \"boolean\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"previous_transactions\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {}"] # [doc = "          },"] # [doc = "          \"revert_reason\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"to_address\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"transaction_hash\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "          },"] # [doc = "          \"value\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"traces_completed\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"traces_pending\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"transaction_count\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"window_start\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetIncidentsIncidentIdResponse { pub assertion : GetIncidentsIncidentIdResponseAssertion , pub assertion_adopter : GetIncidentsIncidentIdResponseAssertionAdopter , pub assertion_adopter_id : String , pub assertion_id : String , pub chain_id : std :: num :: NonZeroU64 , pub created_at : chrono :: DateTime < chrono :: offset :: Utc > , pub environment : GetIncidentsIncidentIdResponseEnvironment , pub incident_id : uuid :: Uuid , pub invalidating_transactions : Vec < GetIncidentsIncidentIdResponseInvalidatingTransactionsItem > , pub traces_completed : i64 , pub traces_pending : i64 , pub transaction_count : i64 , pub window_start : chrono :: DateTime < chrono :: offset :: Utc > , } impl From < & GetIncidentsIncidentIdResponse > for GetIncidentsIncidentIdResponse { fn from (value : & GetIncidentsIncidentIdResponse) -> Self { value . clone () } } # [doc = "GetIncidentsIncidentIdResponseAssertion"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_id\","] # [doc = "    \"description\","] # [doc = "    \"title\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"title\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetIncidentsIncidentIdResponseAssertion { pub assertion_id : String , pub description : Option < String > , pub title : Option < String > , } impl From < & GetIncidentsIncidentIdResponseAssertion > for GetIncidentsIncidentIdResponseAssertion { fn from (value : & GetIncidentsIncidentIdResponseAssertion) -> Self { value . clone () } } # [doc = "GetIncidentsIncidentIdResponseAssertionAdopter"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"id\","] # [doc = "    \"name\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetIncidentsIncidentIdResponseAssertionAdopter { pub address : String , pub id : String , pub name : Option < String > , } impl From < & GetIncidentsIncidentIdResponseAssertionAdopter > for GetIncidentsIncidentIdResponseAssertionAdopter { fn from (value : & GetIncidentsIncidentIdResponseAssertionAdopter) -> Self { value . clone () } } # [doc = "GetIncidentsIncidentIdResponseEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetIncidentsIncidentIdResponseEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & GetIncidentsIncidentIdResponseEnvironment > for GetIncidentsIncidentIdResponseEnvironment { fn from (value : & GetIncidentsIncidentIdResponseEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetIncidentsIncidentIdResponseEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for GetIncidentsIncidentIdResponseEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetIncidentsIncidentIdResponseEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetIncidentsIncidentIdResponseEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetIncidentsIncidentIdResponseEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetIncidentsIncidentIdResponseInvalidatingTransactionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"block_number\","] # [doc = "    \"calldata\","] # [doc = "    \"debug_traces\","] # [doc = "    \"from_address\","] # [doc = "    \"id\","] # [doc = "    \"incident_timestamp\","] # [doc = "    \"landed_on_chain\","] # [doc = "    \"revert_reason\","] # [doc = "    \"to_address\","] # [doc = "    \"transaction_hash\","] # [doc = "    \"value\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"block_env\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"additionalProperties\": {}"] # [doc = "    },"] # [doc = "    \"block_number\": {"] # [doc = "      \"type\": ["] # [doc = "        \"integer\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"calldata\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"debug_traces\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"environment\","] # [doc = "          \"error\","] # [doc = "          \"id\","] # [doc = "          \"status\","] # [doc = "          \"trace_content\","] # [doc = "          \"trace_format\","] # [doc = "          \"tracer_duration_ms\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"created_at\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"date-time\""] # [doc = "          },"] # [doc = "          \"environment\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"staging\","] # [doc = "              \"production\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"error\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"uuid\""] # [doc = "          },"] # [doc = "          \"status\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"pending\","] # [doc = "              \"in_progress\","] # [doc = "              \"completed\","] # [doc = "              \"failed\","] # [doc = "              \"skipped\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"trace_content\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"trace_format\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"ansi\","] # [doc = "              \"plain\","] # [doc = "              \"json\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"tracer_completed_at\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ],"] # [doc = "            \"format\": \"date-time\""] # [doc = "          },"] # [doc = "          \"tracer_duration_ms\": {"] # [doc = "            \"type\": ["] # [doc = "              \"integer\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"from_address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"incident_timestamp\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"landed_on_chain\": {"] # [doc = "      \"type\": ["] # [doc = "        \"boolean\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"previous_transactions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {}"] # [doc = "    },"] # [doc = "    \"revert_reason\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"to_address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"transaction_hash\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    },"] # [doc = "    \"value\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetIncidentsIncidentIdResponseInvalidatingTransactionsItem { # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub block_env : :: serde_json :: Map < String , :: serde_json :: Value > , pub block_number : Option < i64 > , pub calldata : Option < String > , pub debug_traces : Vec < GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItem > , pub from_address : String , pub id : uuid :: Uuid , pub incident_timestamp : chrono :: DateTime < chrono :: offset :: Utc > , pub landed_on_chain : Option < bool > , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub previous_transactions : Vec < :: serde_json :: Value > , pub revert_reason : Option < String > , pub to_address : String , pub transaction_hash : GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash , pub value : String , } impl From < & GetIncidentsIncidentIdResponseInvalidatingTransactionsItem > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItem { fn from (value : & GetIncidentsIncidentIdResponseInvalidatingTransactionsItem) -> Self { value . clone () } } # [doc = "GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"environment\","] # [doc = "    \"error\","] # [doc = "    \"id\","] # [doc = "    \"status\","] # [doc = "    \"trace_content\","] # [doc = "    \"trace_format\","] # [doc = "    \"tracer_duration_ms\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"pending\","] # [doc = "        \"in_progress\","] # [doc = "        \"completed\","] # [doc = "        \"failed\","] # [doc = "        \"skipped\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"trace_content\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"trace_format\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"ansi\","] # [doc = "        \"plain\","] # [doc = "        \"json\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"tracer_completed_at\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"tracer_duration_ms\": {"] # [doc = "      \"type\": ["] # [doc = "        \"integer\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItem { # [serde (default , skip_serializing_if = "Option::is_none")] pub created_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , pub environment : GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment , pub error : Option < String > , pub id : uuid :: Uuid , pub status : GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus , pub trace_content : Option < String > , pub trace_format : GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat , # [serde (default , skip_serializing_if = "Option::is_none")] pub tracer_completed_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , pub tracer_duration_ms : Option < i64 > , } impl From < & GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItem > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItem { fn from (value : & GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItem) -> Self { value . clone () } } # [doc = "GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment { fn from (value : & GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"pending\","] # [doc = "    \"in_progress\","] # [doc = "    \"completed\","] # [doc = "    \"failed\","] # [doc = "    \"skipped\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus { # [serde (rename = "pending")] Pending , # [serde (rename = "in_progress")] InProgress , # [serde (rename = "completed")] Completed , # [serde (rename = "failed")] Failed , # [serde (rename = "skipped")] Skipped , } impl From < & GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus { fn from (value : & GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Pending => write ! (f , "pending") , Self :: InProgress => write ! (f , "in_progress") , Self :: Completed => write ! (f , "completed") , Self :: Failed => write ! (f , "failed") , Self :: Skipped => write ! (f , "skipped") , } } } impl std :: str :: FromStr for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "pending" => Ok (Self :: Pending) , "in_progress" => Ok (Self :: InProgress) , "completed" => Ok (Self :: Completed) , "failed" => Ok (Self :: Failed) , "skipped" => Ok (Self :: Skipped) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ansi\","] # [doc = "    \"plain\","] # [doc = "    \"json\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat { # [serde (rename = "ansi")] Ansi , # [serde (rename = "plain")] Plain , # [serde (rename = "json")] Json , } impl From < & GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat { fn from (value : & GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Ansi => write ! (f , "ansi") , Self :: Plain => write ! (f , "plain") , Self :: Json => write ! (f , "json") , } } } impl std :: str :: FromStr for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "ansi" => Ok (Self :: Ansi) , "plain" => Ok (Self :: Plain) , "json" => Ok (Self :: Json) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemDebugTracesItemTraceFormat { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash (String) ; impl :: std :: ops :: Deref for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash > for String { fn from (value : GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash) -> Self { value . 0 } } impl From < & GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash { fn from (value : & GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetIncidentsIncidentIdResponseInvalidatingTransactionsItemTransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetIncidentsIncidentIdTransactionsTxIdTraceResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"created_at\","] # [doc = "    \"environment\","] # [doc = "    \"error\","] # [doc = "    \"id\","] # [doc = "    \"invalidating_transaction_id\","] # [doc = "    \"status\","] # [doc = "    \"trace_content\","] # [doc = "    \"trace_format\","] # [doc = "    \"tracer_completed_at\","] # [doc = "    \"tracer_duration_ms\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"invalidating_transaction_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"pending\","] # [doc = "        \"in_progress\","] # [doc = "        \"completed\","] # [doc = "        \"failed\","] # [doc = "        \"skipped\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"trace_content\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"trace_format\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"ansi\","] # [doc = "        \"plain\","] # [doc = "        \"json\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"tracer_completed_at\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"tracer_duration_ms\": {"] # [doc = "      \"type\": ["] # [doc = "        \"integer\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetIncidentsIncidentIdTransactionsTxIdTraceResponse { pub created_at : chrono :: DateTime < chrono :: offset :: Utc > , pub environment : GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment , pub error : Option < String > , pub id : uuid :: Uuid , pub invalidating_transaction_id : uuid :: Uuid , pub status : GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus , pub trace_content : Option < String > , pub trace_format : GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat , pub tracer_completed_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , pub tracer_duration_ms : Option < i64 > , } impl From < & GetIncidentsIncidentIdTransactionsTxIdTraceResponse > for GetIncidentsIncidentIdTransactionsTxIdTraceResponse { fn from (value : & GetIncidentsIncidentIdTransactionsTxIdTraceResponse) -> Self { value . clone () } } # [doc = "GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment { fn from (value : & GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"pending\","] # [doc = "    \"in_progress\","] # [doc = "    \"completed\","] # [doc = "    \"failed\","] # [doc = "    \"skipped\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus { # [serde (rename = "pending")] Pending , # [serde (rename = "in_progress")] InProgress , # [serde (rename = "completed")] Completed , # [serde (rename = "failed")] Failed , # [serde (rename = "skipped")] Skipped , } impl From < & GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus { fn from (value : & GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Pending => write ! (f , "pending") , Self :: InProgress => write ! (f , "in_progress") , Self :: Completed => write ! (f , "completed") , Self :: Failed => write ! (f , "failed") , Self :: Skipped => write ! (f , "skipped") , } } } impl std :: str :: FromStr for GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "pending" => Ok (Self :: Pending) , "in_progress" => Ok (Self :: InProgress) , "completed" => Ok (Self :: Completed) , "failed" => Ok (Self :: Failed) , "skipped" => Ok (Self :: Skipped) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseStatus { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ansi\","] # [doc = "    \"plain\","] # [doc = "    \"json\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat { # [serde (rename = "ansi")] Ansi , # [serde (rename = "plain")] Plain , # [serde (rename = "json")] Json , } impl From < & GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat { fn from (value : & GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Ansi => write ! (f , "ansi") , Self :: Plain => write ! (f , "plain") , Self :: Json => write ! (f , "json") , } } } impl std :: str :: FromStr for GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "ansi" => Ok (Self :: Ansi) , "plain" => Ok (Self :: Plain) , "json" => Ok (Self :: Json) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetIncidentsIncidentIdTransactionsTxIdTraceResponseTraceFormat { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetManualVerificationRequestsAirtableRecordIdAirtableRecordId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetManualVerificationRequestsAirtableRecordIdAirtableRecordId (String) ; impl :: std :: ops :: Deref for GetManualVerificationRequestsAirtableRecordIdAirtableRecordId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetManualVerificationRequestsAirtableRecordIdAirtableRecordId > for String { fn from (value : GetManualVerificationRequestsAirtableRecordIdAirtableRecordId) -> Self { value . 0 } } impl From < & GetManualVerificationRequestsAirtableRecordIdAirtableRecordId > for GetManualVerificationRequestsAirtableRecordIdAirtableRecordId { fn from (value : & GetManualVerificationRequestsAirtableRecordIdAirtableRecordId) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetManualVerificationRequestsAirtableRecordIdAirtableRecordId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetManualVerificationRequestsAirtableRecordIdAirtableRecordId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetManualVerificationRequestsAirtableRecordIdAirtableRecordId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetManualVerificationRequestsAirtableRecordIdAirtableRecordId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetManualVerificationRequestsAirtableRecordIdAirtableRecordId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetManualVerificationRequestsAirtableRecordIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"addresses\","] # [doc = "        \"airtable_record_id\","] # [doc = "        \"id\","] # [doc = "        \"last_synced_at\","] # [doc = "        \"project_draft_id\","] # [doc = "        \"project_id\","] # [doc = "        \"requested_at\","] # [doc = "        \"requested_by\","] # [doc = "        \"signature_error\","] # [doc = "        \"signature_expires_at\","] # [doc = "        \"signature_message\","] # [doc = "        \"signature_nonce\","] # [doc = "        \"signature_signed_at\","] # [doc = "        \"signature_verified_at\","] # [doc = "        \"status\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"addresses\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"airtable_record_id\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"id\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"format\": \"uuid\""] # [doc = "        },"] # [doc = "        \"last_synced_at\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ],"] # [doc = "          \"format\": \"date-time\""] # [doc = "        },"] # [doc = "        \"project_draft_id\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ],"] # [doc = "          \"format\": \"uuid\""] # [doc = "        },"] # [doc = "        \"project_id\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ],"] # [doc = "          \"format\": \"uuid\""] # [doc = "        },"] # [doc = "        \"requested_at\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"format\": \"date-time\""] # [doc = "        },"] # [doc = "        \"requested_by\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"signature_error\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"signature_expires_at\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ],"] # [doc = "          \"format\": \"date-time\""] # [doc = "        },"] # [doc = "        \"signature_hash\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"signature_message\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"signature_nonce\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"signature_resources\": {},"] # [doc = "        \"signature_signed_at\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ],"] # [doc = "          \"format\": \"date-time\""] # [doc = "        },"] # [doc = "        \"signature_verified_at\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ],"] # [doc = "          \"format\": \"date-time\""] # [doc = "        },"] # [doc = "        \"status\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"enum\": ["] # [doc = "            \"requested\","] # [doc = "            \"pending\","] # [doc = "            \"overdue\","] # [doc = "            \"approved\","] # [doc = "            \"rejected\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"addresses\","] # [doc = "        \"airtable_record_id\","] # [doc = "        \"status\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"addresses\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"airtable_record_id\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"status\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"enum\": ["] # [doc = "            \"requested\","] # [doc = "            \"pending\","] # [doc = "            \"overdue\","] # [doc = "            \"approved\","] # [doc = "            \"rejected\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum GetManualVerificationRequestsAirtableRecordIdResponse { Variant0 { addresses : Vec < GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem > , airtable_record_id : Option < String > , id : uuid :: Uuid , last_synced_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , project_draft_id : Option < uuid :: Uuid > , project_id : Option < uuid :: Uuid > , requested_at : chrono :: DateTime < chrono :: offset :: Utc > , requested_by : GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy , signature_error : Option < String > , signature_expires_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , # [serde (default , skip_serializing_if = "Option::is_none")] signature_hash : Option < String > , signature_message : Option < String > , signature_nonce : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] signature_resources : Option < :: serde_json :: Value > , signature_signed_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , signature_verified_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , status : GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status , } , Variant1 { addresses : Vec < GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem > , airtable_record_id : Option < String > , status : GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status , } , } impl From < & GetManualVerificationRequestsAirtableRecordIdResponse > for GetManualVerificationRequestsAirtableRecordIdResponse { fn from (value : & GetManualVerificationRequestsAirtableRecordIdResponse) -> Self { value . clone () } } # [doc = "GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem (String) ; impl :: std :: ops :: Deref for GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem > for String { fn from (value : GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem) -> Self { value . 0 } } impl From < & GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem { fn from (value : & GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0AddressesItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy (String) ; impl :: std :: ops :: Deref for GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy > for String { fn from (value : GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy) -> Self { value . 0 } } impl From < & GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy { fn from (value : & GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0RequestedBy { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"requested\","] # [doc = "    \"pending\","] # [doc = "    \"overdue\","] # [doc = "    \"approved\","] # [doc = "    \"rejected\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status { # [serde (rename = "requested")] Requested , # [serde (rename = "pending")] Pending , # [serde (rename = "overdue")] Overdue , # [serde (rename = "approved")] Approved , # [serde (rename = "rejected")] Rejected , } impl From < & GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status { fn from (value : & GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Requested => write ! (f , "requested") , Self :: Pending => write ! (f , "pending") , Self :: Overdue => write ! (f , "overdue") , Self :: Approved => write ! (f , "approved") , Self :: Rejected => write ! (f , "rejected") , } } } impl std :: str :: FromStr for GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "requested" => Ok (Self :: Requested) , "pending" => Ok (Self :: Pending) , "overdue" => Ok (Self :: Overdue) , "approved" => Ok (Self :: Approved) , "rejected" => Ok (Self :: Rejected) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetManualVerificationRequestsAirtableRecordIdResponseVariant0Status { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem (String) ; impl :: std :: ops :: Deref for GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem > for String { fn from (value : GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem) -> Self { value . 0 } } impl From < & GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem > for GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem { fn from (value : & GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetManualVerificationRequestsAirtableRecordIdResponseVariant1AddressesItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"requested\","] # [doc = "    \"pending\","] # [doc = "    \"overdue\","] # [doc = "    \"approved\","] # [doc = "    \"rejected\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status { # [serde (rename = "requested")] Requested , # [serde (rename = "pending")] Pending , # [serde (rename = "overdue")] Overdue , # [serde (rename = "approved")] Approved , # [serde (rename = "rejected")] Rejected , } impl From < & GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status > for GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status { fn from (value : & GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Requested => write ! (f , "requested") , Self :: Pending => write ! (f , "pending") , Self :: Overdue => write ! (f , "overdue") , Self :: Approved => write ! (f , "approved") , Self :: Rejected => write ! (f , "rejected") , } } } impl std :: str :: FromStr for GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "requested" => Ok (Self :: Requested) , "pending" => Ok (Self :: Pending) , "overdue" => Ok (Self :: Overdue) , "approved" => Ok (Self :: Approved) , "rejected" => Ok (Self :: Rejected) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetManualVerificationRequestsAirtableRecordIdResponseVariant1Status { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId (String) ; impl :: std :: ops :: Deref for GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId > for String { fn from (value : GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId) -> Self { value . 0 } } impl From < & GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId > for GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId { fn from (value : & GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetManualVerificationRequestsAirtableRecordIdStatusResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"airtable_record_id\","] # [doc = "    \"airtable_status\","] # [doc = "    \"eligible_for_signature\","] # [doc = "    \"last_checked_at\","] # [doc = "    \"normalized_status\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"airtable_record_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"airtable_status\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"eligible_for_signature\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"last_checked_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"normalized_status\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"requested\","] # [doc = "        \"pending\","] # [doc = "        \"overdue\","] # [doc = "        \"approved\","] # [doc = "        \"rejected\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"reasons\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetManualVerificationRequestsAirtableRecordIdStatusResponse { pub airtable_record_id : String , pub airtable_status : String , pub eligible_for_signature : bool , # [serde (default , skip_serializing_if = "Option::is_none")] pub id : Option < uuid :: Uuid > , pub last_checked_at : chrono :: DateTime < chrono :: offset :: Utc > , pub normalized_status : GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub reasons : Vec < String > , } impl From < & GetManualVerificationRequestsAirtableRecordIdStatusResponse > for GetManualVerificationRequestsAirtableRecordIdStatusResponse { fn from (value : & GetManualVerificationRequestsAirtableRecordIdStatusResponse) -> Self { value . clone () } } # [doc = "GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"requested\","] # [doc = "    \"pending\","] # [doc = "    \"overdue\","] # [doc = "    \"approved\","] # [doc = "    \"rejected\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus { # [serde (rename = "requested")] Requested , # [serde (rename = "pending")] Pending , # [serde (rename = "overdue")] Overdue , # [serde (rename = "approved")] Approved , # [serde (rename = "rejected")] Rejected , } impl From < & GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus > for GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus { fn from (value : & GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Requested => write ! (f , "requested") , Self :: Pending => write ! (f , "pending") , Self :: Overdue => write ! (f , "overdue") , Self :: Approved => write ! (f , "approved") , Self :: Rejected => write ! (f , "rejected") , } } } impl std :: str :: FromStr for GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "requested" => Ok (Self :: Requested) , "pending" => Ok (Self :: Pending) , "overdue" => Ok (Self :: Overdue) , "approved" => Ok (Self :: Approved) , "rejected" => Ok (Self :: Rejected) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetManualVerificationRequestsAirtableRecordIdStatusResponseNormalizedStatus { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetOpenapiResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"error\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"code\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"details\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetOpenapiResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub code : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub details : Option < String > , pub error : String , } impl From < & GetOpenapiResponse > for GetOpenapiResponse { fn from (value : & GetOpenapiResponse) -> Self { value . clone () } } # [doc = "GetProjectsDraftsIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"addresses\","] # [doc = "    \"created_at\","] # [doc = "    \"id\","] # [doc = "    \"manual_verification_addresses\","] # [doc = "    \"owner_wallet\","] # [doc = "    \"profile_image_url\","] # [doc = "    \"project_description\","] # [doc = "    \"project_name\","] # [doc = "    \"project_networks\","] # [doc = "    \"status\","] # [doc = "    \"updated_at\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"addresses\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"manual_verification_addresses\": {"] # [doc = "      \"type\": ["] # [doc = "        \"array\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"owner_wallet\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"project_description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 1000"] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    },"] # [doc = "    \"project_networks\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"integer\","] # [doc = "        \"exclusiveMinimum\": 0.0"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"active\","] # [doc = "        \"pending_verification\","] # [doc = "        \"completed\","] # [doc = "        \"abandoned\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"updated_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsDraftsIdResponse { pub addresses : Vec < GetProjectsDraftsIdResponseAddressesItem > , pub created_at : chrono :: DateTime < chrono :: offset :: Utc > , pub id : uuid :: Uuid , pub manual_verification_addresses : Option < Vec < GetProjectsDraftsIdResponseManualVerificationAddressesItem > > , pub owner_wallet : GetProjectsDraftsIdResponseOwnerWallet , pub profile_image_url : Option < String > , pub project_description : Option < GetProjectsDraftsIdResponseProjectDescription > , pub project_name : Option < GetProjectsDraftsIdResponseProjectName > , pub project_networks : Vec < std :: num :: NonZeroU64 > , pub status : GetProjectsDraftsIdResponseStatus , pub updated_at : chrono :: DateTime < chrono :: offset :: Utc > , } impl From < & GetProjectsDraftsIdResponse > for GetProjectsDraftsIdResponse { fn from (value : & GetProjectsDraftsIdResponse) -> Self { value . clone () } } # [doc = "GetProjectsDraftsIdResponseAddressesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsDraftsIdResponseAddressesItem (String) ; impl :: std :: ops :: Deref for GetProjectsDraftsIdResponseAddressesItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsDraftsIdResponseAddressesItem > for String { fn from (value : GetProjectsDraftsIdResponseAddressesItem) -> Self { value . 0 } } impl From < & GetProjectsDraftsIdResponseAddressesItem > for GetProjectsDraftsIdResponseAddressesItem { fn from (value : & GetProjectsDraftsIdResponseAddressesItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsDraftsIdResponseAddressesItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsDraftsIdResponseAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsDraftsIdResponseAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsDraftsIdResponseAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsDraftsIdResponseAddressesItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsDraftsIdResponseManualVerificationAddressesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsDraftsIdResponseManualVerificationAddressesItem (String) ; impl :: std :: ops :: Deref for GetProjectsDraftsIdResponseManualVerificationAddressesItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsDraftsIdResponseManualVerificationAddressesItem > for String { fn from (value : GetProjectsDraftsIdResponseManualVerificationAddressesItem) -> Self { value . 0 } } impl From < & GetProjectsDraftsIdResponseManualVerificationAddressesItem > for GetProjectsDraftsIdResponseManualVerificationAddressesItem { fn from (value : & GetProjectsDraftsIdResponseManualVerificationAddressesItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsDraftsIdResponseManualVerificationAddressesItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsDraftsIdResponseManualVerificationAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsDraftsIdResponseManualVerificationAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsDraftsIdResponseManualVerificationAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsDraftsIdResponseManualVerificationAddressesItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsDraftsIdResponseOwnerWallet"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsDraftsIdResponseOwnerWallet (String) ; impl :: std :: ops :: Deref for GetProjectsDraftsIdResponseOwnerWallet { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsDraftsIdResponseOwnerWallet > for String { fn from (value : GetProjectsDraftsIdResponseOwnerWallet) -> Self { value . 0 } } impl From < & GetProjectsDraftsIdResponseOwnerWallet > for GetProjectsDraftsIdResponseOwnerWallet { fn from (value : & GetProjectsDraftsIdResponseOwnerWallet) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsDraftsIdResponseOwnerWallet { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsDraftsIdResponseOwnerWallet { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsDraftsIdResponseOwnerWallet { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsDraftsIdResponseOwnerWallet { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsDraftsIdResponseOwnerWallet { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsDraftsIdResponseProjectDescription"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 1000"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsDraftsIdResponseProjectDescription (String) ; impl :: std :: ops :: Deref for GetProjectsDraftsIdResponseProjectDescription { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsDraftsIdResponseProjectDescription > for String { fn from (value : GetProjectsDraftsIdResponseProjectDescription) -> Self { value . 0 } } impl From < & GetProjectsDraftsIdResponseProjectDescription > for GetProjectsDraftsIdResponseProjectDescription { fn from (value : & GetProjectsDraftsIdResponseProjectDescription) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsDraftsIdResponseProjectDescription { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 1000usize { return Err ("longer than 1000 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsDraftsIdResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsDraftsIdResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsDraftsIdResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsDraftsIdResponseProjectDescription { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsDraftsIdResponseProjectName"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsDraftsIdResponseProjectName (String) ; impl :: std :: ops :: Deref for GetProjectsDraftsIdResponseProjectName { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsDraftsIdResponseProjectName > for String { fn from (value : GetProjectsDraftsIdResponseProjectName) -> Self { value . 0 } } impl From < & GetProjectsDraftsIdResponseProjectName > for GetProjectsDraftsIdResponseProjectName { fn from (value : & GetProjectsDraftsIdResponseProjectName) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsDraftsIdResponseProjectName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsDraftsIdResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsDraftsIdResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsDraftsIdResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsDraftsIdResponseProjectName { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsDraftsIdResponseStatus"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"active\","] # [doc = "    \"pending_verification\","] # [doc = "    \"completed\","] # [doc = "    \"abandoned\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsDraftsIdResponseStatus { # [serde (rename = "active")] Active , # [serde (rename = "pending_verification")] PendingVerification , # [serde (rename = "completed")] Completed , # [serde (rename = "abandoned")] Abandoned , } impl From < & GetProjectsDraftsIdResponseStatus > for GetProjectsDraftsIdResponseStatus { fn from (value : & GetProjectsDraftsIdResponseStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsDraftsIdResponseStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Active => write ! (f , "active") , Self :: PendingVerification => write ! (f , "pending_verification") , Self :: Completed => write ! (f , "completed") , Self :: Abandoned => write ! (f , "abandoned") , } } } impl std :: str :: FromStr for GetProjectsDraftsIdResponseStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "active" => Ok (Self :: Active) , "pending_verification" => Ok (Self :: PendingVerification) , "completed" => Ok (Self :: Completed) , "abandoned" => Ok (Self :: Abandoned) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsDraftsIdResponseStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsDraftsIdResponseStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsDraftsIdResponseStatus { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetProjectsProjectIdEventsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"events\","] # [doc = "    \"project_id\","] # [doc = "    \"total_count\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"events\": {"] # [doc = "      \"description\": \"Array of merged and sorted project events\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"id\","] # [doc = "          \"metadata\","] # [doc = "          \"project_id\","] # [doc = "          \"source\","] # [doc = "          \"timestamp\","] # [doc = "          \"type\","] # [doc = "          \"visibility\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"environment\": {"] # [doc = "            \"description\": \"Environment context for the event (staging or production)\","] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"staging\","] # [doc = "              \"production\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"id\": {"] # [doc = "            \"description\": \"Unique event identifier, prefixed with source (db_ or bc_)\","] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"metadata\": {"] # [doc = "            \"description\": \"Event-specific metadata including optional transaction hash\","] # [doc = "            \"allOf\": ["] # [doc = "              {"] # [doc = "                \"type\": \"object\","] # [doc = "                \"additionalProperties\": {}"] # [doc = "              },"] # [doc = "              {"] # [doc = "                \"type\": \"object\","] # [doc = "                \"properties\": {"] # [doc = "                  \"tx_hash\": {"] # [doc = "                    \"type\": \"string\""] # [doc = "                  }"] # [doc = "                }"] # [doc = "              }"] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"project_id\": {"] # [doc = "            \"description\": \"UUID of the associated project\","] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"uuid\""] # [doc = "          },"] # [doc = "          \"source\": {"] # [doc = "            \"description\": \"Source of the event (database or blockchain)\","] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"database\","] # [doc = "              \"blockchain\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"timestamp\": {"] # [doc = "            \"description\": \"ISO datetime when the event occurred\","] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"date-time\""] # [doc = "          },"] # [doc = "          \"type\": {"] # [doc = "            \"description\": \"Event type in snake_case format\","] # [doc = "            \"oneOf\": ["] # [doc = "              {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"enum\": ["] # [doc = "                  \"project_created\","] # [doc = "                  \"project_edited\","] # [doc = "                  \"project_deleted\","] # [doc = "                  \"project_transferred\","] # [doc = "                  \"contract_added\","] # [doc = "                  \"contract_removed\","] # [doc = "                  \"contract_moved\","] # [doc = "                  \"assertion_submitted\","] # [doc = "                  \"assertion_registered\","] # [doc = "                  \"assertion_activated\","] # [doc = "                  \"assertion_removed\","] # [doc = "                  \"assertion_deactivated\","] # [doc = "                  \"incident_reported\""] # [doc = "                ]"] # [doc = "              },"] # [doc = "              {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"enum\": ["] # [doc = "                  \"contract_registered\","] # [doc = "                  \"assertion_registered\","] # [doc = "                  \"assertion_unregistered\","] # [doc = "                  \"manager_transfer_requested\","] # [doc = "                  \"manager_transferred\""] # [doc = "                ]"] # [doc = "              }"] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"visibility\": {"] # [doc = "            \"description\": \"Whether the event is public or private\","] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"public\","] # [doc = "              \"private\""] # [doc = "            ]"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"description\": \"UUID of the project\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"total_count\": {"] # [doc = "      \"description\": \"Total number of events returned\","] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdEventsResponse { # [doc = "Array of merged and sorted project events"] pub events : Vec < GetProjectsProjectIdEventsResponseEventsItem > , # [doc = "UUID of the project"] pub project_id : uuid :: Uuid , # [doc = "Total number of events returned"] pub total_count : u64 , } impl From < & GetProjectsProjectIdEventsResponse > for GetProjectsProjectIdEventsResponse { fn from (value : & GetProjectsProjectIdEventsResponse) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdEventsResponseEventsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"id\","] # [doc = "    \"metadata\","] # [doc = "    \"project_id\","] # [doc = "    \"source\","] # [doc = "    \"timestamp\","] # [doc = "    \"type\","] # [doc = "    \"visibility\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"environment\": {"] # [doc = "      \"description\": \"Environment context for the event (staging or production)\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"description\": \"Unique event identifier, prefixed with source (db_ or bc_)\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"metadata\": {"] # [doc = "      \"description\": \"Event-specific metadata including optional transaction hash\","] # [doc = "      \"allOf\": ["] # [doc = "        {"] # [doc = "          \"type\": \"object\","] # [doc = "          \"additionalProperties\": {}"] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"object\","] # [doc = "          \"properties\": {"] # [doc = "            \"tx_hash\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          }"] # [doc = "        }"] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"description\": \"UUID of the associated project\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"source\": {"] # [doc = "      \"description\": \"Source of the event (database or blockchain)\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"database\","] # [doc = "        \"blockchain\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"timestamp\": {"] # [doc = "      \"description\": \"ISO datetime when the event occurred\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"type\": {"] # [doc = "      \"description\": \"Event type in snake_case format\","] # [doc = "      \"oneOf\": ["] # [doc = "        {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"enum\": ["] # [doc = "            \"project_created\","] # [doc = "            \"project_edited\","] # [doc = "            \"project_deleted\","] # [doc = "            \"project_transferred\","] # [doc = "            \"contract_added\","] # [doc = "            \"contract_removed\","] # [doc = "            \"contract_moved\","] # [doc = "            \"assertion_submitted\","] # [doc = "            \"assertion_registered\","] # [doc = "            \"assertion_activated\","] # [doc = "            \"assertion_removed\","] # [doc = "            \"assertion_deactivated\","] # [doc = "            \"incident_reported\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"enum\": ["] # [doc = "            \"contract_registered\","] # [doc = "            \"assertion_registered\","] # [doc = "            \"assertion_unregistered\","] # [doc = "            \"manager_transfer_requested\","] # [doc = "            \"manager_transferred\""] # [doc = "          ]"] # [doc = "        }"] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"visibility\": {"] # [doc = "      \"description\": \"Whether the event is public or private\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"public\","] # [doc = "        \"private\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdEventsResponseEventsItem { # [doc = "Environment context for the event (staging or production)"] # [serde (default , skip_serializing_if = "Option::is_none")] pub environment : Option < GetProjectsProjectIdEventsResponseEventsItemEnvironment > , # [doc = "Unique event identifier, prefixed with source (db_ or bc_)"] pub id : String , pub metadata : GetProjectsProjectIdEventsResponseEventsItemMetadata , # [doc = "UUID of the associated project"] pub project_id : uuid :: Uuid , # [doc = "Source of the event (database or blockchain)"] pub source : GetProjectsProjectIdEventsResponseEventsItemSource , # [doc = "ISO datetime when the event occurred"] pub timestamp : chrono :: DateTime < chrono :: offset :: Utc > , # [doc = "Event type in snake_case format"] # [serde (rename = "type")] pub type_ : GetProjectsProjectIdEventsResponseEventsItemType , # [doc = "Whether the event is public or private"] pub visibility : GetProjectsProjectIdEventsResponseEventsItemVisibility , } impl From < & GetProjectsProjectIdEventsResponseEventsItem > for GetProjectsProjectIdEventsResponseEventsItem { fn from (value : & GetProjectsProjectIdEventsResponseEventsItem) -> Self { value . clone () } } # [doc = "Environment context for the event (staging or production)"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Environment context for the event (staging or production)\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdEventsResponseEventsItemEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & GetProjectsProjectIdEventsResponseEventsItemEnvironment > for GetProjectsProjectIdEventsResponseEventsItemEnvironment { fn from (value : & GetProjectsProjectIdEventsResponseEventsItemEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdEventsResponseEventsItemEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for GetProjectsProjectIdEventsResponseEventsItemEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdEventsResponseEventsItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdEventsResponseEventsItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdEventsResponseEventsItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Event-specific metadata including optional transaction hash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Event-specific metadata including optional transaction hash\","] # [doc = "  \"allOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"additionalProperties\": {}"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"properties\": {"] # [doc = "        \"tx_hash\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdEventsResponseEventsItemMetadata { # [serde (default , skip_serializing_if = "Option::is_none")] pub tx_hash : Option < String > , } impl From < & GetProjectsProjectIdEventsResponseEventsItemMetadata > for GetProjectsProjectIdEventsResponseEventsItemMetadata { fn from (value : & GetProjectsProjectIdEventsResponseEventsItemMetadata) -> Self { value . clone () } } # [doc = "Source of the event (database or blockchain)"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Source of the event (database or blockchain)\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"database\","] # [doc = "    \"blockchain\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdEventsResponseEventsItemSource { # [serde (rename = "database")] Database , # [serde (rename = "blockchain")] Blockchain , } impl From < & GetProjectsProjectIdEventsResponseEventsItemSource > for GetProjectsProjectIdEventsResponseEventsItemSource { fn from (value : & GetProjectsProjectIdEventsResponseEventsItemSource) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdEventsResponseEventsItemSource { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Database => write ! (f , "database") , Self :: Blockchain => write ! (f , "blockchain") , } } } impl std :: str :: FromStr for GetProjectsProjectIdEventsResponseEventsItemSource { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "database" => Ok (Self :: Database) , "blockchain" => Ok (Self :: Blockchain) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdEventsResponseEventsItemSource { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdEventsResponseEventsItemSource { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdEventsResponseEventsItemSource { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Event type in snake_case format"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Event type in snake_case format\","] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"project_created\","] # [doc = "        \"project_edited\","] # [doc = "        \"project_deleted\","] # [doc = "        \"project_transferred\","] # [doc = "        \"contract_added\","] # [doc = "        \"contract_removed\","] # [doc = "        \"contract_moved\","] # [doc = "        \"assertion_submitted\","] # [doc = "        \"assertion_registered\","] # [doc = "        \"assertion_activated\","] # [doc = "        \"assertion_removed\","] # [doc = "        \"assertion_deactivated\","] # [doc = "        \"incident_reported\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"contract_registered\","] # [doc = "        \"assertion_registered\","] # [doc = "        \"assertion_unregistered\","] # [doc = "        \"manager_transfer_requested\","] # [doc = "        \"manager_transferred\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum GetProjectsProjectIdEventsResponseEventsItemType { Variant0 (GetProjectsProjectIdEventsResponseEventsItemTypeVariant0) , Variant1 (GetProjectsProjectIdEventsResponseEventsItemTypeVariant1) , } impl From < & GetProjectsProjectIdEventsResponseEventsItemType > for GetProjectsProjectIdEventsResponseEventsItemType { fn from (value : & GetProjectsProjectIdEventsResponseEventsItemType) -> Self { value . clone () } } impl std :: str :: FromStr for GetProjectsProjectIdEventsResponseEventsItemType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdEventsResponseEventsItemType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdEventsResponseEventsItemType { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdEventsResponseEventsItemType { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: fmt :: Display for GetProjectsProjectIdEventsResponseEventsItemType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } } impl From < GetProjectsProjectIdEventsResponseEventsItemTypeVariant0 > for GetProjectsProjectIdEventsResponseEventsItemType { fn from (value : GetProjectsProjectIdEventsResponseEventsItemTypeVariant0) -> Self { Self :: Variant0 (value) } } impl From < GetProjectsProjectIdEventsResponseEventsItemTypeVariant1 > for GetProjectsProjectIdEventsResponseEventsItemType { fn from (value : GetProjectsProjectIdEventsResponseEventsItemTypeVariant1) -> Self { Self :: Variant1 (value) } } # [doc = "GetProjectsProjectIdEventsResponseEventsItemTypeVariant0"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"project_created\","] # [doc = "    \"project_edited\","] # [doc = "    \"project_deleted\","] # [doc = "    \"project_transferred\","] # [doc = "    \"contract_added\","] # [doc = "    \"contract_removed\","] # [doc = "    \"contract_moved\","] # [doc = "    \"assertion_submitted\","] # [doc = "    \"assertion_registered\","] # [doc = "    \"assertion_activated\","] # [doc = "    \"assertion_removed\","] # [doc = "    \"assertion_deactivated\","] # [doc = "    \"incident_reported\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdEventsResponseEventsItemTypeVariant0 { # [serde (rename = "project_created")] ProjectCreated , # [serde (rename = "project_edited")] ProjectEdited , # [serde (rename = "project_deleted")] ProjectDeleted , # [serde (rename = "project_transferred")] ProjectTransferred , # [serde (rename = "contract_added")] ContractAdded , # [serde (rename = "contract_removed")] ContractRemoved , # [serde (rename = "contract_moved")] ContractMoved , # [serde (rename = "assertion_submitted")] AssertionSubmitted , # [serde (rename = "assertion_registered")] AssertionRegistered , # [serde (rename = "assertion_activated")] AssertionActivated , # [serde (rename = "assertion_removed")] AssertionRemoved , # [serde (rename = "assertion_deactivated")] AssertionDeactivated , # [serde (rename = "incident_reported")] IncidentReported , } impl From < & GetProjectsProjectIdEventsResponseEventsItemTypeVariant0 > for GetProjectsProjectIdEventsResponseEventsItemTypeVariant0 { fn from (value : & GetProjectsProjectIdEventsResponseEventsItemTypeVariant0) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdEventsResponseEventsItemTypeVariant0 { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ProjectCreated => write ! (f , "project_created") , Self :: ProjectEdited => write ! (f , "project_edited") , Self :: ProjectDeleted => write ! (f , "project_deleted") , Self :: ProjectTransferred => write ! (f , "project_transferred") , Self :: ContractAdded => write ! (f , "contract_added") , Self :: ContractRemoved => write ! (f , "contract_removed") , Self :: ContractMoved => write ! (f , "contract_moved") , Self :: AssertionSubmitted => write ! (f , "assertion_submitted") , Self :: AssertionRegistered => write ! (f , "assertion_registered") , Self :: AssertionActivated => write ! (f , "assertion_activated") , Self :: AssertionRemoved => write ! (f , "assertion_removed") , Self :: AssertionDeactivated => write ! (f , "assertion_deactivated") , Self :: IncidentReported => write ! (f , "incident_reported") , } } } impl std :: str :: FromStr for GetProjectsProjectIdEventsResponseEventsItemTypeVariant0 { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "project_created" => Ok (Self :: ProjectCreated) , "project_edited" => Ok (Self :: ProjectEdited) , "project_deleted" => Ok (Self :: ProjectDeleted) , "project_transferred" => Ok (Self :: ProjectTransferred) , "contract_added" => Ok (Self :: ContractAdded) , "contract_removed" => Ok (Self :: ContractRemoved) , "contract_moved" => Ok (Self :: ContractMoved) , "assertion_submitted" => Ok (Self :: AssertionSubmitted) , "assertion_registered" => Ok (Self :: AssertionRegistered) , "assertion_activated" => Ok (Self :: AssertionActivated) , "assertion_removed" => Ok (Self :: AssertionRemoved) , "assertion_deactivated" => Ok (Self :: AssertionDeactivated) , "incident_reported" => Ok (Self :: IncidentReported) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdEventsResponseEventsItemTypeVariant0 { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdEventsResponseEventsItemTypeVariant0 { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdEventsResponseEventsItemTypeVariant0 { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetProjectsProjectIdEventsResponseEventsItemTypeVariant1"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"contract_registered\","] # [doc = "    \"assertion_registered\","] # [doc = "    \"assertion_unregistered\","] # [doc = "    \"manager_transfer_requested\","] # [doc = "    \"manager_transferred\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdEventsResponseEventsItemTypeVariant1 { # [serde (rename = "contract_registered")] ContractRegistered , # [serde (rename = "assertion_registered")] AssertionRegistered , # [serde (rename = "assertion_unregistered")] AssertionUnregistered , # [serde (rename = "manager_transfer_requested")] ManagerTransferRequested , # [serde (rename = "manager_transferred")] ManagerTransferred , } impl From < & GetProjectsProjectIdEventsResponseEventsItemTypeVariant1 > for GetProjectsProjectIdEventsResponseEventsItemTypeVariant1 { fn from (value : & GetProjectsProjectIdEventsResponseEventsItemTypeVariant1) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdEventsResponseEventsItemTypeVariant1 { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: ContractRegistered => write ! (f , "contract_registered") , Self :: AssertionRegistered => write ! (f , "assertion_registered") , Self :: AssertionUnregistered => write ! (f , "assertion_unregistered") , Self :: ManagerTransferRequested => write ! (f , "manager_transfer_requested") , Self :: ManagerTransferred => write ! (f , "manager_transferred") , } } } impl std :: str :: FromStr for GetProjectsProjectIdEventsResponseEventsItemTypeVariant1 { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "contract_registered" => Ok (Self :: ContractRegistered) , "assertion_registered" => Ok (Self :: AssertionRegistered) , "assertion_unregistered" => Ok (Self :: AssertionUnregistered) , "manager_transfer_requested" => Ok (Self :: ManagerTransferRequested) , "manager_transferred" => Ok (Self :: ManagerTransferred) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdEventsResponseEventsItemTypeVariant1 { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdEventsResponseEventsItemTypeVariant1 { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdEventsResponseEventsItemTypeVariant1 { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Whether the event is public or private"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Whether the event is public or private\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"public\","] # [doc = "    \"private\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdEventsResponseEventsItemVisibility { # [serde (rename = "public")] Public , # [serde (rename = "private")] Private , } impl From < & GetProjectsProjectIdEventsResponseEventsItemVisibility > for GetProjectsProjectIdEventsResponseEventsItemVisibility { fn from (value : & GetProjectsProjectIdEventsResponseEventsItemVisibility) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdEventsResponseEventsItemVisibility { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Public => write ! (f , "public") , Self :: Private => write ! (f , "private") , } } } impl std :: str :: FromStr for GetProjectsProjectIdEventsResponseEventsItemVisibility { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "public" => Ok (Self :: Public) , "private" => Ok (Self :: Private) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdEventsResponseEventsItemVisibility { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdEventsResponseEventsItemVisibility { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdEventsResponseEventsItemVisibility { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetProjectsProjectIdIncidentsEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"all\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\","] # [doc = "    \"all\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdIncidentsEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , # [serde (rename = "all")] All , } impl From < & GetProjectsProjectIdIncidentsEnvironment > for GetProjectsProjectIdIncidentsEnvironment { fn from (value : & GetProjectsProjectIdIncidentsEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdIncidentsEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , Self :: All => write ! (f , "all") , } } } impl std :: str :: FromStr for GetProjectsProjectIdIncidentsEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , "all" => Ok (Self :: All) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdIncidentsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdIncidentsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdIncidentsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl Default for GetProjectsProjectIdIncidentsEnvironment { fn default () -> Self { GetProjectsProjectIdIncidentsEnvironment :: All } } # [doc = "GetProjectsProjectIdIncidentsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"incidents\","] # [doc = "    \"pagination\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"incidents\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopter_id\","] # [doc = "          \"assertion_id\","] # [doc = "          \"assertion_title\","] # [doc = "          \"chain_id\","] # [doc = "          \"contract_address\","] # [doc = "          \"contract_name\","] # [doc = "          \"created_at\","] # [doc = "          \"environment\","] # [doc = "          \"incident_id\","] # [doc = "          \"traces_completed\","] # [doc = "          \"traces_pending\","] # [doc = "          \"transaction_count\","] # [doc = "          \"window_start\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopter_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"assertion_title\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"chain_id\": {"] # [doc = "            \"type\": \"integer\","] # [doc = "            \"exclusiveMinimum\": 0.0"] # [doc = "          },"] # [doc = "          \"contract_address\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"contract_name\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"created_at\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"date-time\""] # [doc = "          },"] # [doc = "          \"environment\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"staging\","] # [doc = "              \"production\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"incident_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"uuid\""] # [doc = "          },"] # [doc = "          \"traces_completed\": {"] # [doc = "            \"type\": \"integer\","] # [doc = "            \"minimum\": 0.0"] # [doc = "          },"] # [doc = "          \"traces_pending\": {"] # [doc = "            \"type\": \"integer\","] # [doc = "            \"minimum\": 0.0"] # [doc = "          },"] # [doc = "          \"transaction_count\": {"] # [doc = "            \"type\": \"integer\","] # [doc = "            \"minimum\": 0.0"] # [doc = "          },"] # [doc = "          \"window_start\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"date-time\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"pagination\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"has_next\","] # [doc = "        \"has_prev\","] # [doc = "        \"limit\","] # [doc = "        \"page\","] # [doc = "        \"total\","] # [doc = "        \"total_pages\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"has_next\": {"] # [doc = "          \"type\": \"boolean\""] # [doc = "        },"] # [doc = "        \"has_prev\": {"] # [doc = "          \"type\": \"boolean\""] # [doc = "        },"] # [doc = "        \"limit\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"page\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"total\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"minimum\": 0.0"] # [doc = "        },"] # [doc = "        \"total_pages\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"minimum\": 0.0"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdIncidentsResponse { pub incidents : Vec < GetProjectsProjectIdIncidentsResponseIncidentsItem > , pub pagination : GetProjectsProjectIdIncidentsResponsePagination , } impl From < & GetProjectsProjectIdIncidentsResponse > for GetProjectsProjectIdIncidentsResponse { fn from (value : & GetProjectsProjectIdIncidentsResponse) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdIncidentsResponseIncidentsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_id\","] # [doc = "    \"assertion_id\","] # [doc = "    \"assertion_title\","] # [doc = "    \"chain_id\","] # [doc = "    \"contract_address\","] # [doc = "    \"contract_name\","] # [doc = "    \"created_at\","] # [doc = "    \"environment\","] # [doc = "    \"incident_id\","] # [doc = "    \"traces_completed\","] # [doc = "    \"traces_pending\","] # [doc = "    \"transaction_count\","] # [doc = "    \"window_start\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_title\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"chain_id\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"contract_address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"contract_name\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"incident_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"traces_completed\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"traces_pending\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"transaction_count\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"window_start\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdIncidentsResponseIncidentsItem { pub assertion_adopter_id : String , pub assertion_id : String , pub assertion_title : Option < String > , pub chain_id : std :: num :: NonZeroU64 , pub contract_address : String , pub contract_name : Option < String > , pub created_at : chrono :: DateTime < chrono :: offset :: Utc > , pub environment : GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment , pub incident_id : uuid :: Uuid , pub traces_completed : u64 , pub traces_pending : u64 , pub transaction_count : u64 , pub window_start : chrono :: DateTime < chrono :: offset :: Utc > , } impl From < & GetProjectsProjectIdIncidentsResponseIncidentsItem > for GetProjectsProjectIdIncidentsResponseIncidentsItem { fn from (value : & GetProjectsProjectIdIncidentsResponseIncidentsItem) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment > for GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment { fn from (value : & GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdIncidentsResponseIncidentsItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetProjectsProjectIdIncidentsResponsePagination"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"has_next\","] # [doc = "    \"has_prev\","] # [doc = "    \"limit\","] # [doc = "    \"page\","] # [doc = "    \"total\","] # [doc = "    \"total_pages\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"has_next\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"has_prev\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"limit\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"page\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"total\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"total_pages\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdIncidentsResponsePagination { pub has_next : bool , pub has_prev : bool , pub limit : std :: num :: NonZeroU64 , pub page : std :: num :: NonZeroU64 , pub total : u64 , pub total_pages : u64 , } impl From < & GetProjectsProjectIdIncidentsResponsePagination > for GetProjectsProjectIdIncidentsResponsePagination { fn from (value : & GetProjectsProjectIdIncidentsResponsePagination) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdIncidentsStatsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"average_per_day\","] # [doc = "    \"incidents_by_assertion\","] # [doc = "    \"incidents_by_chain\","] # [doc = "    \"incidents_by_day\","] # [doc = "    \"most_recent_incident\","] # [doc = "    \"total_incidents\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"average_per_day\": {"] # [doc = "      \"type\": \"number\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"incidents_by_assertion\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_id\","] # [doc = "          \"count\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"count\": {"] # [doc = "            \"type\": \"integer\","] # [doc = "            \"minimum\": 0.0"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"incidents_by_chain\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"chain_id\","] # [doc = "          \"count\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"chain_id\": {"] # [doc = "            \"type\": \"integer\","] # [doc = "            \"exclusiveMinimum\": 0.0"] # [doc = "          },"] # [doc = "          \"count\": {"] # [doc = "            \"type\": \"integer\","] # [doc = "            \"minimum\": 0.0"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"incidents_by_day\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"count\","] # [doc = "          \"date\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"count\": {"] # [doc = "            \"type\": \"integer\","] # [doc = "            \"minimum\": 0.0"] # [doc = "          },"] # [doc = "          \"date\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"most_recent_incident\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"total_incidents\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdIncidentsStatsResponse { pub average_per_day : f64 , pub incidents_by_assertion : Vec < GetProjectsProjectIdIncidentsStatsResponseIncidentsByAssertionItem > , pub incidents_by_chain : Vec < GetProjectsProjectIdIncidentsStatsResponseIncidentsByChainItem > , pub incidents_by_day : Vec < GetProjectsProjectIdIncidentsStatsResponseIncidentsByDayItem > , pub most_recent_incident : Option < chrono :: DateTime < chrono :: offset :: Utc > > , pub total_incidents : u64 , } impl From < & GetProjectsProjectIdIncidentsStatsResponse > for GetProjectsProjectIdIncidentsStatsResponse { fn from (value : & GetProjectsProjectIdIncidentsStatsResponse) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdIncidentsStatsResponseIncidentsByAssertionItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_id\","] # [doc = "    \"count\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"count\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdIncidentsStatsResponseIncidentsByAssertionItem { pub assertion_id : String , pub count : u64 , } impl From < & GetProjectsProjectIdIncidentsStatsResponseIncidentsByAssertionItem > for GetProjectsProjectIdIncidentsStatsResponseIncidentsByAssertionItem { fn from (value : & GetProjectsProjectIdIncidentsStatsResponseIncidentsByAssertionItem) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdIncidentsStatsResponseIncidentsByChainItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"chain_id\","] # [doc = "    \"count\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chain_id\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"count\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdIncidentsStatsResponseIncidentsByChainItem { pub chain_id : std :: num :: NonZeroU64 , pub count : u64 , } impl From < & GetProjectsProjectIdIncidentsStatsResponseIncidentsByChainItem > for GetProjectsProjectIdIncidentsStatsResponseIncidentsByChainItem { fn from (value : & GetProjectsProjectIdIncidentsStatsResponseIncidentsByChainItem) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdIncidentsStatsResponseIncidentsByDayItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"count\","] # [doc = "    \"date\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"count\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"date\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdIncidentsStatsResponseIncidentsByDayItem { pub count : u64 , pub date : String , } impl From < & GetProjectsProjectIdIncidentsStatsResponseIncidentsByDayItem > for GetProjectsProjectIdIncidentsStatsResponseIncidentsByDayItem { fn from (value : & GetProjectsProjectIdIncidentsStatsResponseIncidentsByDayItem) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdIntegrationsPagerdutyResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"configured\","] # [doc = "    \"enabled\","] # [doc = "    \"last_notification_at\","] # [doc = "    \"notification_count\","] # [doc = "    \"routing_key_masked\","] # [doc = "    \"test_available\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"configured\": {"] # [doc = "      \"description\": \"Whether the integration is configured\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"enabled\": {"] # [doc = "      \"description\": \"Whether the integration is enabled\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"last_notification_at\": {"] # [doc = "      \"description\": \"Last notification timestamp in ISO format\","] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"notification_count\": {"] # [doc = "      \"description\": \"Total number of notifications sent\","] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"routing_key_masked\": {"] # [doc = "      \"description\": \"Masked routing key showing only last 4 characters (e.g., \\\"****************************abcd\\\")\","] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"test_available\": {"] # [doc = "      \"description\": \"Whether test notification can be sent\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdIntegrationsPagerdutyResponse { # [doc = "Whether the integration is configured"] pub configured : bool , # [doc = "Whether the integration is enabled"] pub enabled : bool , # [doc = "Last notification timestamp in ISO format"] pub last_notification_at : Option < String > , pub notification_count : f64 , # [doc = "Masked routing key showing only last 4 characters (e.g., \"****************************abcd\")"] pub routing_key_masked : Option < String > , # [doc = "Whether test notification can be sent"] pub test_available : bool , } impl From < & GetProjectsProjectIdIntegrationsPagerdutyResponse > for GetProjectsProjectIdIntegrationsPagerdutyResponse { fn from (value : & GetProjectsProjectIdIntegrationsPagerdutyResponse) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdIntegrationsSlackResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"configured\","] # [doc = "    \"enabled\","] # [doc = "    \"last_notification_at\","] # [doc = "    \"notification_count\","] # [doc = "    \"test_available\","] # [doc = "    \"webhook_url\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"configured\": {"] # [doc = "      \"description\": \"Whether the integration is configured\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"enabled\": {"] # [doc = "      \"description\": \"Whether the integration is enabled\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"last_notification_at\": {"] # [doc = "      \"description\": \"Last notification timestamp in ISO format\","] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"notification_count\": {"] # [doc = "      \"description\": \"Total number of notifications sent\","] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"test_available\": {"] # [doc = "      \"description\": \"Whether test notification can be sent\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"webhook_url\": {"] # [doc = "      \"description\": \"The configured Slack webhook URL (null if not configured)\","] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdIntegrationsSlackResponse { # [doc = "Whether the integration is configured"] pub configured : bool , # [doc = "Whether the integration is enabled"] pub enabled : bool , # [doc = "Last notification timestamp in ISO format"] pub last_notification_at : Option < String > , pub notification_count : f64 , # [doc = "Whether test notification can be sent"] pub test_available : bool , # [doc = "The configured Slack webhook URL (null if not configured)"] pub webhook_url : Option < String > , } impl From < & GetProjectsProjectIdIntegrationsSlackResponse > for GetProjectsProjectIdIntegrationsSlackResponse { fn from (value : & GetProjectsProjectIdIntegrationsSlackResponse) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdRegisteredAssertionsEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"all\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\","] # [doc = "    \"all\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdRegisteredAssertionsEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , # [serde (rename = "all")] All , } impl From < & GetProjectsProjectIdRegisteredAssertionsEnvironment > for GetProjectsProjectIdRegisteredAssertionsEnvironment { fn from (value : & GetProjectsProjectIdRegisteredAssertionsEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdRegisteredAssertionsEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , Self :: All => write ! (f , "all") , } } } impl std :: str :: FromStr for GetProjectsProjectIdRegisteredAssertionsEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , "all" => Ok (Self :: All) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdRegisteredAssertionsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdRegisteredAssertionsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdRegisteredAssertionsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl Default for GetProjectsProjectIdRegisteredAssertionsEnvironment { fn default () -> Self { GetProjectsProjectIdRegisteredAssertionsEnvironment :: All } } # [doc = "GetProjectsProjectIdRegisteredAssertionsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"registered_assertions\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"registered_assertions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_functions\","] # [doc = "          \"assertion_id\","] # [doc = "          \"bytecode\","] # [doc = "          \"constructor_abi_signature\","] # [doc = "          \"constructor_args\","] # [doc = "          \"contract_name\","] # [doc = "          \"linked_adopters\","] # [doc = "          \"registered_address\","] # [doc = "          \"registered_at\","] # [doc = "          \"signature\","] # [doc = "          \"source_code\","] # [doc = "          \"status\","] # [doc = "          \"submitted_at\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_functions\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "          },"] # [doc = "          \"bytecode\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"constructor_abi_signature\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"constructor_args\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {}"] # [doc = "          },"] # [doc = "          \"contract_name\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"environment\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"staging\","] # [doc = "              \"production\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"linked_adopters\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"registered_address\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ],"] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "          },"] # [doc = "          \"registered_at\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ],"] # [doc = "            \"format\": \"date-time\""] # [doc = "          },"] # [doc = "          \"signature\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"source_code\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"status\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"pending\","] # [doc = "              \"submitted\","] # [doc = "              \"registered\","] # [doc = "              \"removed\","] # [doc = "              \"failed\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"submitted_at\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"date-time\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdRegisteredAssertionsResponse { pub registered_assertions : Vec < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem > , } impl From < & GetProjectsProjectIdRegisteredAssertionsResponse > for GetProjectsProjectIdRegisteredAssertionsResponse { fn from (value : & GetProjectsProjectIdRegisteredAssertionsResponse) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_functions\","] # [doc = "    \"assertion_id\","] # [doc = "    \"bytecode\","] # [doc = "    \"constructor_abi_signature\","] # [doc = "    \"constructor_args\","] # [doc = "    \"contract_name\","] # [doc = "    \"linked_adopters\","] # [doc = "    \"registered_address\","] # [doc = "    \"registered_at\","] # [doc = "    \"signature\","] # [doc = "    \"source_code\","] # [doc = "    \"status\","] # [doc = "    \"submitted_at\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_functions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    },"] # [doc = "    \"bytecode\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"constructor_abi_signature\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"constructor_args\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {}"] # [doc = "    },"] # [doc = "    \"contract_name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"linked_adopters\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"registered_address\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"registered_at\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"signature\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"source_code\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"pending\","] # [doc = "        \"submitted\","] # [doc = "        \"registered\","] # [doc = "        \"removed\","] # [doc = "        \"failed\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"submitted_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem { pub assertion_functions : Vec < String > , pub assertion_id : GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId , pub bytecode : Option < String > , pub constructor_abi_signature : Option < String > , pub constructor_args : Vec < :: serde_json :: Value > , pub contract_name : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub environment : Option < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment > , pub linked_adopters : Vec < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem > , pub registered_address : Option < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress > , pub registered_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , pub signature : String , pub source_code : Option < String > , pub status : GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus , pub submitted_at : chrono :: DateTime < chrono :: offset :: Utc > , } impl From < & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem { fn from (value : & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId (String) ; impl :: std :: ops :: Deref for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId > for String { fn from (value : GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId) -> Self { value . 0 } } impl From < & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId { fn from (value : & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment { fn from (value : & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem (String) ; impl :: std :: ops :: Deref for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem > for String { fn from (value : GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem) -> Self { value . 0 } } impl From < & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { fn from (value : & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress (String) ; impl :: std :: ops :: Deref for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress > for String { fn from (value : GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress) -> Self { value . 0 } } impl From < & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { fn from (value : & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"pending\","] # [doc = "    \"submitted\","] # [doc = "    \"registered\","] # [doc = "    \"removed\","] # [doc = "    \"failed\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus { # [serde (rename = "pending")] Pending , # [serde (rename = "submitted")] Submitted , # [serde (rename = "registered")] Registered , # [serde (rename = "removed")] Removed , # [serde (rename = "failed")] Failed , } impl From < & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus { fn from (value : & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Pending => write ! (f , "pending") , Self :: Submitted => write ! (f , "submitted") , Self :: Registered => write ! (f , "registered") , Self :: Removed => write ! (f , "removed") , Self :: Failed => write ! (f , "failed") , } } } impl std :: str :: FromStr for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "pending" => Ok (Self :: Pending) , "submitted" => Ok (Self :: Submitted) , "registered" => Ok (Self :: Registered) , "removed" => Ok (Self :: Removed) , "failed" => Ok (Self :: Failed) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetProjectsProjectIdRemoveAssertionsCalldataResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_ids\","] # [doc = "    \"calldata\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_ids\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"calldata\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdRemoveAssertionsCalldataResponse { pub assertion_ids : Vec < String > , pub calldata : String , } impl From < & GetProjectsProjectIdRemoveAssertionsCalldataResponse > for GetProjectsProjectIdRemoveAssertionsCalldataResponse { fn from (value : & GetProjectsProjectIdRemoveAssertionsCalldataResponse) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"created_at\","] # [doc = "    \"project_id\","] # [doc = "    \"project_manager\","] # [doc = "    \"project_name\","] # [doc = "    \"project_networks\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chain_names\": {"] # [doc = "      \"description\": \"Array of human-readable chain names that maps 1:1 with project_networks array\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"pending_verification_contracts\": {"] # [doc = "      \"description\": \"Array of contract addresses that have pending manual verification requests\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"project_description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 1000"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"project_manager\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    },"] # [doc = "    \"project_networks\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"integer\","] # [doc = "        \"exclusiveMinimum\": 0.0"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"saved_count\": {"] # [doc = "      \"default\": 0,"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdResponse { # [doc = "Array of human-readable chain names that maps 1:1 with project_networks array"] # [serde (default , skip_serializing_if = "Vec::is_empty")] pub chain_names : Vec < String > , pub created_at : chrono :: DateTime < chrono :: offset :: Utc > , # [doc = "Array of contract addresses that have pending manual verification requests"] # [serde (default , skip_serializing_if = "Vec::is_empty")] pub pending_verification_contracts : Vec < GetProjectsProjectIdResponsePendingVerificationContractsItem > , # [serde (default , skip_serializing_if = "Option::is_none")] pub profile_image_url : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_description : Option < GetProjectsProjectIdResponseProjectDescription > , pub project_id : uuid :: Uuid , pub project_manager : GetProjectsProjectIdResponseProjectManager , pub project_name : GetProjectsProjectIdResponseProjectName , pub project_networks : Vec < std :: num :: NonZeroU64 > , # [serde (default)] pub saved_count : u64 , } impl From < & GetProjectsProjectIdResponse > for GetProjectsProjectIdResponse { fn from (value : & GetProjectsProjectIdResponse) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdResponsePendingVerificationContractsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsProjectIdResponsePendingVerificationContractsItem (String) ; impl :: std :: ops :: Deref for GetProjectsProjectIdResponsePendingVerificationContractsItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsProjectIdResponsePendingVerificationContractsItem > for String { fn from (value : GetProjectsProjectIdResponsePendingVerificationContractsItem) -> Self { value . 0 } } impl From < & GetProjectsProjectIdResponsePendingVerificationContractsItem > for GetProjectsProjectIdResponsePendingVerificationContractsItem { fn from (value : & GetProjectsProjectIdResponsePendingVerificationContractsItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsProjectIdResponsePendingVerificationContractsItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdResponsePendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdResponsePendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdResponsePendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdResponsePendingVerificationContractsItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsProjectIdResponseProjectDescription"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 1000"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsProjectIdResponseProjectDescription (String) ; impl :: std :: ops :: Deref for GetProjectsProjectIdResponseProjectDescription { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsProjectIdResponseProjectDescription > for String { fn from (value : GetProjectsProjectIdResponseProjectDescription) -> Self { value . 0 } } impl From < & GetProjectsProjectIdResponseProjectDescription > for GetProjectsProjectIdResponseProjectDescription { fn from (value : & GetProjectsProjectIdResponseProjectDescription) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsProjectIdResponseProjectDescription { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 1000usize { return Err ("longer than 1000 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdResponseProjectDescription { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsProjectIdResponseProjectManager"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsProjectIdResponseProjectManager (String) ; impl :: std :: ops :: Deref for GetProjectsProjectIdResponseProjectManager { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsProjectIdResponseProjectManager > for String { fn from (value : GetProjectsProjectIdResponseProjectManager) -> Self { value . 0 } } impl From < & GetProjectsProjectIdResponseProjectManager > for GetProjectsProjectIdResponseProjectManager { fn from (value : & GetProjectsProjectIdResponseProjectManager) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsProjectIdResponseProjectManager { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdResponseProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdResponseProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdResponseProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdResponseProjectManager { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsProjectIdResponseProjectName"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsProjectIdResponseProjectName (String) ; impl :: std :: ops :: Deref for GetProjectsProjectIdResponseProjectName { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsProjectIdResponseProjectName > for String { fn from (value : GetProjectsProjectIdResponseProjectName) -> Self { value . 0 } } impl From < & GetProjectsProjectIdResponseProjectName > for GetProjectsProjectIdResponseProjectName { fn from (value : & GetProjectsProjectIdResponseProjectName) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsProjectIdResponseProjectName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdResponseProjectName { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsProjectIdSubmittedAssertionsEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"all\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\","] # [doc = "    \"all\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetProjectsProjectIdSubmittedAssertionsEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , # [serde (rename = "all")] All , } impl From < & GetProjectsProjectIdSubmittedAssertionsEnvironment > for GetProjectsProjectIdSubmittedAssertionsEnvironment { fn from (value : & GetProjectsProjectIdSubmittedAssertionsEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetProjectsProjectIdSubmittedAssertionsEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , Self :: All => write ! (f , "all") , } } } impl std :: str :: FromStr for GetProjectsProjectIdSubmittedAssertionsEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , "all" => Ok (Self :: All) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetProjectsProjectIdSubmittedAssertionsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetProjectsProjectIdSubmittedAssertionsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetProjectsProjectIdSubmittedAssertionsEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl Default for GetProjectsProjectIdSubmittedAssertionsEnvironment { fn default () -> Self { GetProjectsProjectIdSubmittedAssertionsEnvironment :: All } } # [doc = "GetProjectsProjectIdSubmittedAssertionsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"submitted_assertions\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"submitted_assertions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_functions\","] # [doc = "          \"assertion_id\","] # [doc = "          \"bytecode\","] # [doc = "          \"contract_name\","] # [doc = "          \"registered_at\","] # [doc = "          \"signature\","] # [doc = "          \"source_code\","] # [doc = "          \"status\","] # [doc = "          \"submitted_at\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopters\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"assertion_functions\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"bytecode\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"contract_name\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"environment\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"registered_at\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"signature\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"source_code\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"status\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"submitted_at\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdSubmittedAssertionsResponse { pub submitted_assertions : Vec < GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem > , } impl From < & GetProjectsProjectIdSubmittedAssertionsResponse > for GetProjectsProjectIdSubmittedAssertionsResponse { fn from (value : & GetProjectsProjectIdSubmittedAssertionsResponse) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_functions\","] # [doc = "    \"assertion_id\","] # [doc = "    \"bytecode\","] # [doc = "    \"contract_name\","] # [doc = "    \"registered_at\","] # [doc = "    \"signature\","] # [doc = "    \"source_code\","] # [doc = "    \"status\","] # [doc = "    \"submitted_at\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopters\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertion_functions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"bytecode\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"contract_name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"registered_at\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"signature\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"source_code\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"submitted_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem { # [serde (default , skip_serializing_if = "Vec::is_empty")] pub assertion_adopters : Vec < String > , pub assertion_functions : Vec < String > , pub assertion_id : String , pub bytecode : Option < String > , pub contract_name : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub environment : Option < String > , pub registered_at : Option < String > , pub signature : String , pub source_code : Option < String > , pub status : String , pub submitted_at : String , } impl From < & GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem > for GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem { fn from (value : & GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdWidgetResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"project_id\","] # [doc = "    \"project_name\","] # [doc = "    \"saved_count\","] # [doc = "    \"total_registered_assertions\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"project_description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 1000"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    },"] # [doc = "    \"saved_count\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"total_registered_assertions\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsProjectIdWidgetResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub profile_image_url : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_description : Option < GetProjectsProjectIdWidgetResponseProjectDescription > , pub project_id : uuid :: Uuid , pub project_name : GetProjectsProjectIdWidgetResponseProjectName , pub saved_count : u64 , pub total_registered_assertions : u64 , } impl From < & GetProjectsProjectIdWidgetResponse > for GetProjectsProjectIdWidgetResponse { fn from (value : & GetProjectsProjectIdWidgetResponse) -> Self { value . clone () } } # [doc = "GetProjectsProjectIdWidgetResponseProjectDescription"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 1000"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsProjectIdWidgetResponseProjectDescription (String) ; impl :: std :: ops :: Deref for GetProjectsProjectIdWidgetResponseProjectDescription { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsProjectIdWidgetResponseProjectDescription > for String { fn from (value : GetProjectsProjectIdWidgetResponseProjectDescription) -> Self { value . 0 } } impl From < & GetProjectsProjectIdWidgetResponseProjectDescription > for GetProjectsProjectIdWidgetResponseProjectDescription { fn from (value : & GetProjectsProjectIdWidgetResponseProjectDescription) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsProjectIdWidgetResponseProjectDescription { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 1000usize { return Err ("longer than 1000 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdWidgetResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdWidgetResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdWidgetResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdWidgetResponseProjectDescription { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsProjectIdWidgetResponseProjectName"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsProjectIdWidgetResponseProjectName (String) ; impl :: std :: ops :: Deref for GetProjectsProjectIdWidgetResponseProjectName { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsProjectIdWidgetResponseProjectName > for String { fn from (value : GetProjectsProjectIdWidgetResponseProjectName) -> Self { value . 0 } } impl From < & GetProjectsProjectIdWidgetResponseProjectName > for GetProjectsProjectIdWidgetResponseProjectName { fn from (value : & GetProjectsProjectIdWidgetResponseProjectName) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsProjectIdWidgetResponseProjectName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdWidgetResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdWidgetResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdWidgetResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdWidgetResponseProjectName { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"error\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"code\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"details\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub code : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub details : Option < String > , pub error : String , } impl From < & GetProjectsResponse > for GetProjectsResponse { fn from (value : & GetProjectsResponse) -> Self { value . clone () } } # [doc = "GetProjectsResponseItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"created_at\","] # [doc = "    \"project_id\","] # [doc = "    \"project_manager\","] # [doc = "    \"project_name\","] # [doc = "    \"project_networks\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chain_names\": {"] # [doc = "      \"description\": \"Array of human-readable chain names that maps 1:1 with project_networks array\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"pending_verification_contracts\": {"] # [doc = "      \"description\": \"Array of contract addresses that have pending manual verification requests\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"project_description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 1000"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"project_manager\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    },"] # [doc = "    \"project_networks\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"integer\","] # [doc = "        \"exclusiveMinimum\": 0.0"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"saved_count\": {"] # [doc = "      \"default\": 0,"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsResponseItem { # [doc = "Array of human-readable chain names that maps 1:1 with project_networks array"] # [serde (default , skip_serializing_if = "Vec::is_empty")] pub chain_names : Vec < String > , pub created_at : chrono :: DateTime < chrono :: offset :: Utc > , # [doc = "Array of contract addresses that have pending manual verification requests"] # [serde (default , skip_serializing_if = "Vec::is_empty")] pub pending_verification_contracts : Vec < GetProjectsResponseItemPendingVerificationContractsItem > , # [serde (default , skip_serializing_if = "Option::is_none")] pub profile_image_url : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_description : Option < GetProjectsResponseItemProjectDescription > , pub project_id : uuid :: Uuid , pub project_manager : GetProjectsResponseItemProjectManager , pub project_name : GetProjectsResponseItemProjectName , pub project_networks : Vec < std :: num :: NonZeroU64 > , # [serde (default)] pub saved_count : u64 , } impl From < & GetProjectsResponseItem > for GetProjectsResponseItem { fn from (value : & GetProjectsResponseItem) -> Self { value . clone () } } # [doc = "GetProjectsResponseItemPendingVerificationContractsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsResponseItemPendingVerificationContractsItem (String) ; impl :: std :: ops :: Deref for GetProjectsResponseItemPendingVerificationContractsItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsResponseItemPendingVerificationContractsItem > for String { fn from (value : GetProjectsResponseItemPendingVerificationContractsItem) -> Self { value . 0 } } impl From < & GetProjectsResponseItemPendingVerificationContractsItem > for GetProjectsResponseItemPendingVerificationContractsItem { fn from (value : & GetProjectsResponseItemPendingVerificationContractsItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsResponseItemPendingVerificationContractsItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsResponseItemPendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsResponseItemPendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsResponseItemPendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsResponseItemPendingVerificationContractsItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsResponseItemProjectDescription"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 1000"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsResponseItemProjectDescription (String) ; impl :: std :: ops :: Deref for GetProjectsResponseItemProjectDescription { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsResponseItemProjectDescription > for String { fn from (value : GetProjectsResponseItemProjectDescription) -> Self { value . 0 } } impl From < & GetProjectsResponseItemProjectDescription > for GetProjectsResponseItemProjectDescription { fn from (value : & GetProjectsResponseItemProjectDescription) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsResponseItemProjectDescription { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 1000usize { return Err ("longer than 1000 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsResponseItemProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsResponseItemProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsResponseItemProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsResponseItemProjectDescription { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsResponseItemProjectManager"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsResponseItemProjectManager (String) ; impl :: std :: ops :: Deref for GetProjectsResponseItemProjectManager { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsResponseItemProjectManager > for String { fn from (value : GetProjectsResponseItemProjectManager) -> Self { value . 0 } } impl From < & GetProjectsResponseItemProjectManager > for GetProjectsResponseItemProjectManager { fn from (value : & GetProjectsResponseItemProjectManager) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsResponseItemProjectManager { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsResponseItemProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsResponseItemProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsResponseItemProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsResponseItemProjectManager { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsResponseItemProjectName"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsResponseItemProjectName (String) ; impl :: std :: ops :: Deref for GetProjectsResponseItemProjectName { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsResponseItemProjectName > for String { fn from (value : GetProjectsResponseItemProjectName) -> Self { value . 0 } } impl From < & GetProjectsResponseItemProjectName > for GetProjectsResponseItemProjectName { fn from (value : & GetProjectsResponseItemProjectName) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsResponseItemProjectName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsResponseItemProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsResponseItemProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsResponseItemProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsResponseItemProjectName { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsSavedResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"error\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"code\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"details\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsSavedResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub code : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub details : Option < String > , pub error : String , } impl From < & GetProjectsSavedResponse > for GetProjectsSavedResponse { fn from (value : & GetProjectsSavedResponse) -> Self { value . clone () } } # [doc = "GetProjectsSavedResponseItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"created_at\","] # [doc = "    \"project_id\","] # [doc = "    \"project_manager\","] # [doc = "    \"project_name\","] # [doc = "    \"project_networks\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chain_names\": {"] # [doc = "      \"description\": \"Array of human-readable chain names that maps 1:1 with project_networks array\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"pending_verification_contracts\": {"] # [doc = "      \"description\": \"Array of contract addresses that have pending manual verification requests\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"project_description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 1000"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"project_manager\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    },"] # [doc = "    \"project_networks\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"integer\","] # [doc = "        \"exclusiveMinimum\": 0.0"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"saved_count\": {"] # [doc = "      \"default\": 0,"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetProjectsSavedResponseItem { # [doc = "Array of human-readable chain names that maps 1:1 with project_networks array"] # [serde (default , skip_serializing_if = "Vec::is_empty")] pub chain_names : Vec < String > , pub created_at : chrono :: DateTime < chrono :: offset :: Utc > , # [doc = "Array of contract addresses that have pending manual verification requests"] # [serde (default , skip_serializing_if = "Vec::is_empty")] pub pending_verification_contracts : Vec < GetProjectsSavedResponseItemPendingVerificationContractsItem > , # [serde (default , skip_serializing_if = "Option::is_none")] pub profile_image_url : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_description : Option < GetProjectsSavedResponseItemProjectDescription > , pub project_id : uuid :: Uuid , pub project_manager : GetProjectsSavedResponseItemProjectManager , pub project_name : GetProjectsSavedResponseItemProjectName , pub project_networks : Vec < std :: num :: NonZeroU64 > , # [serde (default)] pub saved_count : u64 , } impl From < & GetProjectsSavedResponseItem > for GetProjectsSavedResponseItem { fn from (value : & GetProjectsSavedResponseItem) -> Self { value . clone () } } # [doc = "GetProjectsSavedResponseItemPendingVerificationContractsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsSavedResponseItemPendingVerificationContractsItem (String) ; impl :: std :: ops :: Deref for GetProjectsSavedResponseItemPendingVerificationContractsItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsSavedResponseItemPendingVerificationContractsItem > for String { fn from (value : GetProjectsSavedResponseItemPendingVerificationContractsItem) -> Self { value . 0 } } impl From < & GetProjectsSavedResponseItemPendingVerificationContractsItem > for GetProjectsSavedResponseItemPendingVerificationContractsItem { fn from (value : & GetProjectsSavedResponseItemPendingVerificationContractsItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsSavedResponseItemPendingVerificationContractsItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsSavedResponseItemPendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsSavedResponseItemPendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsSavedResponseItemPendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsSavedResponseItemPendingVerificationContractsItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsSavedResponseItemProjectDescription"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 1000"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsSavedResponseItemProjectDescription (String) ; impl :: std :: ops :: Deref for GetProjectsSavedResponseItemProjectDescription { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsSavedResponseItemProjectDescription > for String { fn from (value : GetProjectsSavedResponseItemProjectDescription) -> Self { value . 0 } } impl From < & GetProjectsSavedResponseItemProjectDescription > for GetProjectsSavedResponseItemProjectDescription { fn from (value : & GetProjectsSavedResponseItemProjectDescription) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsSavedResponseItemProjectDescription { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 1000usize { return Err ("longer than 1000 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsSavedResponseItemProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsSavedResponseItemProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsSavedResponseItemProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsSavedResponseItemProjectDescription { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsSavedResponseItemProjectManager"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsSavedResponseItemProjectManager (String) ; impl :: std :: ops :: Deref for GetProjectsSavedResponseItemProjectManager { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsSavedResponseItemProjectManager > for String { fn from (value : GetProjectsSavedResponseItemProjectManager) -> Self { value . 0 } } impl From < & GetProjectsSavedResponseItemProjectManager > for GetProjectsSavedResponseItemProjectManager { fn from (value : & GetProjectsSavedResponseItemProjectManager) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsSavedResponseItemProjectManager { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsSavedResponseItemProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsSavedResponseItemProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsSavedResponseItemProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsSavedResponseItemProjectManager { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsSavedResponseItemProjectName"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsSavedResponseItemProjectName (String) ; impl :: std :: ops :: Deref for GetProjectsSavedResponseItemProjectName { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsSavedResponseItemProjectName > for String { fn from (value : GetProjectsSavedResponseItemProjectName) -> Self { value . 0 } } impl From < & GetProjectsSavedResponseItemProjectName > for GetProjectsSavedResponseItemProjectName { fn from (value : & GetProjectsSavedResponseItemProjectName) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsSavedResponseItemProjectName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsSavedResponseItemProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsSavedResponseItemProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsSavedResponseItemProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsSavedResponseItemProjectName { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetProjectsUser"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetProjectsUser (String) ; impl :: std :: ops :: Deref for GetProjectsUser { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetProjectsUser > for String { fn from (value : GetProjectsUser) -> Self { value . 0 } } impl From < & GetProjectsUser > for GetProjectsUser { fn from (value : & GetProjectsUser) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetProjectsUser { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetProjectsUser { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetProjectsUser { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetProjectsUser { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsUser { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetPublicIncidentsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"data\","] # [doc = "    \"pagination\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"data\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"id\","] # [doc = "          \"network\","] # [doc = "          \"referenceId\","] # [doc = "          \"timestamp\","] # [doc = "          \"title\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"uuid\""] # [doc = "          },"] # [doc = "          \"network\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"chainId\","] # [doc = "              \"name\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"chainId\": {"] # [doc = "                \"type\": \"number\""] # [doc = "              },"] # [doc = "              \"name\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"referenceId\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"timestamp\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"date-time\""] # [doc = "          },"] # [doc = "          \"title\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"metadata\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"properties\": {"] # [doc = "        \"network\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"pagination\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"hasNext\","] # [doc = "        \"hasPrevious\","] # [doc = "        \"limit\","] # [doc = "        \"page\","] # [doc = "        \"totalCount\","] # [doc = "        \"totalPages\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"hasNext\": {"] # [doc = "          \"type\": \"boolean\""] # [doc = "        },"] # [doc = "        \"hasPrevious\": {"] # [doc = "          \"type\": \"boolean\""] # [doc = "        },"] # [doc = "        \"limit\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"page\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"totalCount\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"minimum\": 0.0"] # [doc = "        },"] # [doc = "        \"totalPages\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"minimum\": 0.0"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetPublicIncidentsResponse { pub data : Vec < GetPublicIncidentsResponseDataItem > , # [serde (default , skip_serializing_if = "Option::is_none")] pub metadata : Option < GetPublicIncidentsResponseMetadata > , pub pagination : GetPublicIncidentsResponsePagination , } impl From < & GetPublicIncidentsResponse > for GetPublicIncidentsResponse { fn from (value : & GetPublicIncidentsResponse) -> Self { value . clone () } } # [doc = "GetPublicIncidentsResponseDataItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"id\","] # [doc = "    \"network\","] # [doc = "    \"referenceId\","] # [doc = "    \"timestamp\","] # [doc = "    \"title\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"network\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"chainId\","] # [doc = "        \"name\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"chainId\": {"] # [doc = "          \"type\": \"number\""] # [doc = "        },"] # [doc = "        \"name\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"referenceId\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"timestamp\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"title\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetPublicIncidentsResponseDataItem { pub id : uuid :: Uuid , pub network : GetPublicIncidentsResponseDataItemNetwork , # [serde (rename = "referenceId")] pub reference_id : String , pub timestamp : chrono :: DateTime < chrono :: offset :: Utc > , pub title : String , } impl From < & GetPublicIncidentsResponseDataItem > for GetPublicIncidentsResponseDataItem { fn from (value : & GetPublicIncidentsResponseDataItem) -> Self { value . clone () } } # [doc = "GetPublicIncidentsResponseDataItemNetwork"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"chainId\","] # [doc = "    \"name\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chainId\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetPublicIncidentsResponseDataItemNetwork { # [serde (rename = "chainId")] pub chain_id : f64 , pub name : String , } impl From < & GetPublicIncidentsResponseDataItemNetwork > for GetPublicIncidentsResponseDataItemNetwork { fn from (value : & GetPublicIncidentsResponseDataItemNetwork) -> Self { value . clone () } } # [doc = "GetPublicIncidentsResponseMetadata"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"network\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetPublicIncidentsResponseMetadata { # [serde (default , skip_serializing_if = "Option::is_none")] pub network : Option < std :: num :: NonZeroU64 > , } impl From < & GetPublicIncidentsResponseMetadata > for GetPublicIncidentsResponseMetadata { fn from (value : & GetPublicIncidentsResponseMetadata) -> Self { value . clone () } } # [doc = "GetPublicIncidentsResponsePagination"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"hasNext\","] # [doc = "    \"hasPrevious\","] # [doc = "    \"limit\","] # [doc = "    \"page\","] # [doc = "    \"totalCount\","] # [doc = "    \"totalPages\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"hasNext\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"hasPrevious\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"limit\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"page\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"totalCount\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"totalPages\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetPublicIncidentsResponsePagination { # [serde (rename = "hasNext")] pub has_next : bool , # [serde (rename = "hasPrevious")] pub has_previous : bool , pub limit : std :: num :: NonZeroU64 , pub page : std :: num :: NonZeroU64 , # [serde (rename = "totalCount")] pub total_count : u64 , # [serde (rename = "totalPages")] pub total_pages : u64 , } impl From < & GetPublicIncidentsResponsePagination > for GetPublicIncidentsResponsePagination { fn from (value : & GetPublicIncidentsResponsePagination) -> Self { value . clone () } } # [doc = "GetPublicIncidentsSort"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"timestamp_desc\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"timestamp_asc\","] # [doc = "    \"timestamp_desc\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetPublicIncidentsSort { # [serde (rename = "timestamp_asc")] TimestampAsc , # [serde (rename = "timestamp_desc")] TimestampDesc , } impl From < & GetPublicIncidentsSort > for GetPublicIncidentsSort { fn from (value : & GetPublicIncidentsSort) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetPublicIncidentsSort { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: TimestampAsc => write ! (f , "timestamp_asc") , Self :: TimestampDesc => write ! (f , "timestamp_desc") , } } } impl std :: str :: FromStr for GetPublicIncidentsSort { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "timestamp_asc" => Ok (Self :: TimestampAsc) , "timestamp_desc" => Ok (Self :: TimestampDesc) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetPublicIncidentsSort { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetPublicIncidentsSort { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetPublicIncidentsSort { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl Default for GetPublicIncidentsSort { fn default () -> Self { GetPublicIncidentsSort :: TimestampDesc } } # [doc = "GetSearchQuery"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetSearchQuery (String) ; impl :: std :: ops :: Deref for GetSearchQuery { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetSearchQuery > for String { fn from (value : GetSearchQuery) -> Self { value . 0 } } impl From < & GetSearchQuery > for GetSearchQuery { fn from (value : & GetSearchQuery) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetSearchQuery { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetSearchQuery { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetSearchQuery { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetSearchQuery { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetSearchQuery { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetSearchResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"contracts\","] # [doc = "    \"projects\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"contracts\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"data\","] # [doc = "          \"foundBy\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"data\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"id\","] # [doc = "              \"network\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"contract_name\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"id\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"network\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"related_project_id\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"foundBy\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"projects\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"profile_image_url\","] # [doc = "          \"project_id\","] # [doc = "          \"project_name\","] # [doc = "          \"project_networks\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"profile_image_url\": {"] # [doc = "            \"type\": ["] # [doc = "              \"string\","] # [doc = "              \"null\""] # [doc = "            ]"] # [doc = "          },"] # [doc = "          \"project_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"project_name\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"project_networks\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSearchResponse { pub contracts : Vec < GetSearchResponseContractsItem > , pub projects : Vec < GetSearchResponseProjectsItem > , } impl From < & GetSearchResponse > for GetSearchResponse { fn from (value : & GetSearchResponse) -> Self { value . clone () } } # [doc = "GetSearchResponseContractsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"data\","] # [doc = "    \"foundBy\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"data\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"address\","] # [doc = "        \"id\","] # [doc = "        \"network\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"address\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"contract_name\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"id\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"network\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"related_project_id\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"foundBy\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSearchResponseContractsItem { pub data : GetSearchResponseContractsItemData , # [serde (rename = "foundBy")] pub found_by : String , } impl From < & GetSearchResponseContractsItem > for GetSearchResponseContractsItem { fn from (value : & GetSearchResponseContractsItem) -> Self { value . clone () } } # [doc = "GetSearchResponseContractsItemData"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"id\","] # [doc = "    \"network\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"contract_name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"network\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"related_project_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSearchResponseContractsItemData { pub address : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub contract_name : Option < String > , pub id : String , pub network : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub related_project_id : Option < String > , } impl From < & GetSearchResponseContractsItemData > for GetSearchResponseContractsItemData { fn from (value : & GetSearchResponseContractsItemData) -> Self { value . clone () } } # [doc = "GetSearchResponseProjectsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"profile_image_url\","] # [doc = "    \"project_id\","] # [doc = "    \"project_name\","] # [doc = "    \"project_networks\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"project_networks\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSearchResponseProjectsItem { pub profile_image_url : Option < String > , pub project_id : String , pub project_name : String , pub project_networks : Vec < String > , } impl From < & GetSearchResponseProjectsItem > for GetSearchResponseProjectsItem { fn from (value : & GetSearchResponseProjectsItem) -> Self { value . clone () } } # [doc = "GetStatsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_count\","] # [doc = "    \"project_count\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_count\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"metadata\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"filters\","] # [doc = "        \"has_filters\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"filters\": {"] # [doc = "          \"type\": \"object\","] # [doc = "          \"properties\": {"] # [doc = "            \"network_id\": {"] # [doc = "              \"type\": \"number\""] # [doc = "            },"] # [doc = "            \"user\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "            },"] # [doc = "            \"with_assertions_only\": {"] # [doc = "              \"type\": \"boolean\""] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"has_filters\": {"] # [doc = "          \"type\": \"boolean\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"project_count\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetStatsResponse { pub assertion_count : u64 , # [serde (default , skip_serializing_if = "Option::is_none")] pub metadata : Option < GetStatsResponseMetadata > , pub project_count : u64 , } impl From < & GetStatsResponse > for GetStatsResponse { fn from (value : & GetStatsResponse) -> Self { value . clone () } } # [doc = "GetStatsResponseMetadata"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"filters\","] # [doc = "    \"has_filters\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"filters\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"properties\": {"] # [doc = "        \"network_id\": {"] # [doc = "          \"type\": \"number\""] # [doc = "        },"] # [doc = "        \"user\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"with_assertions_only\": {"] # [doc = "          \"type\": \"boolean\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"has_filters\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetStatsResponseMetadata { pub filters : GetStatsResponseMetadataFilters , pub has_filters : bool , } impl From < & GetStatsResponseMetadata > for GetStatsResponseMetadata { fn from (value : & GetStatsResponseMetadata) -> Self { value . clone () } } # [doc = "GetStatsResponseMetadataFilters"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"network_id\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"user\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"with_assertions_only\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetStatsResponseMetadataFilters { # [serde (default , skip_serializing_if = "Option::is_none")] pub network_id : Option < f64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub user : Option < GetStatsResponseMetadataFiltersUser > , # [serde (default , skip_serializing_if = "Option::is_none")] pub with_assertions_only : Option < bool > , } impl From < & GetStatsResponseMetadataFilters > for GetStatsResponseMetadataFilters { fn from (value : & GetStatsResponseMetadataFilters) -> Self { value . clone () } } # [doc = "GetStatsResponseMetadataFiltersUser"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetStatsResponseMetadataFiltersUser (String) ; impl :: std :: ops :: Deref for GetStatsResponseMetadataFiltersUser { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetStatsResponseMetadataFiltersUser > for String { fn from (value : GetStatsResponseMetadataFiltersUser) -> Self { value . 0 } } impl From < & GetStatsResponseMetadataFiltersUser > for GetStatsResponseMetadataFiltersUser { fn from (value : & GetStatsResponseMetadataFiltersUser) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetStatsResponseMetadataFiltersUser { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetStatsResponseMetadataFiltersUser { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetStatsResponseMetadataFiltersUser { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetStatsResponseMetadataFiltersUser { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetStatsResponseMetadataFiltersUser { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetStatsUser"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetStatsUser (String) ; impl :: std :: ops :: Deref for GetStatsUser { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetStatsUser > for String { fn from (value : GetStatsUser) -> Self { value . 0 } } impl From < & GetStatsUser > for GetStatsUser { fn from (value : & GetStatsUser) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetStatsUser { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetStatsUser { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetStatsUser { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetStatsUser { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetStatsUser { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetSystemStatusResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertionDa\","] # [doc = "    \"assertionDas\","] # [doc = "    \"assertionEnforcer\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertionDa\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"operational\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"message\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"operational\": {"] # [doc = "          \"type\": \"boolean\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertionDas\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"id\","] # [doc = "          \"name\","] # [doc = "          \"operational\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"chainId\": {"] # [doc = "            \"type\": \"number\""] # [doc = "          },"] # [doc = "          \"id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"message\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"name\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"operational\": {"] # [doc = "            \"type\": \"boolean\""] # [doc = "          },"] # [doc = "          \"url\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertionEnforcer\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"operational\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"message\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"operational\": {"] # [doc = "          \"type\": \"boolean\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertionEnforcers\": {"] # [doc = "      \"default\": [],"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"id\","] # [doc = "          \"name\","] # [doc = "          \"operational\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"chainId\": {"] # [doc = "            \"type\": \"number\""] # [doc = "          },"] # [doc = "          \"id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"message\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"name\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"operational\": {"] # [doc = "            \"type\": \"boolean\""] # [doc = "          },"] # [doc = "          \"url\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"enforcers\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"networkStatus\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"networkStatus\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"chain_id\","] # [doc = "              \"last_updated\","] # [doc = "              \"operational\","] # [doc = "              \"stale\","] # [doc = "              \"status\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"chain_id\": {"] # [doc = "                \"type\": \"integer\""] # [doc = "              },"] # [doc = "              \"last_updated\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"format\": \"date-time\""] # [doc = "              },"] # [doc = "              \"message\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"metadata\": {"] # [doc = "                \"type\": \"object\","] # [doc = "                \"properties\": {"] # [doc = "                  \"degradation_reason\": {"] # [doc = "                    \"type\": \"string\""] # [doc = "                  },"] # [doc = "                  \"message\": {"] # [doc = "                    \"type\": \"string\""] # [doc = "                  }"] # [doc = "                }"] # [doc = "              },"] # [doc = "              \"operational\": {"] # [doc = "                \"type\": \"boolean\""] # [doc = "              },"] # [doc = "              \"stale\": {"] # [doc = "                \"type\": \"boolean\""] # [doc = "              },"] # [doc = "              \"status\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"enum\": ["] # [doc = "                  \"operational\","] # [doc = "                  \"degraded\","] # [doc = "                  \"outage\""] # [doc = "                ]"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"rpc\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"id\","] # [doc = "              \"operational\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"id\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"operational\": {"] # [doc = "                \"type\": \"boolean\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSystemStatusResponse { # [serde (rename = "assertionDa")] pub assertion_da : GetSystemStatusResponseAssertionDa , # [serde (rename = "assertionDas")] pub assertion_das : Vec < GetSystemStatusResponseAssertionDasItem > , # [serde (rename = "assertionEnforcer")] pub assertion_enforcer : GetSystemStatusResponseAssertionEnforcer , # [serde (rename = "assertionEnforcers" , default , skip_serializing_if = "Vec::is_empty")] pub assertion_enforcers : Vec < GetSystemStatusResponseAssertionEnforcersItem > , # [serde (default , skip_serializing_if = "Option::is_none")] pub enforcers : Option < GetSystemStatusResponseEnforcers > , } impl From < & GetSystemStatusResponse > for GetSystemStatusResponse { fn from (value : & GetSystemStatusResponse) -> Self { value . clone () } } # [doc = "GetSystemStatusResponseAssertionDa"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"operational\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"operational\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSystemStatusResponseAssertionDa { # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , pub operational : bool , } impl From < & GetSystemStatusResponseAssertionDa > for GetSystemStatusResponseAssertionDa { fn from (value : & GetSystemStatusResponseAssertionDa) -> Self { value . clone () } } # [doc = "GetSystemStatusResponseAssertionDasItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"id\","] # [doc = "    \"name\","] # [doc = "    \"operational\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chainId\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"operational\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"url\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSystemStatusResponseAssertionDasItem { # [serde (rename = "chainId" , default , skip_serializing_if = "Option::is_none")] pub chain_id : Option < f64 > , pub id : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , pub name : String , pub operational : bool , # [serde (default , skip_serializing_if = "Option::is_none")] pub url : Option < String > , } impl From < & GetSystemStatusResponseAssertionDasItem > for GetSystemStatusResponseAssertionDasItem { fn from (value : & GetSystemStatusResponseAssertionDasItem) -> Self { value . clone () } } # [doc = "GetSystemStatusResponseAssertionEnforcer"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"operational\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"operational\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSystemStatusResponseAssertionEnforcer { # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , pub operational : bool , } impl From < & GetSystemStatusResponseAssertionEnforcer > for GetSystemStatusResponseAssertionEnforcer { fn from (value : & GetSystemStatusResponseAssertionEnforcer) -> Self { value . clone () } } # [doc = "GetSystemStatusResponseAssertionEnforcersItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"id\","] # [doc = "    \"name\","] # [doc = "    \"operational\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chainId\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"operational\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"url\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSystemStatusResponseAssertionEnforcersItem { # [serde (rename = "chainId" , default , skip_serializing_if = "Option::is_none")] pub chain_id : Option < f64 > , pub id : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , pub name : String , pub operational : bool , # [serde (default , skip_serializing_if = "Option::is_none")] pub url : Option < String > , } impl From < & GetSystemStatusResponseAssertionEnforcersItem > for GetSystemStatusResponseAssertionEnforcersItem { fn from (value : & GetSystemStatusResponseAssertionEnforcersItem) -> Self { value . clone () } } # [doc = "GetSystemStatusResponseEnforcers"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"networkStatus\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"networkStatus\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"chain_id\","] # [doc = "          \"last_updated\","] # [doc = "          \"operational\","] # [doc = "          \"stale\","] # [doc = "          \"status\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"chain_id\": {"] # [doc = "            \"type\": \"integer\""] # [doc = "          },"] # [doc = "          \"last_updated\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"date-time\""] # [doc = "          },"] # [doc = "          \"message\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"metadata\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"properties\": {"] # [doc = "              \"degradation_reason\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"message\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"operational\": {"] # [doc = "            \"type\": \"boolean\""] # [doc = "          },"] # [doc = "          \"stale\": {"] # [doc = "            \"type\": \"boolean\""] # [doc = "          },"] # [doc = "          \"status\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"enum\": ["] # [doc = "              \"operational\","] # [doc = "              \"degraded\","] # [doc = "              \"outage\""] # [doc = "            ]"] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"rpc\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"id\","] # [doc = "          \"operational\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"operational\": {"] # [doc = "            \"type\": \"boolean\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSystemStatusResponseEnforcers { # [serde (rename = "networkStatus")] pub network_status : Vec < GetSystemStatusResponseEnforcersNetworkStatusItem > , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub rpc : Vec < GetSystemStatusResponseEnforcersRpcItem > , } impl From < & GetSystemStatusResponseEnforcers > for GetSystemStatusResponseEnforcers { fn from (value : & GetSystemStatusResponseEnforcers) -> Self { value . clone () } } # [doc = "GetSystemStatusResponseEnforcersNetworkStatusItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"chain_id\","] # [doc = "    \"last_updated\","] # [doc = "    \"operational\","] # [doc = "    \"stale\","] # [doc = "    \"status\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chain_id\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"last_updated\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"metadata\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"properties\": {"] # [doc = "        \"degradation_reason\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"message\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"operational\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"stale\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"operational\","] # [doc = "        \"degraded\","] # [doc = "        \"outage\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSystemStatusResponseEnforcersNetworkStatusItem { pub chain_id : i64 , pub last_updated : chrono :: DateTime < chrono :: offset :: Utc > , # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub metadata : Option < GetSystemStatusResponseEnforcersNetworkStatusItemMetadata > , pub operational : bool , pub stale : bool , pub status : GetSystemStatusResponseEnforcersNetworkStatusItemStatus , } impl From < & GetSystemStatusResponseEnforcersNetworkStatusItem > for GetSystemStatusResponseEnforcersNetworkStatusItem { fn from (value : & GetSystemStatusResponseEnforcersNetworkStatusItem) -> Self { value . clone () } } # [doc = "GetSystemStatusResponseEnforcersNetworkStatusItemMetadata"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"degradation_reason\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSystemStatusResponseEnforcersNetworkStatusItemMetadata { # [serde (default , skip_serializing_if = "Option::is_none")] pub degradation_reason : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , } impl From < & GetSystemStatusResponseEnforcersNetworkStatusItemMetadata > for GetSystemStatusResponseEnforcersNetworkStatusItemMetadata { fn from (value : & GetSystemStatusResponseEnforcersNetworkStatusItemMetadata) -> Self { value . clone () } } # [doc = "GetSystemStatusResponseEnforcersNetworkStatusItemStatus"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"operational\","] # [doc = "    \"degraded\","] # [doc = "    \"outage\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetSystemStatusResponseEnforcersNetworkStatusItemStatus { # [serde (rename = "operational")] Operational , # [serde (rename = "degraded")] Degraded , # [serde (rename = "outage")] Outage , } impl From < & GetSystemStatusResponseEnforcersNetworkStatusItemStatus > for GetSystemStatusResponseEnforcersNetworkStatusItemStatus { fn from (value : & GetSystemStatusResponseEnforcersNetworkStatusItemStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetSystemStatusResponseEnforcersNetworkStatusItemStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Operational => write ! (f , "operational") , Self :: Degraded => write ! (f , "degraded") , Self :: Outage => write ! (f , "outage") , } } } impl std :: str :: FromStr for GetSystemStatusResponseEnforcersNetworkStatusItemStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "operational" => Ok (Self :: Operational) , "degraded" => Ok (Self :: Degraded) , "outage" => Ok (Self :: Outage) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetSystemStatusResponseEnforcersNetworkStatusItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetSystemStatusResponseEnforcersNetworkStatusItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetSystemStatusResponseEnforcersNetworkStatusItemStatus { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetSystemStatusResponseEnforcersRpcItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"id\","] # [doc = "    \"operational\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"operational\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetSystemStatusResponseEnforcersRpcItem { pub id : String , pub operational : bool , } impl From < & GetSystemStatusResponseEnforcersRpcItem > for GetSystemStatusResponseEnforcersRpcItem { fn from (value : & GetSystemStatusResponseEnforcersRpcItem) -> Self { value . clone () } } # [doc = "GetTransfersAssertionAdoptersTransferIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"error\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"code\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"details\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetTransfersAssertionAdoptersTransferIdResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub code : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub details : Option < String > , pub error : String , } impl From < & GetTransfersAssertionAdoptersTransferIdResponse > for GetTransfersAssertionAdoptersTransferIdResponse { fn from (value : & GetTransfersAssertionAdoptersTransferIdResponse) -> Self { value . clone () } } # [doc = "GetTransfersProjectsTransferIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopters\","] # [doc = "    \"created_at\","] # [doc = "    \"expires_at\","] # [doc = "    \"initial_owner\","] # [doc = "    \"new_owner\","] # [doc = "    \"project\","] # [doc = "    \"project_id\","] # [doc = "    \"responded_at\","] # [doc = "    \"status\","] # [doc = "    \"transfer_id\","] # [doc = "    \"updated_at\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopters\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"address\","] # [doc = "          \"assertion_adopter_manager\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"address\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"assertion_adopter_manager\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"expires_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"initial_owner\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"new_owner\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"project\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"profile_image_url\","] # [doc = "        \"project_id\","] # [doc = "        \"project_name\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"profile_image_url\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"project_id\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"project_name\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"responded_at\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"transfer_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"updated_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetTransfersProjectsTransferIdResponse { pub assertion_adopters : Vec < GetTransfersProjectsTransferIdResponseAssertionAdoptersItem > , pub created_at : String , pub expires_at : String , pub initial_owner : String , pub new_owner : String , pub project : GetTransfersProjectsTransferIdResponseProject , pub project_id : String , pub responded_at : Option < String > , pub status : String , pub transfer_id : String , pub updated_at : String , } impl From < & GetTransfersProjectsTransferIdResponse > for GetTransfersProjectsTransferIdResponse { fn from (value : & GetTransfersProjectsTransferIdResponse) -> Self { value . clone () } } # [doc = "GetTransfersProjectsTransferIdResponseAssertionAdoptersItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"assertion_adopter_manager\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_adopter_manager\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetTransfersProjectsTransferIdResponseAssertionAdoptersItem { pub address : String , pub assertion_adopter_manager : String , } impl From < & GetTransfersProjectsTransferIdResponseAssertionAdoptersItem > for GetTransfersProjectsTransferIdResponseAssertionAdoptersItem { fn from (value : & GetTransfersProjectsTransferIdResponseAssertionAdoptersItem) -> Self { value . clone () } } # [doc = "GetTransfersProjectsTransferIdResponseProject"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"profile_image_url\","] # [doc = "    \"project_id\","] # [doc = "    \"project_name\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetTransfersProjectsTransferIdResponseProject { pub profile_image_url : Option < String > , pub project_id : String , pub project_name : String , } impl From < & GetTransfersProjectsTransferIdResponseProject > for GetTransfersProjectsTransferIdResponseProject { fn from (value : & GetTransfersProjectsTransferIdResponseProject) -> Self { value . clone () } } # [doc = "GetTransfersResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_transfers\","] # [doc = "    \"project_transfers\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_transfers\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"project_transfers\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetTransfersResponse { pub assertion_adopter_transfers : Vec < String > , pub project_transfers : Vec < String > , } impl From < & GetTransfersResponse > for GetTransfersResponse { fn from (value : & GetTransfersResponse) -> Self { value . clone () } } # [doc = "GetTransfersRole"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"sender\","] # [doc = "    \"receiver\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetTransfersRole { # [serde (rename = "sender")] Sender , # [serde (rename = "receiver")] Receiver , } impl From < & GetTransfersRole > for GetTransfersRole { fn from (value : & GetTransfersRole) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetTransfersRole { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Sender => write ! (f , "sender") , Self :: Receiver => write ! (f , "receiver") , } } } impl std :: str :: FromStr for GetTransfersRole { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "sender" => Ok (Self :: Sender) , "receiver" => Ok (Self :: Receiver) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetTransfersRole { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetTransfersRole { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetTransfersRole { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetWebAuthMeResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"scope\","] # [doc = "    \"terms_accepted\","] # [doc = "    \"terms_accepted_at\","] # [doc = "    \"whitelisted\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"scope\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"web\","] # [doc = "        \"cli\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"terms_accepted\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"terms_accepted_at\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"whitelisted\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetWebAuthMeResponse { pub address : GetWebAuthMeResponseAddress , pub scope : GetWebAuthMeResponseScope , pub terms_accepted : bool , pub terms_accepted_at : Option < String > , pub whitelisted : bool , } impl From < & GetWebAuthMeResponse > for GetWebAuthMeResponse { fn from (value : & GetWebAuthMeResponse) -> Self { value . clone () } } # [doc = "GetWebAuthMeResponseAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetWebAuthMeResponseAddress (String) ; impl :: std :: ops :: Deref for GetWebAuthMeResponseAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetWebAuthMeResponseAddress > for String { fn from (value : GetWebAuthMeResponseAddress) -> Self { value . 0 } } impl From < & GetWebAuthMeResponseAddress > for GetWebAuthMeResponseAddress { fn from (value : & GetWebAuthMeResponseAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetWebAuthMeResponseAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetWebAuthMeResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetWebAuthMeResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetWebAuthMeResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetWebAuthMeResponseAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetWebAuthMeResponseScope"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"web\","] # [doc = "    \"cli\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum GetWebAuthMeResponseScope { # [serde (rename = "web")] Web , # [serde (rename = "cli")] Cli , } impl From < & GetWebAuthMeResponseScope > for GetWebAuthMeResponseScope { fn from (value : & GetWebAuthMeResponseScope) -> Self { value . clone () } } impl :: std :: fmt :: Display for GetWebAuthMeResponseScope { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Web => write ! (f , "web") , Self :: Cli => write ! (f , "cli") , } } } impl std :: str :: FromStr for GetWebAuthMeResponseScope { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "web" => Ok (Self :: Web) , "cli" => Ok (Self :: Cli) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for GetWebAuthMeResponseScope { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for GetWebAuthMeResponseScope { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for GetWebAuthMeResponseScope { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "GetWebAuthNonceResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"nonce\","] # [doc = "    \"ttl\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"nonce\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"ttl\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetWebAuthNonceResponse { pub nonce : String , pub ttl : f64 , } impl From < & GetWebAuthNonceResponse > for GetWebAuthNonceResponse { fn from (value : & GetWebAuthNonceResponse) -> Self { value . clone () } } # [doc = "GetWebVerifiedContractAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct GetWebVerifiedContractAddress (String) ; impl :: std :: ops :: Deref for GetWebVerifiedContractAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < GetWebVerifiedContractAddress > for String { fn from (value : GetWebVerifiedContractAddress) -> Self { value . 0 } } impl From < & GetWebVerifiedContractAddress > for GetWebVerifiedContractAddress { fn from (value : & GetWebVerifiedContractAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for GetWebVerifiedContractAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for GetWebVerifiedContractAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for GetWebVerifiedContractAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for GetWebVerifiedContractAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for GetWebVerifiedContractAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "GetWebVerifiedContractResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"chainId\","] # [doc = "    \"isVerified\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"chainId\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"contractName\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"isVerified\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetWebVerifiedContractResponse { pub address : String , # [serde (rename = "chainId")] pub chain_id : f64 , # [serde (rename = "contractName" , default , skip_serializing_if = "Option::is_none")] pub contract_name : Option < String > , # [serde (rename = "isVerified")] pub is_verified : bool , # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , } impl From < & GetWebVerifiedContractResponse > for GetWebVerifiedContractResponse { fn from (value : & GetWebVerifiedContractResponse) -> Self { value . clone () } } # [doc = "GetWhitelistResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"whitelisted\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"whitelisted\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetWhitelistResponse { pub address : String , pub whitelisted : bool , } impl From < & GetWhitelistResponse > for GetWhitelistResponse { fn from (value : & GetWhitelistResponse) -> Self { value . clone () } } # [doc = "PatchTransfersAssertionAdoptersTransferIdBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"action\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"action\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"accept\","] # [doc = "        \"reject\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PatchTransfersAssertionAdoptersTransferIdBody { pub action : PatchTransfersAssertionAdoptersTransferIdBodyAction , } impl From < & PatchTransfersAssertionAdoptersTransferIdBody > for PatchTransfersAssertionAdoptersTransferIdBody { fn from (value : & PatchTransfersAssertionAdoptersTransferIdBody) -> Self { value . clone () } } # [doc = "PatchTransfersAssertionAdoptersTransferIdBodyAction"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"accept\","] # [doc = "    \"reject\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PatchTransfersAssertionAdoptersTransferIdBodyAction { # [serde (rename = "accept")] Accept , # [serde (rename = "reject")] Reject , } impl From < & PatchTransfersAssertionAdoptersTransferIdBodyAction > for PatchTransfersAssertionAdoptersTransferIdBodyAction { fn from (value : & PatchTransfersAssertionAdoptersTransferIdBodyAction) -> Self { value . clone () } } impl :: std :: fmt :: Display for PatchTransfersAssertionAdoptersTransferIdBodyAction { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Accept => write ! (f , "accept") , Self :: Reject => write ! (f , "reject") , } } } impl std :: str :: FromStr for PatchTransfersAssertionAdoptersTransferIdBodyAction { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "accept" => Ok (Self :: Accept) , "reject" => Ok (Self :: Reject) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PatchTransfersAssertionAdoptersTransferIdBodyAction { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PatchTransfersAssertionAdoptersTransferIdBodyAction { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PatchTransfersAssertionAdoptersTransferIdBodyAction { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "PatchTransfersAssertionAdoptersTransferIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PatchTransfersAssertionAdoptersTransferIdResponse { pub message : String , } impl From < & PatchTransfersAssertionAdoptersTransferIdResponse > for PatchTransfersAssertionAdoptersTransferIdResponse { fn from (value : & PatchTransfersAssertionAdoptersTransferIdResponse) -> Self { value . clone () } } # [doc = "PatchTransfersProjectsTransferIdBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"action\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"action\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"accept\","] # [doc = "        \"reject\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PatchTransfersProjectsTransferIdBody { pub action : PatchTransfersProjectsTransferIdBodyAction , } impl From < & PatchTransfersProjectsTransferIdBody > for PatchTransfersProjectsTransferIdBody { fn from (value : & PatchTransfersProjectsTransferIdBody) -> Self { value . clone () } } # [doc = "PatchTransfersProjectsTransferIdBodyAction"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"accept\","] # [doc = "    \"reject\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PatchTransfersProjectsTransferIdBodyAction { # [serde (rename = "accept")] Accept , # [serde (rename = "reject")] Reject , } impl From < & PatchTransfersProjectsTransferIdBodyAction > for PatchTransfersProjectsTransferIdBodyAction { fn from (value : & PatchTransfersProjectsTransferIdBodyAction) -> Self { value . clone () } } impl :: std :: fmt :: Display for PatchTransfersProjectsTransferIdBodyAction { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Accept => write ! (f , "accept") , Self :: Reject => write ! (f , "reject") , } } } impl std :: str :: FromStr for PatchTransfersProjectsTransferIdBodyAction { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "accept" => Ok (Self :: Accept) , "reject" => Ok (Self :: Reject) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PatchTransfersProjectsTransferIdBodyAction { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PatchTransfersProjectsTransferIdBodyAction { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PatchTransfersProjectsTransferIdBodyAction { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "PatchTransfersProjectsTransferIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PatchTransfersProjectsTransferIdResponse { pub message : String , } impl From < & PatchTransfersProjectsTransferIdResponse > for PatchTransfersProjectsTransferIdResponse { fn from (value : & PatchTransfersProjectsTransferIdResponse) -> Self { value . clone () } } # [doc = "PostAssertionAdoptersAssignProjectBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_id\","] # [doc = "    \"project_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostAssertionAdoptersAssignProjectBody { pub assertion_adopter_id : String , pub project_id : uuid :: Uuid , } impl From < & PostAssertionAdoptersAssignProjectBody > for PostAssertionAdoptersAssignProjectBody { fn from (value : & PostAssertionAdoptersAssignProjectBody) -> Self { value . clone () } } # [doc = "PostAssertionAdoptersAssignProjectResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostAssertionAdoptersAssignProjectResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , pub success : bool , } impl From < & PostAssertionAdoptersAssignProjectResponse > for PostAssertionAdoptersAssignProjectResponse { fn from (value : & PostAssertionAdoptersAssignProjectResponse) -> Self { value . clone () } } # [doc = "PostAssertionsConfirmPromotionBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"chainId\","] # [doc = "    \"environment\","] # [doc = "    \"promotions\","] # [doc = "    \"tx_hash\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chainId\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"promotions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopter_id\","] # [doc = "          \"assertion_id\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopter_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"tx_hash\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostAssertionsConfirmPromotionBody { # [serde (rename = "chainId")] pub chain_id : std :: num :: NonZeroU64 , pub environment : PostAssertionsConfirmPromotionBodyEnvironment , pub promotions : Vec < PostAssertionsConfirmPromotionBodyPromotionsItem > , pub tx_hash : PostAssertionsConfirmPromotionBodyTxHash , } impl From < & PostAssertionsConfirmPromotionBody > for PostAssertionsConfirmPromotionBody { fn from (value : & PostAssertionsConfirmPromotionBody) -> Self { value . clone () } } # [doc = "PostAssertionsConfirmPromotionBodyEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PostAssertionsConfirmPromotionBodyEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & PostAssertionsConfirmPromotionBodyEnvironment > for PostAssertionsConfirmPromotionBodyEnvironment { fn from (value : & PostAssertionsConfirmPromotionBodyEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for PostAssertionsConfirmPromotionBodyEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for PostAssertionsConfirmPromotionBodyEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PostAssertionsConfirmPromotionBodyEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostAssertionsConfirmPromotionBodyEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostAssertionsConfirmPromotionBodyEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "PostAssertionsConfirmPromotionBodyPromotionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_id\","] # [doc = "    \"assertion_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostAssertionsConfirmPromotionBodyPromotionsItem { pub assertion_adopter_id : String , pub assertion_id : PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId , } impl From < & PostAssertionsConfirmPromotionBodyPromotionsItem > for PostAssertionsConfirmPromotionBodyPromotionsItem { fn from (value : & PostAssertionsConfirmPromotionBodyPromotionsItem) -> Self { value . clone () } } # [doc = "PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId (String) ; impl :: std :: ops :: Deref for PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId > for String { fn from (value : PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId) -> Self { value . 0 } } impl From < & PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId > for PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId { fn from (value : & PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostAssertionsConfirmPromotionBodyPromotionsItemAssertionId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostAssertionsConfirmPromotionBodyTxHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostAssertionsConfirmPromotionBodyTxHash (String) ; impl :: std :: ops :: Deref for PostAssertionsConfirmPromotionBodyTxHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostAssertionsConfirmPromotionBodyTxHash > for String { fn from (value : PostAssertionsConfirmPromotionBodyTxHash) -> Self { value . 0 } } impl From < & PostAssertionsConfirmPromotionBodyTxHash > for PostAssertionsConfirmPromotionBodyTxHash { fn from (value : & PostAssertionsConfirmPromotionBodyTxHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostAssertionsConfirmPromotionBodyTxHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostAssertionsConfirmPromotionBodyTxHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostAssertionsConfirmPromotionBodyTxHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostAssertionsConfirmPromotionBodyTxHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostAssertionsConfirmPromotionBodyTxHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostAssertionsConfirmPromotionResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"failed\","] # [doc = "    \"promoted\","] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"failed\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopter_id\","] # [doc = "          \"assertion_id\","] # [doc = "          \"error\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopter_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "          },"] # [doc = "          \"error\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"promoted\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopter_id\","] # [doc = "          \"assertion_id\","] # [doc = "          \"cleanup_job_id\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopter_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "          },"] # [doc = "          \"cleanup_job_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"format\": \"uuid\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostAssertionsConfirmPromotionResponse { pub failed : Vec < PostAssertionsConfirmPromotionResponseFailedItem > , pub promoted : Vec < PostAssertionsConfirmPromotionResponsePromotedItem > , pub success : bool , } impl From < & PostAssertionsConfirmPromotionResponse > for PostAssertionsConfirmPromotionResponse { fn from (value : & PostAssertionsConfirmPromotionResponse) -> Self { value . clone () } } # [doc = "PostAssertionsConfirmPromotionResponseFailedItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_id\","] # [doc = "    \"assertion_id\","] # [doc = "    \"error\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostAssertionsConfirmPromotionResponseFailedItem { pub assertion_adopter_id : String , pub assertion_id : PostAssertionsConfirmPromotionResponseFailedItemAssertionId , pub error : String , } impl From < & PostAssertionsConfirmPromotionResponseFailedItem > for PostAssertionsConfirmPromotionResponseFailedItem { fn from (value : & PostAssertionsConfirmPromotionResponseFailedItem) -> Self { value . clone () } } # [doc = "PostAssertionsConfirmPromotionResponseFailedItemAssertionId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostAssertionsConfirmPromotionResponseFailedItemAssertionId (String) ; impl :: std :: ops :: Deref for PostAssertionsConfirmPromotionResponseFailedItemAssertionId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostAssertionsConfirmPromotionResponseFailedItemAssertionId > for String { fn from (value : PostAssertionsConfirmPromotionResponseFailedItemAssertionId) -> Self { value . 0 } } impl From < & PostAssertionsConfirmPromotionResponseFailedItemAssertionId > for PostAssertionsConfirmPromotionResponseFailedItemAssertionId { fn from (value : & PostAssertionsConfirmPromotionResponseFailedItemAssertionId) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostAssertionsConfirmPromotionResponseFailedItemAssertionId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostAssertionsConfirmPromotionResponseFailedItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostAssertionsConfirmPromotionResponseFailedItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostAssertionsConfirmPromotionResponseFailedItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostAssertionsConfirmPromotionResponseFailedItemAssertionId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostAssertionsConfirmPromotionResponsePromotedItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_id\","] # [doc = "    \"assertion_id\","] # [doc = "    \"cleanup_job_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    },"] # [doc = "    \"cleanup_job_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostAssertionsConfirmPromotionResponsePromotedItem { pub assertion_adopter_id : String , pub assertion_id : PostAssertionsConfirmPromotionResponsePromotedItemAssertionId , pub cleanup_job_id : uuid :: Uuid , } impl From < & PostAssertionsConfirmPromotionResponsePromotedItem > for PostAssertionsConfirmPromotionResponsePromotedItem { fn from (value : & PostAssertionsConfirmPromotionResponsePromotedItem) -> Self { value . clone () } } # [doc = "PostAssertionsConfirmPromotionResponsePromotedItemAssertionId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostAssertionsConfirmPromotionResponsePromotedItemAssertionId (String) ; impl :: std :: ops :: Deref for PostAssertionsConfirmPromotionResponsePromotedItemAssertionId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostAssertionsConfirmPromotionResponsePromotedItemAssertionId > for String { fn from (value : PostAssertionsConfirmPromotionResponsePromotedItemAssertionId) -> Self { value . 0 } } impl From < & PostAssertionsConfirmPromotionResponsePromotedItemAssertionId > for PostAssertionsConfirmPromotionResponsePromotedItemAssertionId { fn from (value : & PostAssertionsConfirmPromotionResponsePromotedItemAssertionId) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostAssertionsConfirmPromotionResponsePromotedItemAssertionId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostAssertionsConfirmPromotionResponsePromotedItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostAssertionsConfirmPromotionResponsePromotedItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostAssertionsConfirmPromotionResponsePromotedItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostAssertionsConfirmPromotionResponsePromotedItemAssertionId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostCalldataBatchPromoteBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"chainId\","] # [doc = "    \"promotions\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"adminVerifier\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"chainId\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"data\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    },"] # [doc = "    \"promotions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopter_id\","] # [doc = "          \"assertion_id\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopter_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCalldataBatchPromoteBody { # [serde (rename = "adminVerifier" , default , skip_serializing_if = "Option::is_none")] pub admin_verifier : Option < PostCalldataBatchPromoteBodyAdminVerifier > , # [serde (rename = "chainId")] pub chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] pub data : Option < PostCalldataBatchPromoteBodyData > , pub promotions : Vec < PostCalldataBatchPromoteBodyPromotionsItem > , } impl From < & PostCalldataBatchPromoteBody > for PostCalldataBatchPromoteBody { fn from (value : & PostCalldataBatchPromoteBody) -> Self { value . clone () } } # [doc = "PostCalldataBatchPromoteBodyAdminVerifier"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostCalldataBatchPromoteBodyAdminVerifier (String) ; impl :: std :: ops :: Deref for PostCalldataBatchPromoteBodyAdminVerifier { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostCalldataBatchPromoteBodyAdminVerifier > for String { fn from (value : PostCalldataBatchPromoteBodyAdminVerifier) -> Self { value . 0 } } impl From < & PostCalldataBatchPromoteBodyAdminVerifier > for PostCalldataBatchPromoteBodyAdminVerifier { fn from (value : & PostCalldataBatchPromoteBodyAdminVerifier) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostCalldataBatchPromoteBodyAdminVerifier { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostCalldataBatchPromoteBodyAdminVerifier { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostCalldataBatchPromoteBodyAdminVerifier { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostCalldataBatchPromoteBodyAdminVerifier { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostCalldataBatchPromoteBodyAdminVerifier { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostCalldataBatchPromoteBodyData"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostCalldataBatchPromoteBodyData (String) ; impl :: std :: ops :: Deref for PostCalldataBatchPromoteBodyData { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostCalldataBatchPromoteBodyData > for String { fn from (value : PostCalldataBatchPromoteBodyData) -> Self { value . 0 } } impl From < & PostCalldataBatchPromoteBodyData > for PostCalldataBatchPromoteBodyData { fn from (value : & PostCalldataBatchPromoteBodyData) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostCalldataBatchPromoteBodyData { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostCalldataBatchPromoteBodyData { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostCalldataBatchPromoteBodyData { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostCalldataBatchPromoteBodyData { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostCalldataBatchPromoteBodyData { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostCalldataBatchPromoteBodyPromotionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_id\","] # [doc = "    \"assertion_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCalldataBatchPromoteBodyPromotionsItem { pub assertion_adopter_id : String , pub assertion_id : PostCalldataBatchPromoteBodyPromotionsItemAssertionId , } impl From < & PostCalldataBatchPromoteBodyPromotionsItem > for PostCalldataBatchPromoteBodyPromotionsItem { fn from (value : & PostCalldataBatchPromoteBodyPromotionsItem) -> Self { value . clone () } } # [doc = "PostCalldataBatchPromoteBodyPromotionsItemAssertionId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostCalldataBatchPromoteBodyPromotionsItemAssertionId (String) ; impl :: std :: ops :: Deref for PostCalldataBatchPromoteBodyPromotionsItemAssertionId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostCalldataBatchPromoteBodyPromotionsItemAssertionId > for String { fn from (value : PostCalldataBatchPromoteBodyPromotionsItemAssertionId) -> Self { value . 0 } } impl From < & PostCalldataBatchPromoteBodyPromotionsItemAssertionId > for PostCalldataBatchPromoteBodyPromotionsItemAssertionId { fn from (value : & PostCalldataBatchPromoteBodyPromotionsItemAssertionId) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostCalldataBatchPromoteBodyPromotionsItemAssertionId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostCalldataBatchPromoteBodyPromotionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostCalldataBatchPromoteBodyPromotionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostCalldataBatchPromoteBodyPromotionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostCalldataBatchPromoteBodyPromotionsItemAssertionId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostCalldataBatchPromoteResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"adopters_to_register\","] # [doc = "    \"calldata\","] # [doc = "    \"promotions\","] # [doc = "    \"skipped\","] # [doc = "    \"total_calldata\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"adopters_to_register\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"calldata\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"promotions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopter_id\","] # [doc = "          \"assertion_id\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopter_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"skipped\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopter_id\","] # [doc = "          \"assertion_id\","] # [doc = "          \"reason\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopter_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"reason\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"total_calldata\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCalldataBatchPromoteResponse { pub adopters_to_register : Vec < String > , pub calldata : Vec < String > , pub promotions : Vec < PostCalldataBatchPromoteResponsePromotionsItem > , pub skipped : Vec < PostCalldataBatchPromoteResponseSkippedItem > , pub total_calldata : f64 , } impl From < & PostCalldataBatchPromoteResponse > for PostCalldataBatchPromoteResponse { fn from (value : & PostCalldataBatchPromoteResponse) -> Self { value . clone () } } # [doc = "PostCalldataBatchPromoteResponsePromotionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_id\","] # [doc = "    \"assertion_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCalldataBatchPromoteResponsePromotionsItem { pub assertion_adopter_id : String , pub assertion_id : String , } impl From < & PostCalldataBatchPromoteResponsePromotionsItem > for PostCalldataBatchPromoteResponsePromotionsItem { fn from (value : & PostCalldataBatchPromoteResponsePromotionsItem) -> Self { value . clone () } } # [doc = "PostCalldataBatchPromoteResponseSkippedItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_id\","] # [doc = "    \"assertion_id\","] # [doc = "    \"reason\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"reason\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCalldataBatchPromoteResponseSkippedItem { pub assertion_adopter_id : String , pub assertion_id : String , pub reason : String , } impl From < & PostCalldataBatchPromoteResponseSkippedItem > for PostCalldataBatchPromoteResponseSkippedItem { fn from (value : & PostCalldataBatchPromoteResponseSkippedItem) -> Self { value . clone () } } # [doc = "PostCalldataBatchRegisterBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertions\","] # [doc = "    \"chainId\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"adminVerifier\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"assertions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopters\","] # [doc = "          \"assertion_id\","] # [doc = "          \"assertion_metadata\","] # [doc = "          \"assertion_proof\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopters\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^\\\\d+_0x[a-fA-F0-9]{40}$\""] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "          },"] # [doc = "          \"assertion_metadata\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"assertion_proof\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"chainId\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"data\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"default\": \"production\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCalldataBatchRegisterBody { # [serde (rename = "adminVerifier" , default , skip_serializing_if = "Option::is_none")] pub admin_verifier : Option < PostCalldataBatchRegisterBodyAdminVerifier > , pub assertions : Vec < PostCalldataBatchRegisterBodyAssertionsItem > , # [serde (rename = "chainId")] pub chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] pub data : Option < PostCalldataBatchRegisterBodyData > , # [serde (default = "defaults::post_calldata_batch_register_body_environment")] pub environment : PostCalldataBatchRegisterBodyEnvironment , } impl From < & PostCalldataBatchRegisterBody > for PostCalldataBatchRegisterBody { fn from (value : & PostCalldataBatchRegisterBody) -> Self { value . clone () } } # [doc = "PostCalldataBatchRegisterBodyAdminVerifier"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostCalldataBatchRegisterBodyAdminVerifier (String) ; impl :: std :: ops :: Deref for PostCalldataBatchRegisterBodyAdminVerifier { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostCalldataBatchRegisterBodyAdminVerifier > for String { fn from (value : PostCalldataBatchRegisterBodyAdminVerifier) -> Self { value . 0 } } impl From < & PostCalldataBatchRegisterBodyAdminVerifier > for PostCalldataBatchRegisterBodyAdminVerifier { fn from (value : & PostCalldataBatchRegisterBodyAdminVerifier) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostCalldataBatchRegisterBodyAdminVerifier { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostCalldataBatchRegisterBodyAdminVerifier { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostCalldataBatchRegisterBodyAdminVerifier { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostCalldataBatchRegisterBodyAdminVerifier { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostCalldataBatchRegisterBodyAdminVerifier { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostCalldataBatchRegisterBodyAssertionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopters\","] # [doc = "    \"assertion_id\","] # [doc = "    \"assertion_metadata\","] # [doc = "    \"assertion_proof\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopters\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^\\\\d+_0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    },"] # [doc = "    \"assertion_metadata\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"assertion_proof\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCalldataBatchRegisterBodyAssertionsItem { pub assertion_adopters : Vec < PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem > , pub assertion_id : PostCalldataBatchRegisterBodyAssertionsItemAssertionId , pub assertion_metadata : String , pub assertion_proof : String , } impl From < & PostCalldataBatchRegisterBodyAssertionsItem > for PostCalldataBatchRegisterBodyAssertionsItem { fn from (value : & PostCalldataBatchRegisterBodyAssertionsItem) -> Self { value . clone () } } # [doc = "PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^\\\\d+_0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem (String) ; impl :: std :: ops :: Deref for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem > for String { fn from (value : PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem) -> Self { value . 0 } } impl From < & PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem > for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem { fn from (value : & PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^\\d+_0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^\\d+_0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostCalldataBatchRegisterBodyAssertionsItemAssertionId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostCalldataBatchRegisterBodyAssertionsItemAssertionId (String) ; impl :: std :: ops :: Deref for PostCalldataBatchRegisterBodyAssertionsItemAssertionId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostCalldataBatchRegisterBodyAssertionsItemAssertionId > for String { fn from (value : PostCalldataBatchRegisterBodyAssertionsItemAssertionId) -> Self { value . 0 } } impl From < & PostCalldataBatchRegisterBodyAssertionsItemAssertionId > for PostCalldataBatchRegisterBodyAssertionsItemAssertionId { fn from (value : & PostCalldataBatchRegisterBodyAssertionsItemAssertionId) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostCalldataBatchRegisterBodyAssertionsItemAssertionId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostCalldataBatchRegisterBodyAssertionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostCalldataBatchRegisterBodyAssertionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostCalldataBatchRegisterBodyAssertionsItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostCalldataBatchRegisterBodyAssertionsItemAssertionId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostCalldataBatchRegisterBodyData"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostCalldataBatchRegisterBodyData (String) ; impl :: std :: ops :: Deref for PostCalldataBatchRegisterBodyData { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostCalldataBatchRegisterBodyData > for String { fn from (value : PostCalldataBatchRegisterBodyData) -> Self { value . 0 } } impl From < & PostCalldataBatchRegisterBodyData > for PostCalldataBatchRegisterBodyData { fn from (value : & PostCalldataBatchRegisterBodyData) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostCalldataBatchRegisterBodyData { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostCalldataBatchRegisterBodyData { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostCalldataBatchRegisterBodyData { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostCalldataBatchRegisterBodyData { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostCalldataBatchRegisterBodyData { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostCalldataBatchRegisterBodyEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"production\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PostCalldataBatchRegisterBodyEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & PostCalldataBatchRegisterBodyEnvironment > for PostCalldataBatchRegisterBodyEnvironment { fn from (value : & PostCalldataBatchRegisterBodyEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for PostCalldataBatchRegisterBodyEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for PostCalldataBatchRegisterBodyEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PostCalldataBatchRegisterBodyEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostCalldataBatchRegisterBodyEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostCalldataBatchRegisterBodyEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl Default for PostCalldataBatchRegisterBodyEnvironment { fn default () -> Self { PostCalldataBatchRegisterBodyEnvironment :: Production } } # [doc = "PostCalldataBatchRegisterResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"calldata\","] # [doc = "    \"registered_adopters\","] # [doc = "    \"registered_assertions\","] # [doc = "    \"total_calldata\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"calldata\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"registered_adopters\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"registered_assertions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"total_calldata\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCalldataBatchRegisterResponse { pub calldata : Vec < String > , pub registered_adopters : Vec < String > , pub registered_assertions : Vec < String > , pub total_calldata : f64 , } impl From < & PostCalldataBatchRegisterResponse > for PostCalldataBatchRegisterResponse { fn from (value : & PostCalldataBatchRegisterResponse) -> Self { value . clone () } } # [doc = "PostCliAuthRefreshBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"refresh_token\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"refresh_token\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCliAuthRefreshBody { pub refresh_token : String , } impl From < & PostCliAuthRefreshBody > for PostCliAuthRefreshBody { fn from (value : & PostCliAuthRefreshBody) -> Self { value . clone () } } # [doc = "PostCliAuthRefreshResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"token\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"token\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCliAuthRefreshResponse { pub token : String , } impl From < & PostCliAuthRefreshResponse > for PostCliAuthRefreshResponse { fn from (value : & PostCliAuthRefreshResponse) -> Self { value . clone () } } # [doc = "PostCliAuthVerifyBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"code\","] # [doc = "    \"sessionId\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"code\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 6,"] # [doc = "      \"minLength\": 6"] # [doc = "    },"] # [doc = "    \"sessionId\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCliAuthVerifyBody { pub code : PostCliAuthVerifyBodyCode , # [serde (rename = "sessionId")] pub session_id : uuid :: Uuid , } impl From < & PostCliAuthVerifyBody > for PostCliAuthVerifyBody { fn from (value : & PostCliAuthVerifyBody) -> Self { value . clone () } } # [doc = "PostCliAuthVerifyBodyCode"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 6,"] # [doc = "  \"minLength\": 6"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostCliAuthVerifyBodyCode (String) ; impl :: std :: ops :: Deref for PostCliAuthVerifyBodyCode { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostCliAuthVerifyBodyCode > for String { fn from (value : PostCliAuthVerifyBodyCode) -> Self { value . 0 } } impl From < & PostCliAuthVerifyBodyCode > for PostCliAuthVerifyBodyCode { fn from (value : & PostCliAuthVerifyBodyCode) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostCliAuthVerifyBodyCode { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 6usize { return Err ("longer than 6 characters" . into ()) ; } if value . len () < 6usize { return Err ("shorter than 6 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostCliAuthVerifyBodyCode { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostCliAuthVerifyBodyCode { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostCliAuthVerifyBodyCode { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostCliAuthVerifyBodyCode { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostCliAuthVerifyResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostCliAuthVerifyResponse { pub address : PostCliAuthVerifyResponseAddress , pub success : bool , } impl From < & PostCliAuthVerifyResponse > for PostCliAuthVerifyResponse { fn from (value : & PostCliAuthVerifyResponse) -> Self { value . clone () } } # [doc = "PostCliAuthVerifyResponseAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostCliAuthVerifyResponseAddress (String) ; impl :: std :: ops :: Deref for PostCliAuthVerifyResponseAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostCliAuthVerifyResponseAddress > for String { fn from (value : PostCliAuthVerifyResponseAddress) -> Self { value . 0 } } impl From < & PostCliAuthVerifyResponseAddress > for PostCliAuthVerifyResponseAddress { fn from (value : & PostCliAuthVerifyResponseAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostCliAuthVerifyResponseAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostCliAuthVerifyResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostCliAuthVerifyResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostCliAuthVerifyResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostCliAuthVerifyResponseAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"failures\","] # [doc = "    \"incident_timestamp\","] # [doc = "    \"transaction_data\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"block_env\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"basefee\","] # [doc = "        \"beneficiary\","] # [doc = "        \"difficulty\","] # [doc = "        \"gas_limit\","] # [doc = "        \"number\","] # [doc = "        \"timestamp\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"basefee\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"beneficiary\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"blob_excess_gas_and_price\": {"] # [doc = "          \"type\": ["] # [doc = "            \"object\","] # [doc = "            \"null\""] # [doc = "          ],"] # [doc = "          \"required\": ["] # [doc = "            \"blob_gasprice\","] # [doc = "            \"excess_blob_gas\""] # [doc = "          ],"] # [doc = "          \"properties\": {"] # [doc = "            \"blob_gasprice\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"excess_blob_gas\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"difficulty\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"number\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"prevrandao\": {"] # [doc = "          \"type\": ["] # [doc = "            \"string\","] # [doc = "            \"null\""] # [doc = "          ],"] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"timestamp\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"block_number\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"enforcer_version\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"failures\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopter_address\","] # [doc = "          \"assertion_id\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopter_address\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "          },"] # [doc = "          \"assertion_fn_selector\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{8}$\""] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "          },"] # [doc = "          \"revert_reason\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      },"] # [doc = "      \"minItems\": 1"] # [doc = "    },"] # [doc = "    \"incident_timestamp\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"previous_block_number\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"previous_transactions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"oneOf\": ["] # [doc = "          {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"chain_id\","] # [doc = "              \"from_address\","] # [doc = "              \"gas_limit\","] # [doc = "              \"gas_price\","] # [doc = "              \"nonce\","] # [doc = "              \"to_address\","] # [doc = "              \"transaction_hash\","] # [doc = "              \"type\","] # [doc = "              \"value\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"chain_id\": {"] # [doc = "                \"type\": \"integer\","] # [doc = "                \"exclusiveMinimum\": 0.0"] # [doc = "              },"] # [doc = "              \"data\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"from_address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"gas_limit\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"gas_price\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"nonce\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"to_address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "              },"] # [doc = "              \"transaction_hash\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "              },"] # [doc = "              \"type\": {"] # [doc = "                \"type\": \"number\","] # [doc = "                \"enum\": ["] # [doc = "                  0.0"] # [doc = "                ]"] # [doc = "              },"] # [doc = "              \"value\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          },"] # [doc = "          {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"chain_id\","] # [doc = "              \"from_address\","] # [doc = "              \"gas_limit\","] # [doc = "              \"gas_price\","] # [doc = "              \"nonce\","] # [doc = "              \"to_address\","] # [doc = "              \"transaction_hash\","] # [doc = "              \"type\","] # [doc = "              \"value\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"access_list\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"object\","] # [doc = "                  \"required\": ["] # [doc = "                    \"address\","] # [doc = "                    \"storage_keys\""] # [doc = "                  ],"] # [doc = "                  \"properties\": {"] # [doc = "                    \"address\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                    },"] # [doc = "                    \"storage_keys\": {"] # [doc = "                      \"type\": \"array\","] # [doc = "                      \"items\": {"] # [doc = "                        \"type\": \"string\","] # [doc = "                        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                      }"] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                }"] # [doc = "              },"] # [doc = "              \"chain_id\": {"] # [doc = "                \"type\": \"integer\","] # [doc = "                \"exclusiveMinimum\": 0.0"] # [doc = "              },"] # [doc = "              \"data\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"from_address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"gas_limit\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"gas_price\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"nonce\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"to_address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "              },"] # [doc = "              \"transaction_hash\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "              },"] # [doc = "              \"type\": {"] # [doc = "                \"type\": \"number\","] # [doc = "                \"enum\": ["] # [doc = "                  1.0"] # [doc = "                ]"] # [doc = "              },"] # [doc = "              \"value\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          },"] # [doc = "          {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"chain_id\","] # [doc = "              \"from_address\","] # [doc = "              \"gas_limit\","] # [doc = "              \"max_fee_per_gas\","] # [doc = "              \"max_priority_fee_per_gas\","] # [doc = "              \"nonce\","] # [doc = "              \"to_address\","] # [doc = "              \"transaction_hash\","] # [doc = "              \"type\","] # [doc = "              \"value\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"access_list\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"object\","] # [doc = "                  \"required\": ["] # [doc = "                    \"address\","] # [doc = "                    \"storage_keys\""] # [doc = "                  ],"] # [doc = "                  \"properties\": {"] # [doc = "                    \"address\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                    },"] # [doc = "                    \"storage_keys\": {"] # [doc = "                      \"type\": \"array\","] # [doc = "                      \"items\": {"] # [doc = "                        \"type\": \"string\","] # [doc = "                        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                      }"] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                }"] # [doc = "              },"] # [doc = "              \"chain_id\": {"] # [doc = "                \"type\": \"integer\","] # [doc = "                \"exclusiveMinimum\": 0.0"] # [doc = "              },"] # [doc = "              \"data\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"from_address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"gas_limit\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"max_fee_per_gas\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"max_priority_fee_per_gas\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"nonce\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"to_address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "              },"] # [doc = "              \"transaction_hash\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "              },"] # [doc = "              \"type\": {"] # [doc = "                \"type\": \"number\","] # [doc = "                \"enum\": ["] # [doc = "                  2.0"] # [doc = "                ]"] # [doc = "              },"] # [doc = "              \"value\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          },"] # [doc = "          {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"blob_versioned_hashes\","] # [doc = "              \"chain_id\","] # [doc = "              \"from_address\","] # [doc = "              \"gas_limit\","] # [doc = "              \"max_fee_per_blob_gas\","] # [doc = "              \"max_fee_per_gas\","] # [doc = "              \"max_priority_fee_per_gas\","] # [doc = "              \"nonce\","] # [doc = "              \"to_address\","] # [doc = "              \"transaction_hash\","] # [doc = "              \"type\","] # [doc = "              \"value\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"access_list\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"object\","] # [doc = "                  \"required\": ["] # [doc = "                    \"address\","] # [doc = "                    \"storage_keys\""] # [doc = "                  ],"] # [doc = "                  \"properties\": {"] # [doc = "                    \"address\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                    },"] # [doc = "                    \"storage_keys\": {"] # [doc = "                      \"type\": \"array\","] # [doc = "                      \"items\": {"] # [doc = "                        \"type\": \"string\","] # [doc = "                        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                      }"] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                }"] # [doc = "              },"] # [doc = "              \"blob_versioned_hashes\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                }"] # [doc = "              },"] # [doc = "              \"chain_id\": {"] # [doc = "                \"type\": \"integer\","] # [doc = "                \"exclusiveMinimum\": 0.0"] # [doc = "              },"] # [doc = "              \"data\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"from_address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"gas_limit\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"max_fee_per_blob_gas\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"max_fee_per_gas\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"max_priority_fee_per_gas\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"nonce\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"to_address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "              },"] # [doc = "              \"transaction_hash\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "              },"] # [doc = "              \"type\": {"] # [doc = "                \"type\": \"number\","] # [doc = "                \"enum\": ["] # [doc = "                  3.0"] # [doc = "                ]"] # [doc = "              },"] # [doc = "              \"value\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          },"] # [doc = "          {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"authorization_list\","] # [doc = "              \"chain_id\","] # [doc = "              \"from_address\","] # [doc = "              \"gas_limit\","] # [doc = "              \"max_fee_per_gas\","] # [doc = "              \"max_priority_fee_per_gas\","] # [doc = "              \"nonce\","] # [doc = "              \"to_address\","] # [doc = "              \"transaction_hash\","] # [doc = "              \"type\","] # [doc = "              \"value\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"access_list\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"object\","] # [doc = "                  \"required\": ["] # [doc = "                    \"address\","] # [doc = "                    \"storage_keys\""] # [doc = "                  ],"] # [doc = "                  \"properties\": {"] # [doc = "                    \"address\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                    },"] # [doc = "                    \"storage_keys\": {"] # [doc = "                      \"type\": \"array\","] # [doc = "                      \"items\": {"] # [doc = "                        \"type\": \"string\","] # [doc = "                        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                      }"] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                }"] # [doc = "              },"] # [doc = "              \"authorization_list\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"object\","] # [doc = "                  \"required\": ["] # [doc = "                    \"address\","] # [doc = "                    \"chain_id\","] # [doc = "                    \"nonce\","] # [doc = "                    \"r\","] # [doc = "                    \"s\","] # [doc = "                    \"v\""] # [doc = "                  ],"] # [doc = "                  \"properties\": {"] # [doc = "                    \"address\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                    },"] # [doc = "                    \"chain_id\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                    },"] # [doc = "                    \"nonce\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                    },"] # [doc = "                    \"r\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                    },"] # [doc = "                    \"s\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                    },"] # [doc = "                    \"v\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                }"] # [doc = "              },"] # [doc = "              \"chain_id\": {"] # [doc = "                \"type\": \"integer\","] # [doc = "                \"exclusiveMinimum\": 0.0"] # [doc = "              },"] # [doc = "              \"data\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"from_address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"gas_limit\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"max_fee_per_gas\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"max_priority_fee_per_gas\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"nonce\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"to_address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "              },"] # [doc = "              \"transaction_hash\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "              },"] # [doc = "              \"type\": {"] # [doc = "                \"type\": \"number\","] # [doc = "                \"enum\": ["] # [doc = "                  4.0"] # [doc = "                ]"] # [doc = "              },"] # [doc = "              \"value\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        ]"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"transaction_data\": {"] # [doc = "      \"oneOf\": ["] # [doc = "        {"] # [doc = "          \"type\": \"object\","] # [doc = "          \"required\": ["] # [doc = "            \"chain_id\","] # [doc = "            \"from_address\","] # [doc = "            \"gas_limit\","] # [doc = "            \"gas_price\","] # [doc = "            \"nonce\","] # [doc = "            \"to_address\","] # [doc = "            \"transaction_hash\","] # [doc = "            \"type\","] # [doc = "            \"value\""] # [doc = "          ],"] # [doc = "          \"properties\": {"] # [doc = "            \"chain_id\": {"] # [doc = "              \"type\": \"integer\","] # [doc = "              \"exclusiveMinimum\": 0.0"] # [doc = "            },"] # [doc = "            \"data\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "            },"] # [doc = "            \"from_address\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "            },"] # [doc = "            \"gas_limit\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"gas_price\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"nonce\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"to_address\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "            },"] # [doc = "            \"transaction_hash\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "            },"] # [doc = "            \"type\": {"] # [doc = "              \"type\": \"number\","] # [doc = "              \"enum\": ["] # [doc = "                0.0"] # [doc = "              ]"] # [doc = "            },"] # [doc = "            \"value\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"object\","] # [doc = "          \"required\": ["] # [doc = "            \"chain_id\","] # [doc = "            \"from_address\","] # [doc = "            \"gas_limit\","] # [doc = "            \"gas_price\","] # [doc = "            \"nonce\","] # [doc = "            \"to_address\","] # [doc = "            \"transaction_hash\","] # [doc = "            \"type\","] # [doc = "            \"value\""] # [doc = "          ],"] # [doc = "          \"properties\": {"] # [doc = "            \"access_list\": {"] # [doc = "              \"type\": \"array\","] # [doc = "              \"items\": {"] # [doc = "                \"type\": \"object\","] # [doc = "                \"required\": ["] # [doc = "                  \"address\","] # [doc = "                  \"storage_keys\""] # [doc = "                ],"] # [doc = "                \"properties\": {"] # [doc = "                  \"address\": {"] # [doc = "                    \"type\": \"string\","] # [doc = "                    \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                  },"] # [doc = "                  \"storage_keys\": {"] # [doc = "                    \"type\": \"array\","] # [doc = "                    \"items\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                }"] # [doc = "              }"] # [doc = "            },"] # [doc = "            \"chain_id\": {"] # [doc = "              \"type\": \"integer\","] # [doc = "              \"exclusiveMinimum\": 0.0"] # [doc = "            },"] # [doc = "            \"data\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "            },"] # [doc = "            \"from_address\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "            },"] # [doc = "            \"gas_limit\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"gas_price\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"nonce\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"to_address\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "            },"] # [doc = "            \"transaction_hash\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "            },"] # [doc = "            \"type\": {"] # [doc = "              \"type\": \"number\","] # [doc = "              \"enum\": ["] # [doc = "                1.0"] # [doc = "              ]"] # [doc = "            },"] # [doc = "            \"value\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"object\","] # [doc = "          \"required\": ["] # [doc = "            \"chain_id\","] # [doc = "            \"from_address\","] # [doc = "            \"gas_limit\","] # [doc = "            \"max_fee_per_gas\","] # [doc = "            \"max_priority_fee_per_gas\","] # [doc = "            \"nonce\","] # [doc = "            \"to_address\","] # [doc = "            \"transaction_hash\","] # [doc = "            \"type\","] # [doc = "            \"value\""] # [doc = "          ],"] # [doc = "          \"properties\": {"] # [doc = "            \"access_list\": {"] # [doc = "              \"type\": \"array\","] # [doc = "              \"items\": {"] # [doc = "                \"type\": \"object\","] # [doc = "                \"required\": ["] # [doc = "                  \"address\","] # [doc = "                  \"storage_keys\""] # [doc = "                ],"] # [doc = "                \"properties\": {"] # [doc = "                  \"address\": {"] # [doc = "                    \"type\": \"string\","] # [doc = "                    \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                  },"] # [doc = "                  \"storage_keys\": {"] # [doc = "                    \"type\": \"array\","] # [doc = "                    \"items\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                }"] # [doc = "              }"] # [doc = "            },"] # [doc = "            \"chain_id\": {"] # [doc = "              \"type\": \"integer\","] # [doc = "              \"exclusiveMinimum\": 0.0"] # [doc = "            },"] # [doc = "            \"data\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "            },"] # [doc = "            \"from_address\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "            },"] # [doc = "            \"gas_limit\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"max_fee_per_gas\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"max_priority_fee_per_gas\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"nonce\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"to_address\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "            },"] # [doc = "            \"transaction_hash\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "            },"] # [doc = "            \"type\": {"] # [doc = "              \"type\": \"number\","] # [doc = "              \"enum\": ["] # [doc = "                2.0"] # [doc = "              ]"] # [doc = "            },"] # [doc = "            \"value\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"object\","] # [doc = "          \"required\": ["] # [doc = "            \"blob_versioned_hashes\","] # [doc = "            \"chain_id\","] # [doc = "            \"from_address\","] # [doc = "            \"gas_limit\","] # [doc = "            \"max_fee_per_blob_gas\","] # [doc = "            \"max_fee_per_gas\","] # [doc = "            \"max_priority_fee_per_gas\","] # [doc = "            \"nonce\","] # [doc = "            \"to_address\","] # [doc = "            \"transaction_hash\","] # [doc = "            \"type\","] # [doc = "            \"value\""] # [doc = "          ],"] # [doc = "          \"properties\": {"] # [doc = "            \"access_list\": {"] # [doc = "              \"type\": \"array\","] # [doc = "              \"items\": {"] # [doc = "                \"type\": \"object\","] # [doc = "                \"required\": ["] # [doc = "                  \"address\","] # [doc = "                  \"storage_keys\""] # [doc = "                ],"] # [doc = "                \"properties\": {"] # [doc = "                  \"address\": {"] # [doc = "                    \"type\": \"string\","] # [doc = "                    \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                  },"] # [doc = "                  \"storage_keys\": {"] # [doc = "                    \"type\": \"array\","] # [doc = "                    \"items\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                }"] # [doc = "              }"] # [doc = "            },"] # [doc = "            \"blob_versioned_hashes\": {"] # [doc = "              \"type\": \"array\","] # [doc = "              \"items\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              }"] # [doc = "            },"] # [doc = "            \"chain_id\": {"] # [doc = "              \"type\": \"integer\","] # [doc = "              \"exclusiveMinimum\": 0.0"] # [doc = "            },"] # [doc = "            \"data\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "            },"] # [doc = "            \"from_address\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "            },"] # [doc = "            \"gas_limit\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"max_fee_per_blob_gas\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"max_fee_per_gas\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"max_priority_fee_per_gas\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"nonce\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"to_address\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "            },"] # [doc = "            \"transaction_hash\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "            },"] # [doc = "            \"type\": {"] # [doc = "              \"type\": \"number\","] # [doc = "              \"enum\": ["] # [doc = "                3.0"] # [doc = "              ]"] # [doc = "            },"] # [doc = "            \"value\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"object\","] # [doc = "          \"required\": ["] # [doc = "            \"authorization_list\","] # [doc = "            \"chain_id\","] # [doc = "            \"from_address\","] # [doc = "            \"gas_limit\","] # [doc = "            \"max_fee_per_gas\","] # [doc = "            \"max_priority_fee_per_gas\","] # [doc = "            \"nonce\","] # [doc = "            \"to_address\","] # [doc = "            \"transaction_hash\","] # [doc = "            \"type\","] # [doc = "            \"value\""] # [doc = "          ],"] # [doc = "          \"properties\": {"] # [doc = "            \"access_list\": {"] # [doc = "              \"type\": \"array\","] # [doc = "              \"items\": {"] # [doc = "                \"type\": \"object\","] # [doc = "                \"required\": ["] # [doc = "                  \"address\","] # [doc = "                  \"storage_keys\""] # [doc = "                ],"] # [doc = "                \"properties\": {"] # [doc = "                  \"address\": {"] # [doc = "                    \"type\": \"string\","] # [doc = "                    \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                  },"] # [doc = "                  \"storage_keys\": {"] # [doc = "                    \"type\": \"array\","] # [doc = "                    \"items\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                }"] # [doc = "              }"] # [doc = "            },"] # [doc = "            \"authorization_list\": {"] # [doc = "              \"type\": \"array\","] # [doc = "              \"items\": {"] # [doc = "                \"type\": \"object\","] # [doc = "                \"required\": ["] # [doc = "                  \"address\","] # [doc = "                  \"chain_id\","] # [doc = "                  \"nonce\","] # [doc = "                  \"r\","] # [doc = "                  \"s\","] # [doc = "                  \"v\""] # [doc = "                ],"] # [doc = "                \"properties\": {"] # [doc = "                  \"address\": {"] # [doc = "                    \"type\": \"string\","] # [doc = "                    \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                  },"] # [doc = "                  \"chain_id\": {"] # [doc = "                    \"type\": \"string\","] # [doc = "                    \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                  },"] # [doc = "                  \"nonce\": {"] # [doc = "                    \"type\": \"string\","] # [doc = "                    \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                  },"] # [doc = "                  \"r\": {"] # [doc = "                    \"type\": \"string\","] # [doc = "                    \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                  },"] # [doc = "                  \"s\": {"] # [doc = "                    \"type\": \"string\","] # [doc = "                    \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                  },"] # [doc = "                  \"v\": {"] # [doc = "                    \"type\": \"string\","] # [doc = "                    \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                  }"] # [doc = "                }"] # [doc = "              }"] # [doc = "            },"] # [doc = "            \"chain_id\": {"] # [doc = "              \"type\": \"integer\","] # [doc = "              \"exclusiveMinimum\": 0.0"] # [doc = "            },"] # [doc = "            \"data\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "            },"] # [doc = "            \"from_address\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "            },"] # [doc = "            \"gas_limit\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"max_fee_per_gas\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"max_priority_fee_per_gas\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"nonce\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            \"to_address\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "            },"] # [doc = "            \"transaction_hash\": {"] # [doc = "              \"type\": \"string\","] # [doc = "              \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "            },"] # [doc = "            \"type\": {"] # [doc = "              \"type\": \"number\","] # [doc = "              \"enum\": ["] # [doc = "                4.0"] # [doc = "              ]"] # [doc = "            },"] # [doc = "            \"value\": {"] # [doc = "              \"type\": \"string\""] # [doc = "            }"] # [doc = "          }"] # [doc = "        }"] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBody { # [serde (default , skip_serializing_if = "Option::is_none")] pub block_env : Option < PostEnforcerIncidentsBodyBlockEnv > , # [serde (default , skip_serializing_if = "Option::is_none")] pub block_number : Option < std :: num :: NonZeroU64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub enforcer_version : Option < String > , pub failures : Vec < PostEnforcerIncidentsBodyFailuresItem > , pub incident_timestamp : chrono :: DateTime < chrono :: offset :: Utc > , # [serde (default , skip_serializing_if = "Option::is_none")] pub previous_block_number : Option < u64 > , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub previous_transactions : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItem > , pub transaction_data : PostEnforcerIncidentsBodyTransactionData , } impl From < & PostEnforcerIncidentsBody > for PostEnforcerIncidentsBody { fn from (value : & PostEnforcerIncidentsBody) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyBlockEnv"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"basefee\","] # [doc = "    \"beneficiary\","] # [doc = "    \"difficulty\","] # [doc = "    \"gas_limit\","] # [doc = "    \"number\","] # [doc = "    \"timestamp\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"basefee\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"beneficiary\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"blob_excess_gas_and_price\": {"] # [doc = "      \"type\": ["] # [doc = "        \"object\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"required\": ["] # [doc = "        \"blob_gasprice\","] # [doc = "        \"excess_blob_gas\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"blob_gasprice\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"excess_blob_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"difficulty\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"gas_limit\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"number\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"prevrandao\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    },"] # [doc = "    \"timestamp\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyBlockEnv { pub basefee : String , pub beneficiary : PostEnforcerIncidentsBodyBlockEnvBeneficiary , # [serde (default , skip_serializing_if = "Option::is_none")] pub blob_excess_gas_and_price : Option < PostEnforcerIncidentsBodyBlockEnvBlobExcessGasAndPrice > , pub difficulty : String , pub gas_limit : String , pub number : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub prevrandao : Option < PostEnforcerIncidentsBodyBlockEnvPrevrandao > , pub timestamp : String , } impl From < & PostEnforcerIncidentsBodyBlockEnv > for PostEnforcerIncidentsBodyBlockEnv { fn from (value : & PostEnforcerIncidentsBodyBlockEnv) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyBlockEnvBeneficiary"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyBlockEnvBeneficiary (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyBlockEnvBeneficiary { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyBlockEnvBeneficiary > for String { fn from (value : PostEnforcerIncidentsBodyBlockEnvBeneficiary) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyBlockEnvBeneficiary > for PostEnforcerIncidentsBodyBlockEnvBeneficiary { fn from (value : & PostEnforcerIncidentsBodyBlockEnvBeneficiary) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyBlockEnvBeneficiary { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyBlockEnvBeneficiary { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyBlockEnvBeneficiary { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyBlockEnvBeneficiary { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyBlockEnvBeneficiary { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyBlockEnvBlobExcessGasAndPrice"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"blob_gasprice\","] # [doc = "    \"excess_blob_gas\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"blob_gasprice\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"excess_blob_gas\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyBlockEnvBlobExcessGasAndPrice { pub blob_gasprice : String , pub excess_blob_gas : String , } impl From < & PostEnforcerIncidentsBodyBlockEnvBlobExcessGasAndPrice > for PostEnforcerIncidentsBodyBlockEnvBlobExcessGasAndPrice { fn from (value : & PostEnforcerIncidentsBodyBlockEnvBlobExcessGasAndPrice) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyBlockEnvPrevrandao"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyBlockEnvPrevrandao (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyBlockEnvPrevrandao { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyBlockEnvPrevrandao > for String { fn from (value : PostEnforcerIncidentsBodyBlockEnvPrevrandao) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyBlockEnvPrevrandao > for PostEnforcerIncidentsBodyBlockEnvPrevrandao { fn from (value : & PostEnforcerIncidentsBodyBlockEnvPrevrandao) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyBlockEnvPrevrandao { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyBlockEnvPrevrandao { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyBlockEnvPrevrandao { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyBlockEnvPrevrandao { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyBlockEnvPrevrandao { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyFailuresItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_address\","] # [doc = "    \"assertion_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"assertion_fn_selector\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{8}$\""] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    },"] # [doc = "    \"revert_reason\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyFailuresItem { pub assertion_adopter_address : PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress , # [serde (default , skip_serializing_if = "Option::is_none")] pub assertion_fn_selector : Option < PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector > , pub assertion_id : PostEnforcerIncidentsBodyFailuresItemAssertionId , # [serde (default , skip_serializing_if = "Option::is_none")] pub revert_reason : Option < String > , } impl From < & PostEnforcerIncidentsBodyFailuresItem > for PostEnforcerIncidentsBodyFailuresItem { fn from (value : & PostEnforcerIncidentsBodyFailuresItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress > for String { fn from (value : PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress > for PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress { fn from (value : & PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyFailuresItemAssertionAdopterAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{8}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector > for String { fn from (value : PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector > for PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector { fn from (value : & PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{8}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{8}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyFailuresItemAssertionFnSelector { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyFailuresItemAssertionId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyFailuresItemAssertionId (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyFailuresItemAssertionId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyFailuresItemAssertionId > for String { fn from (value : PostEnforcerIncidentsBodyFailuresItemAssertionId) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyFailuresItemAssertionId > for PostEnforcerIncidentsBodyFailuresItemAssertionId { fn from (value : & PostEnforcerIncidentsBodyFailuresItemAssertionId) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyFailuresItemAssertionId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyFailuresItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyFailuresItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyFailuresItemAssertionId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyFailuresItemAssertionId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"chain_id\","] # [doc = "        \"from_address\","] # [doc = "        \"gas_limit\","] # [doc = "        \"gas_price\","] # [doc = "        \"nonce\","] # [doc = "        \"to_address\","] # [doc = "        \"transaction_hash\","] # [doc = "        \"type\","] # [doc = "        \"value\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"chain_id\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"data\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "        },"] # [doc = "        \"from_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"gas_price\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"nonce\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"to_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "        },"] # [doc = "        \"transaction_hash\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"type\": \"number\","] # [doc = "          \"enum\": ["] # [doc = "            0.0"] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"value\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"chain_id\","] # [doc = "        \"from_address\","] # [doc = "        \"gas_limit\","] # [doc = "        \"gas_price\","] # [doc = "        \"nonce\","] # [doc = "        \"to_address\","] # [doc = "        \"transaction_hash\","] # [doc = "        \"type\","] # [doc = "        \"value\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"access_list\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"storage_keys\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"storage_keys\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"chain_id\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"data\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "        },"] # [doc = "        \"from_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"gas_price\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"nonce\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"to_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "        },"] # [doc = "        \"transaction_hash\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"type\": \"number\","] # [doc = "          \"enum\": ["] # [doc = "            1.0"] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"value\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"chain_id\","] # [doc = "        \"from_address\","] # [doc = "        \"gas_limit\","] # [doc = "        \"max_fee_per_gas\","] # [doc = "        \"max_priority_fee_per_gas\","] # [doc = "        \"nonce\","] # [doc = "        \"to_address\","] # [doc = "        \"transaction_hash\","] # [doc = "        \"type\","] # [doc = "        \"value\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"access_list\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"storage_keys\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"storage_keys\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"chain_id\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"data\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "        },"] # [doc = "        \"from_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_priority_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"nonce\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"to_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "        },"] # [doc = "        \"transaction_hash\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"type\": \"number\","] # [doc = "          \"enum\": ["] # [doc = "            2.0"] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"value\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"blob_versioned_hashes\","] # [doc = "        \"chain_id\","] # [doc = "        \"from_address\","] # [doc = "        \"gas_limit\","] # [doc = "        \"max_fee_per_blob_gas\","] # [doc = "        \"max_fee_per_gas\","] # [doc = "        \"max_priority_fee_per_gas\","] # [doc = "        \"nonce\","] # [doc = "        \"to_address\","] # [doc = "        \"transaction_hash\","] # [doc = "        \"type\","] # [doc = "        \"value\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"access_list\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"storage_keys\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"storage_keys\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"blob_versioned_hashes\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"chain_id\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"data\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "        },"] # [doc = "        \"from_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_fee_per_blob_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_priority_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"nonce\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"to_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "        },"] # [doc = "        \"transaction_hash\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"type\": \"number\","] # [doc = "          \"enum\": ["] # [doc = "            3.0"] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"value\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"authorization_list\","] # [doc = "        \"chain_id\","] # [doc = "        \"from_address\","] # [doc = "        \"gas_limit\","] # [doc = "        \"max_fee_per_gas\","] # [doc = "        \"max_priority_fee_per_gas\","] # [doc = "        \"nonce\","] # [doc = "        \"to_address\","] # [doc = "        \"transaction_hash\","] # [doc = "        \"type\","] # [doc = "        \"value\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"access_list\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"storage_keys\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"storage_keys\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"authorization_list\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"chain_id\","] # [doc = "              \"nonce\","] # [doc = "              \"r\","] # [doc = "              \"s\","] # [doc = "              \"v\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"chain_id\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"nonce\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"r\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"s\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"v\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"chain_id\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"data\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "        },"] # [doc = "        \"from_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_priority_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"nonce\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"to_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "        },"] # [doc = "        \"transaction_hash\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"type\": \"number\","] # [doc = "          \"enum\": ["] # [doc = "            4.0"] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"value\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum PostEnforcerIncidentsBodyPreviousTransactionsItem { Variant0 { chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] data : Option < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data > , from_address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress , gas_limit : String , gas_price : String , nonce : String , to_address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress , transaction_hash : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash , # [serde (rename = "type")] type_ : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type , value : String , } , Variant1 { # [serde (default , skip_serializing_if = "Vec::is_empty")] access_list : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItem > , chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] data : Option < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data > , from_address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress , gas_limit : String , gas_price : String , nonce : String , to_address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress , transaction_hash : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash , # [serde (rename = "type")] type_ : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type , value : String , } , Variant2 { # [serde (default , skip_serializing_if = "Vec::is_empty")] access_list : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItem > , chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] data : Option < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data > , from_address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress , gas_limit : String , max_fee_per_gas : String , max_priority_fee_per_gas : String , nonce : String , to_address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress , transaction_hash : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash , # [serde (rename = "type")] type_ : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type , value : String , } , Variant3 { # [serde (default , skip_serializing_if = "Vec::is_empty")] access_list : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItem > , blob_versioned_hashes : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem > , chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] data : Option < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data > , from_address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress , gas_limit : String , max_fee_per_blob_gas : String , max_fee_per_gas : String , max_priority_fee_per_gas : String , nonce : String , to_address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress , transaction_hash : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash , # [serde (rename = "type")] type_ : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type , value : String , } , Variant4 { # [serde (default , skip_serializing_if = "Vec::is_empty")] access_list : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItem > , authorization_list : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItem > , chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] data : Option < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data > , from_address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress , gas_limit : String , max_fee_per_gas : String , max_priority_fee_per_gas : String , nonce : String , to_address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress , transaction_hash : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash , # [serde (rename = "type")] type_ : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type , value : String , } , } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItem > for PostEnforcerIncidentsBodyPreviousTransactionsItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Data { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0FromAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$|^$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$|^$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0ToAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0TransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"number\","] # [doc = "  \"enum\": ["] # [doc = "    0.0"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type (f64) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type { type Target = f64 ; fn deref (& self) -> & f64 { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type > for f64 { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type) -> Self { value . clone () } } impl std :: convert :: TryFrom < f64 > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type { type Error = self :: error :: ConversionError ; fn try_from (value : f64) -> Result < Self , self :: error :: ConversionError > { if ! [0.0_f64 ,] . contains (& value) { Err ("invalid value" . into ()) } else { Ok (Self (value)) } } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant0Type { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { Self :: try_from (< f64 > :: deserialize (deserializer) ? ,) . map_err (| e | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"storage_keys\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"storage_keys\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItem { pub address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress , pub storage_keys : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem > , } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItem > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1AccessListItemStorageKeysItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Data { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1FromAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$|^$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$|^$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1ToAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1TransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"number\","] # [doc = "  \"enum\": ["] # [doc = "    1.0"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type (f64) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type { type Target = f64 ; fn deref (& self) -> & f64 { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type > for f64 { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type) -> Self { value . clone () } } impl std :: convert :: TryFrom < f64 > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type { type Error = self :: error :: ConversionError ; fn try_from (value : f64) -> Result < Self , self :: error :: ConversionError > { if ! [1.0_f64 ,] . contains (& value) { Err ("invalid value" . into ()) } else { Ok (Self (value)) } } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant1Type { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { Self :: try_from (< f64 > :: deserialize (deserializer) ? ,) . map_err (| e | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"storage_keys\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"storage_keys\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItem { pub address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress , pub storage_keys : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem > , } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItem > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2AccessListItemStorageKeysItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Data { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2FromAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$|^$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$|^$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2ToAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2TransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"number\","] # [doc = "  \"enum\": ["] # [doc = "    2.0"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type (f64) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type { type Target = f64 ; fn deref (& self) -> & f64 { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type > for f64 { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type) -> Self { value . clone () } } impl std :: convert :: TryFrom < f64 > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type { type Error = self :: error :: ConversionError ; fn try_from (value : f64) -> Result < Self , self :: error :: ConversionError > { if ! [2.0_f64 ,] . contains (& value) { Err ("invalid value" . into ()) } else { Ok (Self (value)) } } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant2Type { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { Self :: try_from (< f64 > :: deserialize (deserializer) ? ,) . map_err (| e | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"storage_keys\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"storage_keys\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItem { pub address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress , pub storage_keys : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem > , } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItem > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3AccessListItemStorageKeysItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3BlobVersionedHashesItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Data { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3FromAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$|^$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$|^$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3ToAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3TransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"number\","] # [doc = "  \"enum\": ["] # [doc = "    3.0"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type (f64) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type { type Target = f64 ; fn deref (& self) -> & f64 { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type > for f64 { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type) -> Self { value . clone () } } impl std :: convert :: TryFrom < f64 > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type { type Error = self :: error :: ConversionError ; fn try_from (value : f64) -> Result < Self , self :: error :: ConversionError > { if ! [3.0_f64 ,] . contains (& value) { Err ("invalid value" . into ()) } else { Ok (Self (value)) } } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant3Type { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { Self :: try_from (< f64 > :: deserialize (deserializer) ? ,) . map_err (| e | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"storage_keys\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"storage_keys\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItem { pub address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress , pub storage_keys : Vec < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem > , } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItem > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AccessListItemStorageKeysItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"chain_id\","] # [doc = "    \"nonce\","] # [doc = "    \"r\","] # [doc = "    \"s\","] # [doc = "    \"v\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"chain_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    },"] # [doc = "    \"nonce\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    },"] # [doc = "    \"r\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    },"] # [doc = "    \"s\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    },"] # [doc = "    \"v\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItem { pub address : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress , pub chain_id : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId , pub nonce : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce , pub r : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR , pub s : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS , pub v : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV , } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItem > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItem { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemChainId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemNonce { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemR { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemS { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4AuthorizationListItemV { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Data { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4FromAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$|^$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$|^$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4ToAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash > for String { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4TransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"number\","] # [doc = "  \"enum\": ["] # [doc = "    4.0"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type (f64) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type { type Target = f64 ; fn deref (& self) -> & f64 { & self . 0 } } impl From < PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type > for f64 { fn from (value : PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type { fn from (value : & PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type) -> Self { value . clone () } } impl std :: convert :: TryFrom < f64 > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type { type Error = self :: error :: ConversionError ; fn try_from (value : f64) -> Result < Self , self :: error :: ConversionError > { if ! [4.0_f64 ,] . contains (& value) { Err ("invalid value" . into ()) } else { Ok (Self (value)) } } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyPreviousTransactionsItemVariant4Type { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { Self :: try_from (< f64 > :: deserialize (deserializer) ? ,) . map_err (| e | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionData"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"chain_id\","] # [doc = "        \"from_address\","] # [doc = "        \"gas_limit\","] # [doc = "        \"gas_price\","] # [doc = "        \"nonce\","] # [doc = "        \"to_address\","] # [doc = "        \"transaction_hash\","] # [doc = "        \"type\","] # [doc = "        \"value\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"chain_id\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"data\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "        },"] # [doc = "        \"from_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"gas_price\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"nonce\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"to_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "        },"] # [doc = "        \"transaction_hash\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"type\": \"number\","] # [doc = "          \"enum\": ["] # [doc = "            0.0"] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"value\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"chain_id\","] # [doc = "        \"from_address\","] # [doc = "        \"gas_limit\","] # [doc = "        \"gas_price\","] # [doc = "        \"nonce\","] # [doc = "        \"to_address\","] # [doc = "        \"transaction_hash\","] # [doc = "        \"type\","] # [doc = "        \"value\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"access_list\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"storage_keys\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"storage_keys\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"chain_id\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"data\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "        },"] # [doc = "        \"from_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"gas_price\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"nonce\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"to_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "        },"] # [doc = "        \"transaction_hash\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"type\": \"number\","] # [doc = "          \"enum\": ["] # [doc = "            1.0"] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"value\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"chain_id\","] # [doc = "        \"from_address\","] # [doc = "        \"gas_limit\","] # [doc = "        \"max_fee_per_gas\","] # [doc = "        \"max_priority_fee_per_gas\","] # [doc = "        \"nonce\","] # [doc = "        \"to_address\","] # [doc = "        \"transaction_hash\","] # [doc = "        \"type\","] # [doc = "        \"value\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"access_list\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"storage_keys\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"storage_keys\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"chain_id\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"data\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "        },"] # [doc = "        \"from_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_priority_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"nonce\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"to_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "        },"] # [doc = "        \"transaction_hash\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"type\": \"number\","] # [doc = "          \"enum\": ["] # [doc = "            2.0"] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"value\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"blob_versioned_hashes\","] # [doc = "        \"chain_id\","] # [doc = "        \"from_address\","] # [doc = "        \"gas_limit\","] # [doc = "        \"max_fee_per_blob_gas\","] # [doc = "        \"max_fee_per_gas\","] # [doc = "        \"max_priority_fee_per_gas\","] # [doc = "        \"nonce\","] # [doc = "        \"to_address\","] # [doc = "        \"transaction_hash\","] # [doc = "        \"type\","] # [doc = "        \"value\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"access_list\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"storage_keys\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"storage_keys\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"blob_versioned_hashes\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"chain_id\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"data\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "        },"] # [doc = "        \"from_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_fee_per_blob_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_priority_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"nonce\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"to_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "        },"] # [doc = "        \"transaction_hash\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"type\": \"number\","] # [doc = "          \"enum\": ["] # [doc = "            3.0"] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"value\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"authorization_list\","] # [doc = "        \"chain_id\","] # [doc = "        \"from_address\","] # [doc = "        \"gas_limit\","] # [doc = "        \"max_fee_per_gas\","] # [doc = "        \"max_priority_fee_per_gas\","] # [doc = "        \"nonce\","] # [doc = "        \"to_address\","] # [doc = "        \"transaction_hash\","] # [doc = "        \"type\","] # [doc = "        \"value\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"access_list\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"storage_keys\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"storage_keys\": {"] # [doc = "                \"type\": \"array\","] # [doc = "                \"items\": {"] # [doc = "                  \"type\": \"string\","] # [doc = "                  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "                }"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"authorization_list\": {"] # [doc = "          \"type\": \"array\","] # [doc = "          \"items\": {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"chain_id\","] # [doc = "              \"nonce\","] # [doc = "              \"r\","] # [doc = "              \"s\","] # [doc = "              \"v\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"chain_id\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"nonce\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"r\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"s\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              },"] # [doc = "              \"v\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        },"] # [doc = "        \"chain_id\": {"] # [doc = "          \"type\": \"integer\","] # [doc = "          \"exclusiveMinimum\": 0.0"] # [doc = "        },"] # [doc = "        \"data\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "        },"] # [doc = "        \"from_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"gas_limit\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"max_priority_fee_per_gas\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"nonce\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"to_address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "        },"] # [doc = "        \"transaction_hash\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "        },"] # [doc = "        \"type\": {"] # [doc = "          \"type\": \"number\","] # [doc = "          \"enum\": ["] # [doc = "            4.0"] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"value\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum PostEnforcerIncidentsBodyTransactionData { Variant0 { chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] data : Option < PostEnforcerIncidentsBodyTransactionDataVariant0Data > , from_address : PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress , gas_limit : String , gas_price : String , nonce : String , to_address : PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress , transaction_hash : PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash , # [serde (rename = "type")] type_ : PostEnforcerIncidentsBodyTransactionDataVariant0Type , value : String , } , Variant1 { # [serde (default , skip_serializing_if = "Vec::is_empty")] access_list : Vec < PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItem > , chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] data : Option < PostEnforcerIncidentsBodyTransactionDataVariant1Data > , from_address : PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress , gas_limit : String , gas_price : String , nonce : String , to_address : PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress , transaction_hash : PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash , # [serde (rename = "type")] type_ : PostEnforcerIncidentsBodyTransactionDataVariant1Type , value : String , } , Variant2 { # [serde (default , skip_serializing_if = "Vec::is_empty")] access_list : Vec < PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItem > , chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] data : Option < PostEnforcerIncidentsBodyTransactionDataVariant2Data > , from_address : PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress , gas_limit : String , max_fee_per_gas : String , max_priority_fee_per_gas : String , nonce : String , to_address : PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress , transaction_hash : PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash , # [serde (rename = "type")] type_ : PostEnforcerIncidentsBodyTransactionDataVariant2Type , value : String , } , Variant3 { # [serde (default , skip_serializing_if = "Vec::is_empty")] access_list : Vec < PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItem > , blob_versioned_hashes : Vec < PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem > , chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] data : Option < PostEnforcerIncidentsBodyTransactionDataVariant3Data > , from_address : PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress , gas_limit : String , max_fee_per_blob_gas : String , max_fee_per_gas : String , max_priority_fee_per_gas : String , nonce : String , to_address : PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress , transaction_hash : PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash , # [serde (rename = "type")] type_ : PostEnforcerIncidentsBodyTransactionDataVariant3Type , value : String , } , Variant4 { # [serde (default , skip_serializing_if = "Vec::is_empty")] access_list : Vec < PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItem > , authorization_list : Vec < PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItem > , chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] data : Option < PostEnforcerIncidentsBodyTransactionDataVariant4Data > , from_address : PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress , gas_limit : String , max_fee_per_gas : String , max_priority_fee_per_gas : String , nonce : String , to_address : PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress , transaction_hash : PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash , # [serde (rename = "type")] type_ : PostEnforcerIncidentsBodyTransactionDataVariant4Type , value : String , } , } impl From < & PostEnforcerIncidentsBodyTransactionData > for PostEnforcerIncidentsBodyTransactionData { fn from (value : & PostEnforcerIncidentsBodyTransactionData) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant0Data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant0Data (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant0Data { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant0Data > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant0Data) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant0Data > for PostEnforcerIncidentsBodyTransactionDataVariant0Data { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant0Data) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant0Data { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant0Data { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant0Data { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant0Data { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant0Data { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress > for PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant0FromAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress > for PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$|^$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$|^$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant0ToAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash > for PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant0TransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant0Type"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"number\","] # [doc = "  \"enum\": ["] # [doc = "    0.0"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant0Type (f64) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant0Type { type Target = f64 ; fn deref (& self) -> & f64 { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant0Type > for f64 { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant0Type) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant0Type > for PostEnforcerIncidentsBodyTransactionDataVariant0Type { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant0Type) -> Self { value . clone () } } impl std :: convert :: TryFrom < f64 > for PostEnforcerIncidentsBodyTransactionDataVariant0Type { type Error = self :: error :: ConversionError ; fn try_from (value : f64) -> Result < Self , self :: error :: ConversionError > { if ! [0.0_f64 ,] . contains (& value) { Err ("invalid value" . into ()) } else { Ok (Self (value)) } } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant0Type { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { Self :: try_from (< f64 > :: deserialize (deserializer) ? ,) . map_err (| e | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"storage_keys\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"storage_keys\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItem { pub address : PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress , pub storage_keys : Vec < PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem > , } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItem > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItem { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant1AccessListItemStorageKeysItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant1Data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant1Data (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant1Data { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant1Data > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant1Data) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant1Data > for PostEnforcerIncidentsBodyTransactionDataVariant1Data { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant1Data) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant1Data { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant1Data { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant1Data { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant1Data { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant1Data { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress > for PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant1FromAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress > for PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$|^$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$|^$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant1ToAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash > for PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant1TransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant1Type"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"number\","] # [doc = "  \"enum\": ["] # [doc = "    1.0"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant1Type (f64) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant1Type { type Target = f64 ; fn deref (& self) -> & f64 { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant1Type > for f64 { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant1Type) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant1Type > for PostEnforcerIncidentsBodyTransactionDataVariant1Type { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant1Type) -> Self { value . clone () } } impl std :: convert :: TryFrom < f64 > for PostEnforcerIncidentsBodyTransactionDataVariant1Type { type Error = self :: error :: ConversionError ; fn try_from (value : f64) -> Result < Self , self :: error :: ConversionError > { if ! [1.0_f64 ,] . contains (& value) { Err ("invalid value" . into ()) } else { Ok (Self (value)) } } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant1Type { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { Self :: try_from (< f64 > :: deserialize (deserializer) ? ,) . map_err (| e | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"storage_keys\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"storage_keys\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItem { pub address : PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress , pub storage_keys : Vec < PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem > , } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItem > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItem { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant2AccessListItemStorageKeysItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant2Data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant2Data (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant2Data { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant2Data > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant2Data) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant2Data > for PostEnforcerIncidentsBodyTransactionDataVariant2Data { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant2Data) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant2Data { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant2Data { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant2Data { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant2Data { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant2Data { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress > for PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant2FromAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress > for PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$|^$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$|^$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant2ToAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash > for PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant2TransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant2Type"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"number\","] # [doc = "  \"enum\": ["] # [doc = "    2.0"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant2Type (f64) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant2Type { type Target = f64 ; fn deref (& self) -> & f64 { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant2Type > for f64 { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant2Type) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant2Type > for PostEnforcerIncidentsBodyTransactionDataVariant2Type { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant2Type) -> Self { value . clone () } } impl std :: convert :: TryFrom < f64 > for PostEnforcerIncidentsBodyTransactionDataVariant2Type { type Error = self :: error :: ConversionError ; fn try_from (value : f64) -> Result < Self , self :: error :: ConversionError > { if ! [2.0_f64 ,] . contains (& value) { Err ("invalid value" . into ()) } else { Ok (Self (value)) } } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant2Type { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { Self :: try_from (< f64 > :: deserialize (deserializer) ? ,) . map_err (| e | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"storage_keys\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"storage_keys\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItem { pub address : PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress , pub storage_keys : Vec < PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem > , } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItem > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItem { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant3AccessListItemStorageKeysItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem > for PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant3BlobVersionedHashesItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant3Data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant3Data (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant3Data { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant3Data > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant3Data) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant3Data > for PostEnforcerIncidentsBodyTransactionDataVariant3Data { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant3Data) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant3Data { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant3Data { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant3Data { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant3Data { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant3Data { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress > for PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant3FromAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress > for PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$|^$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$|^$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant3ToAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash > for PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant3TransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant3Type"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"number\","] # [doc = "  \"enum\": ["] # [doc = "    3.0"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant3Type (f64) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant3Type { type Target = f64 ; fn deref (& self) -> & f64 { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant3Type > for f64 { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant3Type) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant3Type > for PostEnforcerIncidentsBodyTransactionDataVariant3Type { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant3Type) -> Self { value . clone () } } impl std :: convert :: TryFrom < f64 > for PostEnforcerIncidentsBodyTransactionDataVariant3Type { type Error = self :: error :: ConversionError ; fn try_from (value : f64) -> Result < Self , self :: error :: ConversionError > { if ! [3.0_f64 ,] . contains (& value) { Err ("invalid value" . into ()) } else { Ok (Self (value)) } } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant3Type { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { Self :: try_from (< f64 > :: deserialize (deserializer) ? ,) . map_err (| e | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"storage_keys\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"storage_keys\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItem { pub address : PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress , pub storage_keys : Vec < PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem > , } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItem > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItem { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4AccessListItemStorageKeysItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"chain_id\","] # [doc = "    \"nonce\","] # [doc = "    \"r\","] # [doc = "    \"s\","] # [doc = "    \"v\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"chain_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    },"] # [doc = "    \"nonce\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    },"] # [doc = "    \"r\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    },"] # [doc = "    \"s\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    },"] # [doc = "    \"v\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItem { pub address : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress , pub chain_id : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId , pub nonce : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce , pub r : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR , pub s : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS , pub v : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV , } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItem > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItem { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItem) -> Self { value . clone () } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemChainId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemNonce { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemR { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemS { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4AuthorizationListItemV { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4Data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4Data (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4Data { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4Data > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4Data) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4Data > for PostEnforcerIncidentsBodyTransactionDataVariant4Data { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4Data) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4Data { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]*$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4Data { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4Data { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4Data { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4Data { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress > for PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4FromAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$|^$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress > for PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$|^$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$|^$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4ToAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash (String) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash > for String { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash > for PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4TransactionHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsBodyTransactionDataVariant4Type"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"number\","] # [doc = "  \"enum\": ["] # [doc = "    4.0"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsBodyTransactionDataVariant4Type (f64) ; impl :: std :: ops :: Deref for PostEnforcerIncidentsBodyTransactionDataVariant4Type { type Target = f64 ; fn deref (& self) -> & f64 { & self . 0 } } impl From < PostEnforcerIncidentsBodyTransactionDataVariant4Type > for f64 { fn from (value : PostEnforcerIncidentsBodyTransactionDataVariant4Type) -> Self { value . 0 } } impl From < & PostEnforcerIncidentsBodyTransactionDataVariant4Type > for PostEnforcerIncidentsBodyTransactionDataVariant4Type { fn from (value : & PostEnforcerIncidentsBodyTransactionDataVariant4Type) -> Self { value . clone () } } impl std :: convert :: TryFrom < f64 > for PostEnforcerIncidentsBodyTransactionDataVariant4Type { type Error = self :: error :: ConversionError ; fn try_from (value : f64) -> Result < Self , self :: error :: ConversionError > { if ! [4.0_f64 ,] . contains (& value) { Err ("invalid value" . into ()) } else { Ok (Self (value)) } } } impl < 'de > :: serde :: Deserialize < 'de > for PostEnforcerIncidentsBodyTransactionDataVariant4Type { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { Self :: try_from (< f64 > :: deserialize (deserializer) ? ,) . map_err (| e | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostEnforcerIncidentsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\","] # [doc = "    \"timestamp\","] # [doc = "    \"tracking_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"timestamp\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"tracking_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerIncidentsResponse { pub message : String , pub timestamp : chrono :: DateTime < chrono :: offset :: Utc > , pub tracking_id : String , } impl From < & PostEnforcerIncidentsResponse > for PostEnforcerIncidentsResponse { fn from (value : & PostEnforcerIncidentsResponse) -> Self { value . clone () } } # [doc = "PostEnforcerNetworkStatusBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"chain_id\","] # [doc = "    \"status\","] # [doc = "    \"timestamp\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chain_id\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"metadata\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"properties\": {"] # [doc = "        \"degradation_reason\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"message\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"operational\","] # [doc = "        \"degraded\","] # [doc = "        \"outage\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"timestamp\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"version\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerNetworkStatusBody { pub chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] pub metadata : Option < PostEnforcerNetworkStatusBodyMetadata > , pub status : PostEnforcerNetworkStatusBodyStatus , pub timestamp : chrono :: DateTime < chrono :: offset :: Utc > , # [serde (default , skip_serializing_if = "Option::is_none")] pub version : Option < String > , } impl From < & PostEnforcerNetworkStatusBody > for PostEnforcerNetworkStatusBody { fn from (value : & PostEnforcerNetworkStatusBody) -> Self { value . clone () } } # [doc = "PostEnforcerNetworkStatusBodyMetadata"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"degradation_reason\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerNetworkStatusBodyMetadata { # [serde (default , skip_serializing_if = "Option::is_none")] pub degradation_reason : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , } impl From < & PostEnforcerNetworkStatusBodyMetadata > for PostEnforcerNetworkStatusBodyMetadata { fn from (value : & PostEnforcerNetworkStatusBodyMetadata) -> Self { value . clone () } } # [doc = "PostEnforcerNetworkStatusBodyStatus"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"operational\","] # [doc = "    \"degraded\","] # [doc = "    \"outage\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PostEnforcerNetworkStatusBodyStatus { # [serde (rename = "operational")] Operational , # [serde (rename = "degraded")] Degraded , # [serde (rename = "outage")] Outage , } impl From < & PostEnforcerNetworkStatusBodyStatus > for PostEnforcerNetworkStatusBodyStatus { fn from (value : & PostEnforcerNetworkStatusBodyStatus) -> Self { value . clone () } } impl :: std :: fmt :: Display for PostEnforcerNetworkStatusBodyStatus { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Operational => write ! (f , "operational") , Self :: Degraded => write ! (f , "degraded") , Self :: Outage => write ! (f , "outage") , } } } impl std :: str :: FromStr for PostEnforcerNetworkStatusBodyStatus { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "operational" => Ok (Self :: Operational) , "degraded" => Ok (Self :: Degraded) , "outage" => Ok (Self :: Outage) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PostEnforcerNetworkStatusBodyStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostEnforcerNetworkStatusBodyStatus { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostEnforcerNetworkStatusBodyStatus { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "PostEnforcerNetworkStatusResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\","] # [doc = "    \"timestamp\","] # [doc = "    \"tracking_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"timestamp\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"tracking_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostEnforcerNetworkStatusResponse { pub message : String , pub timestamp : chrono :: DateTime < chrono :: offset :: Utc > , pub tracking_id : String , } impl From < & PostEnforcerNetworkStatusResponse > for PostEnforcerNetworkStatusResponse { fn from (value : & PostEnforcerNetworkStatusResponse) -> Self { value . clone () } } # [doc = "PostManualVerificationRequestsIdSignaturePrepareResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"expires_at\","] # [doc = "    \"message\","] # [doc = "    \"nonce\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"expires_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"nonce\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostManualVerificationRequestsIdSignaturePrepareResponse { pub expires_at : chrono :: DateTime < chrono :: offset :: Utc > , pub message : String , pub nonce : String , } impl From < & PostManualVerificationRequestsIdSignaturePrepareResponse > for PostManualVerificationRequestsIdSignaturePrepareResponse { fn from (value : & PostManualVerificationRequestsIdSignaturePrepareResponse) -> Self { value . clone () } } # [doc = "PostManualVerificationRequestsIdSignatureVerifyBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\","] # [doc = "    \"signature\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"minLength\": 1"] # [doc = "    },"] # [doc = "    \"signature\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]+$\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostManualVerificationRequestsIdSignatureVerifyBody { pub message : PostManualVerificationRequestsIdSignatureVerifyBodyMessage , pub signature : PostManualVerificationRequestsIdSignatureVerifyBodySignature , } impl From < & PostManualVerificationRequestsIdSignatureVerifyBody > for PostManualVerificationRequestsIdSignatureVerifyBody { fn from (value : & PostManualVerificationRequestsIdSignatureVerifyBody) -> Self { value . clone () } } # [doc = "PostManualVerificationRequestsIdSignatureVerifyBodyMessage"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostManualVerificationRequestsIdSignatureVerifyBodyMessage (String) ; impl :: std :: ops :: Deref for PostManualVerificationRequestsIdSignatureVerifyBodyMessage { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostManualVerificationRequestsIdSignatureVerifyBodyMessage > for String { fn from (value : PostManualVerificationRequestsIdSignatureVerifyBodyMessage) -> Self { value . 0 } } impl From < & PostManualVerificationRequestsIdSignatureVerifyBodyMessage > for PostManualVerificationRequestsIdSignatureVerifyBodyMessage { fn from (value : & PostManualVerificationRequestsIdSignatureVerifyBodyMessage) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostManualVerificationRequestsIdSignatureVerifyBodyMessage { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostManualVerificationRequestsIdSignatureVerifyBodyMessage { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostManualVerificationRequestsIdSignatureVerifyBodyMessage { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostManualVerificationRequestsIdSignatureVerifyBodyMessage { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostManualVerificationRequestsIdSignatureVerifyBodyMessage { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostManualVerificationRequestsIdSignatureVerifyBodySignature"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]+$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostManualVerificationRequestsIdSignatureVerifyBodySignature (String) ; impl :: std :: ops :: Deref for PostManualVerificationRequestsIdSignatureVerifyBodySignature { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostManualVerificationRequestsIdSignatureVerifyBodySignature > for String { fn from (value : PostManualVerificationRequestsIdSignatureVerifyBodySignature) -> Self { value . 0 } } impl From < & PostManualVerificationRequestsIdSignatureVerifyBodySignature > for PostManualVerificationRequestsIdSignatureVerifyBodySignature { fn from (value : & PostManualVerificationRequestsIdSignatureVerifyBodySignature) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostManualVerificationRequestsIdSignatureVerifyBodySignature { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]+$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]+$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostManualVerificationRequestsIdSignatureVerifyBodySignature { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostManualVerificationRequestsIdSignatureVerifyBodySignature { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostManualVerificationRequestsIdSignatureVerifyBodySignature { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostManualVerificationRequestsIdSignatureVerifyBodySignature { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostManualVerificationRequestsIdSignatureVerifyResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"signature_hash\","] # [doc = "    \"success\","] # [doc = "    \"verified_at\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"signature_hash\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"verified_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostManualVerificationRequestsIdSignatureVerifyResponse { pub signature_hash : String , pub success : bool , pub verified_at : chrono :: DateTime < chrono :: offset :: Utc > , } impl From < & PostManualVerificationRequestsIdSignatureVerifyResponse > for PostManualVerificationRequestsIdSignatureVerifyResponse { fn from (value : & PostManualVerificationRequestsIdSignatureVerifyResponse) -> Self { value . clone () } } # [doc = "PostProjectsBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"chain_id\","] # [doc = "    \"project_name\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopters\": {"] # [doc = "      \"default\": [],"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"chain_id\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"draft_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"project_description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 1000"] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsBody { # [serde (default , skip_serializing_if = "Vec::is_empty")] pub assertion_adopters : Vec < PostProjectsBodyAssertionAdoptersItem > , pub chain_id : std :: num :: NonZeroU64 , # [serde (default , skip_serializing_if = "Option::is_none")] pub draft_id : Option < uuid :: Uuid > , # [serde (default , skip_serializing_if = "Option::is_none")] pub profile_image_url : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_description : Option < PostProjectsBodyProjectDescription > , pub project_name : PostProjectsBodyProjectName , } impl From < & PostProjectsBody > for PostProjectsBody { fn from (value : & PostProjectsBody) -> Self { value . clone () } } # [doc = "PostProjectsBodyAssertionAdoptersItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsBodyAssertionAdoptersItem (String) ; impl :: std :: ops :: Deref for PostProjectsBodyAssertionAdoptersItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsBodyAssertionAdoptersItem > for String { fn from (value : PostProjectsBodyAssertionAdoptersItem) -> Self { value . 0 } } impl From < & PostProjectsBodyAssertionAdoptersItem > for PostProjectsBodyAssertionAdoptersItem { fn from (value : & PostProjectsBodyAssertionAdoptersItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsBodyAssertionAdoptersItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsBodyAssertionAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsBodyAssertionAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsBodyAssertionAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsBodyAssertionAdoptersItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsBodyProjectDescription"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 1000"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsBodyProjectDescription (String) ; impl :: std :: ops :: Deref for PostProjectsBodyProjectDescription { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsBodyProjectDescription > for String { fn from (value : PostProjectsBodyProjectDescription) -> Self { value . 0 } } impl From < & PostProjectsBodyProjectDescription > for PostProjectsBodyProjectDescription { fn from (value : & PostProjectsBodyProjectDescription) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsBodyProjectDescription { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 1000usize { return Err ("longer than 1000 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsBodyProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsBodyProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsBodyProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsBodyProjectDescription { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsBodyProjectName"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsBodyProjectName (String) ; impl :: std :: ops :: Deref for PostProjectsBodyProjectName { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsBodyProjectName > for String { fn from (value : PostProjectsBodyProjectName) -> Self { value . 0 } } impl From < & PostProjectsBodyProjectName > for PostProjectsBodyProjectName { fn from (value : & PostProjectsBodyProjectName) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsBodyProjectName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsBodyProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsBodyProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsBodyProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsBodyProjectName { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsDraftsBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"addresses\": {"] # [doc = "      \"default\": [],"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"manual_verification_addresses\": {"] # [doc = "      \"default\": [],"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"project_description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 1000"] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    },"] # [doc = "    \"project_networks\": {"] # [doc = "      \"default\": [],"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"integer\","] # [doc = "        \"exclusiveMinimum\": 0.0"] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsDraftsBody { # [serde (default , skip_serializing_if = "Vec::is_empty")] pub addresses : Vec < PostProjectsDraftsBodyAddressesItem > , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub manual_verification_addresses : Vec < PostProjectsDraftsBodyManualVerificationAddressesItem > , # [serde (default , skip_serializing_if = "Option::is_none")] pub profile_image_url : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_description : Option < PostProjectsDraftsBodyProjectDescription > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_name : Option < PostProjectsDraftsBodyProjectName > , # [serde (default , skip_serializing_if = "Vec::is_empty")] pub project_networks : Vec < std :: num :: NonZeroU64 > , } impl From < & PostProjectsDraftsBody > for PostProjectsDraftsBody { fn from (value : & PostProjectsDraftsBody) -> Self { value . clone () } } # [doc = "PostProjectsDraftsBodyAddressesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsDraftsBodyAddressesItem (String) ; impl :: std :: ops :: Deref for PostProjectsDraftsBodyAddressesItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsDraftsBodyAddressesItem > for String { fn from (value : PostProjectsDraftsBodyAddressesItem) -> Self { value . 0 } } impl From < & PostProjectsDraftsBodyAddressesItem > for PostProjectsDraftsBodyAddressesItem { fn from (value : & PostProjectsDraftsBodyAddressesItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsDraftsBodyAddressesItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsDraftsBodyAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsDraftsBodyAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsDraftsBodyAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsDraftsBodyAddressesItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsDraftsBodyManualVerificationAddressesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsDraftsBodyManualVerificationAddressesItem (String) ; impl :: std :: ops :: Deref for PostProjectsDraftsBodyManualVerificationAddressesItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsDraftsBodyManualVerificationAddressesItem > for String { fn from (value : PostProjectsDraftsBodyManualVerificationAddressesItem) -> Self { value . 0 } } impl From < & PostProjectsDraftsBodyManualVerificationAddressesItem > for PostProjectsDraftsBodyManualVerificationAddressesItem { fn from (value : & PostProjectsDraftsBodyManualVerificationAddressesItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsDraftsBodyManualVerificationAddressesItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsDraftsBodyManualVerificationAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsDraftsBodyManualVerificationAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsDraftsBodyManualVerificationAddressesItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsDraftsBodyManualVerificationAddressesItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsDraftsBodyProjectDescription"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 1000"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsDraftsBodyProjectDescription (String) ; impl :: std :: ops :: Deref for PostProjectsDraftsBodyProjectDescription { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsDraftsBodyProjectDescription > for String { fn from (value : PostProjectsDraftsBodyProjectDescription) -> Self { value . 0 } } impl From < & PostProjectsDraftsBodyProjectDescription > for PostProjectsDraftsBodyProjectDescription { fn from (value : & PostProjectsDraftsBodyProjectDescription) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsDraftsBodyProjectDescription { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 1000usize { return Err ("longer than 1000 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsDraftsBodyProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsDraftsBodyProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsDraftsBodyProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsDraftsBodyProjectDescription { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsDraftsBodyProjectName"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsDraftsBodyProjectName (String) ; impl :: std :: ops :: Deref for PostProjectsDraftsBodyProjectName { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsDraftsBodyProjectName > for String { fn from (value : PostProjectsDraftsBodyProjectName) -> Self { value . 0 } } impl From < & PostProjectsDraftsBodyProjectName > for PostProjectsDraftsBodyProjectName { fn from (value : & PostProjectsDraftsBodyProjectName) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsDraftsBodyProjectName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsDraftsBodyProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsDraftsBodyProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsDraftsBodyProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsDraftsBodyProjectName { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsDraftsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"airtablePrefillUrl\","] # [doc = "    \"id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"airtablePrefillUrl\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsDraftsResponse { # [serde (rename = "airtablePrefillUrl")] pub airtable_prefill_url : String , pub id : uuid :: Uuid , } impl From < & PostProjectsDraftsResponse > for PostProjectsDraftsResponse { fn from (value : & PostProjectsDraftsResponse) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdIntegrationsPagerdutyBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"routing_key\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"enabled\": {"] # [doc = "      \"default\": true,"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"routing_key\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 32,"] # [doc = "      \"minLength\": 32,"] # [doc = "      \"pattern\": \"^[a-zA-Z0-9]{32}$\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdIntegrationsPagerdutyBody { # [serde (default = "defaults::default_bool::<true>")] pub enabled : bool , pub routing_key : PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey , } impl From < & PostProjectsProjectIdIntegrationsPagerdutyBody > for PostProjectsProjectIdIntegrationsPagerdutyBody { fn from (value : & PostProjectsProjectIdIntegrationsPagerdutyBody) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 32,"] # [doc = "  \"minLength\": 32,"] # [doc = "  \"pattern\": \"^[a-zA-Z0-9]{32}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey (String) ; impl :: std :: ops :: Deref for PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey > for String { fn from (value : PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey) -> Self { value . 0 } } impl From < & PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey > for PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey { fn from (value : & PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 32usize { return Err ("longer than 32 characters" . into ()) ; } if value . len () < 32usize { return Err ("shorter than 32 characters" . into ()) ; } if regress :: Regex :: new ("^[a-zA-Z0-9]{32}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^[a-zA-Z0-9]{32}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsProjectIdIntegrationsPagerdutyBodyRoutingKey { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsProjectIdIntegrationsPagerdutyResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"enabled\","] # [doc = "    \"last_updated\","] # [doc = "    \"message\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"enabled\": {"] # [doc = "      \"description\": \"Whether the integration is enabled\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"last_updated\": {"] # [doc = "      \"description\": \"Last update timestamp in ISO format\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"description\": \"Success message\","] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdIntegrationsPagerdutyResponse { # [doc = "Whether the integration is enabled"] pub enabled : bool , # [doc = "Last update timestamp in ISO format"] pub last_updated : String , # [doc = "Success message"] pub message : String , } impl From < & PostProjectsProjectIdIntegrationsPagerdutyResponse > for PostProjectsProjectIdIntegrationsPagerdutyResponse { fn from (value : & PostProjectsProjectIdIntegrationsPagerdutyResponse) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdIntegrationsPagerdutyTestResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"delivered\","] # [doc = "    \"message\","] # [doc = "    \"timestamp\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"delivered\": {"] # [doc = "      \"description\": \"Whether the test incident was successfully created in PagerDuty\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"description\": \"Success message\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"timestamp\": {"] # [doc = "      \"description\": \"Timestamp in ISO 8601 format\","] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdIntegrationsPagerdutyTestResponse { # [doc = "Whether the test incident was successfully created in PagerDuty"] pub delivered : bool , # [doc = "Success message"] pub message : String , # [doc = "Timestamp in ISO 8601 format"] pub timestamp : String , } impl From < & PostProjectsProjectIdIntegrationsPagerdutyTestResponse > for PostProjectsProjectIdIntegrationsPagerdutyTestResponse { fn from (value : & PostProjectsProjectIdIntegrationsPagerdutyTestResponse) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdIntegrationsSlackBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"webhook_url\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"enabled\": {"] # [doc = "      \"default\": true,"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"webhook_url\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 150,"] # [doc = "      \"pattern\": \"^https:\\\\/\\\\/hooks\\\\.slack\\\\.com\\\\/services\\\\/\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdIntegrationsSlackBody { # [serde (default = "defaults::default_bool::<true>")] pub enabled : bool , pub webhook_url : PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl , } impl From < & PostProjectsProjectIdIntegrationsSlackBody > for PostProjectsProjectIdIntegrationsSlackBody { fn from (value : & PostProjectsProjectIdIntegrationsSlackBody) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 150,"] # [doc = "  \"pattern\": \"^https:\\\\/\\\\/hooks\\\\.slack\\\\.com\\\\/services\\\\/\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl (String) ; impl :: std :: ops :: Deref for PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl > for String { fn from (value : PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl) -> Self { value . 0 } } impl From < & PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl > for PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl { fn from (value : & PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 150usize { return Err ("longer than 150 characters" . into ()) ; } if regress :: Regex :: new ("^https:\\/\\/hooks\\.slack\\.com\\/services\\/") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^https:\\/\\/hooks\\.slack\\.com\\/services\\/\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsProjectIdIntegrationsSlackBodyWebhookUrl { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsProjectIdIntegrationsSlackResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"enabled\","] # [doc = "    \"last_updated\","] # [doc = "    \"message\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"enabled\": {"] # [doc = "      \"description\": \"Whether the integration is enabled\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"last_updated\": {"] # [doc = "      \"description\": \"Last update timestamp in ISO format\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"description\": \"Success message\","] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdIntegrationsSlackResponse { # [doc = "Whether the integration is enabled"] pub enabled : bool , # [doc = "Last update timestamp in ISO format"] pub last_updated : String , # [doc = "Success message"] pub message : String , } impl From < & PostProjectsProjectIdIntegrationsSlackResponse > for PostProjectsProjectIdIntegrationsSlackResponse { fn from (value : & PostProjectsProjectIdIntegrationsSlackResponse) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdIntegrationsSlackTestResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"delivered\","] # [doc = "    \"message\","] # [doc = "    \"timestamp\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"delivered\": {"] # [doc = "      \"description\": \"Whether the test notification was delivered\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"description\": \"Success message\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"timestamp\": {"] # [doc = "      \"description\": \"Timestamp in ISO 8601 format\","] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdIntegrationsSlackTestResponse { # [doc = "Whether the test notification was delivered"] pub delivered : bool , # [doc = "Success message"] pub message : String , # [doc = "Timestamp in ISO 8601 format"] pub timestamp : String , } impl From < & PostProjectsProjectIdIntegrationsSlackTestResponse > for PostProjectsProjectIdIntegrationsSlackTestResponse { fn from (value : & PostProjectsProjectIdIntegrationsSlackTestResponse) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdReconcileBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"scopes\": {"] # [doc = "      \"default\": ["] # [doc = "        \"assertion_registrations\""] # [doc = "      ],"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"enum\": ["] # [doc = "          \"assertion_registrations\""] # [doc = "        ]"] # [doc = "      },"] # [doc = "      \"minItems\": 1"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdReconcileBody { # [serde (default = "defaults::post_projects_project_id_reconcile_body_scopes")] pub scopes : Vec < PostProjectsProjectIdReconcileBodyScopesItem > , } impl From < & PostProjectsProjectIdReconcileBody > for PostProjectsProjectIdReconcileBody { fn from (value : & PostProjectsProjectIdReconcileBody) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdReconcileBodyScopesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"assertion_registrations\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PostProjectsProjectIdReconcileBodyScopesItem { # [serde (rename = "assertion_registrations")] AssertionRegistrations , } impl From < & PostProjectsProjectIdReconcileBodyScopesItem > for PostProjectsProjectIdReconcileBodyScopesItem { fn from (value : & PostProjectsProjectIdReconcileBodyScopesItem) -> Self { value . clone () } } impl :: std :: fmt :: Display for PostProjectsProjectIdReconcileBodyScopesItem { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: AssertionRegistrations => write ! (f , "assertion_registrations") , } } } impl std :: str :: FromStr for PostProjectsProjectIdReconcileBodyScopesItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "assertion_registrations" => Ok (Self :: AssertionRegistrations) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PostProjectsProjectIdReconcileBodyScopesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostProjectsProjectIdReconcileBodyScopesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostProjectsProjectIdReconcileBodyScopesItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Reconciliation completed successfully"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Reconciliation completed successfully\","] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"created\","] # [doc = "    \"existing\","] # [doc = "    \"processed\","] # [doc = "    \"project_id\","] # [doc = "    \"run_at\","] # [doc = "    \"scopes\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"cleanup_job_ids\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"created\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"existing\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"processed\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"run_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"scopes\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"enum\": ["] # [doc = "          \"assertion_registrations\""] # [doc = "        ]"] # [doc = "      },"] # [doc = "      \"minItems\": 1"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdReconcileResponse { # [serde (default , skip_serializing_if = "Vec::is_empty")] pub cleanup_job_ids : Vec < String > , pub created : u64 , pub existing : u64 , pub processed : u64 , pub project_id : uuid :: Uuid , pub run_at : chrono :: DateTime < chrono :: offset :: Utc > , pub scopes : Vec < PostProjectsProjectIdReconcileResponseScopesItem > , } impl From < & PostProjectsProjectIdReconcileResponse > for PostProjectsProjectIdReconcileResponse { fn from (value : & PostProjectsProjectIdReconcileResponse) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdReconcileResponseScopesItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"assertion_registrations\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PostProjectsProjectIdReconcileResponseScopesItem { # [serde (rename = "assertion_registrations")] AssertionRegistrations , } impl From < & PostProjectsProjectIdReconcileResponseScopesItem > for PostProjectsProjectIdReconcileResponseScopesItem { fn from (value : & PostProjectsProjectIdReconcileResponseScopesItem) -> Self { value . clone () } } impl :: std :: fmt :: Display for PostProjectsProjectIdReconcileResponseScopesItem { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: AssertionRegistrations => write ! (f , "assertion_registrations") , } } } impl std :: str :: FromStr for PostProjectsProjectIdReconcileResponseScopesItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "assertion_registrations" => Ok (Self :: AssertionRegistrations) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PostProjectsProjectIdReconcileResponseScopesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostProjectsProjectIdReconcileResponseScopesItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostProjectsProjectIdReconcileResponseScopesItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "PostProjectsProjectIdRegisteredAssertionsBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertions\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_adopters\","] # [doc = "          \"assertion_id\","] # [doc = "          \"registered_address\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_adopters\": {"] # [doc = "            \"type\": \"array\","] # [doc = "            \"items\": {"] # [doc = "              \"oneOf\": ["] # [doc = "                {"] # [doc = "                  \"type\": \"object\","] # [doc = "                  \"required\": ["] # [doc = "                    \"id\""] # [doc = "                  ],"] # [doc = "                  \"properties\": {"] # [doc = "                    \"id\": {"] # [doc = "                      \"type\": \"string\""] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                },"] # [doc = "                {"] # [doc = "                  \"type\": \"object\","] # [doc = "                  \"required\": ["] # [doc = "                    \"address\""] # [doc = "                  ],"] # [doc = "                  \"properties\": {"] # [doc = "                    \"address\": {"] # [doc = "                      \"type\": \"string\","] # [doc = "                      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "                    },"] # [doc = "                    \"network\": {"] # [doc = "                      \"oneOf\": ["] # [doc = "                        {"] # [doc = "                          \"type\": \"string\""] # [doc = "                        },"] # [doc = "                        {"] # [doc = "                          \"type\": \"number\""] # [doc = "                        }"] # [doc = "                      ]"] # [doc = "                    }"] # [doc = "                  }"] # [doc = "                }"] # [doc = "              ]"] # [doc = "            }"] # [doc = "          },"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"registered_address\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"chainId\": {"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    },"] # [doc = "    \"environment\": {"] # [doc = "      \"default\": \"production\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"staging\","] # [doc = "        \"production\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"signature\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdRegisteredAssertionsBody { pub assertions : Vec < PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem > , # [serde (rename = "chainId" , default , skip_serializing_if = "Option::is_none")] pub chain_id : Option < std :: num :: NonZeroU64 > , # [serde (default = "defaults::post_projects_project_id_registered_assertions_body_environment")] pub environment : PostProjectsProjectIdRegisteredAssertionsBodyEnvironment , # [serde (default , skip_serializing_if = "Option::is_none")] pub signature : Option < String > , } impl From < & PostProjectsProjectIdRegisteredAssertionsBody > for PostProjectsProjectIdRegisteredAssertionsBody { fn from (value : & PostProjectsProjectIdRegisteredAssertionsBody) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopters\","] # [doc = "    \"assertion_id\","] # [doc = "    \"registered_address\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopters\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"oneOf\": ["] # [doc = "          {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"id\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"id\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          },"] # [doc = "          {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"network\": {"] # [doc = "                \"oneOf\": ["] # [doc = "                  {"] # [doc = "                    \"type\": \"string\""] # [doc = "                  },"] # [doc = "                  {"] # [doc = "                    \"type\": \"number\""] # [doc = "                  }"] # [doc = "                ]"] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        ]"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"registered_address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem { pub assertion_adopters : Vec < PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem > , pub assertion_id : String , pub registered_address : String , } impl From < & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem { fn from (value : & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"id\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"id\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"address\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"network\": {"] # [doc = "          \"oneOf\": ["] # [doc = "            {"] # [doc = "              \"type\": \"string\""] # [doc = "            },"] # [doc = "            {"] # [doc = "              \"type\": \"number\""] # [doc = "            }"] # [doc = "          ]"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem { Variant0 { id : String , } , Variant1 { address : PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address , # [serde (default , skip_serializing_if = "Option::is_none")] network : Option < PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network > , } , } impl From < & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem { fn from (value : & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address (String) ; impl :: std :: ops :: Deref for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address > for String { fn from (value : PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address) -> Self { value . 0 } } impl From < & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { fn from (value : & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { Variant0 (String) , Variant1 (f64) , } impl From < & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { fn from (value : & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network) -> Self { value . clone () } } impl std :: str :: FromStr for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } } impl std :: convert :: TryFrom < & str > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: fmt :: Display for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } } impl From < f64 > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { fn from (value : f64) -> Self { Self :: Variant1 (value) } } # [doc = "PostProjectsProjectIdRegisteredAssertionsBodyEnvironment"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"production\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"staging\","] # [doc = "    \"production\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PostProjectsProjectIdRegisteredAssertionsBodyEnvironment { # [serde (rename = "staging")] Staging , # [serde (rename = "production")] Production , } impl From < & PostProjectsProjectIdRegisteredAssertionsBodyEnvironment > for PostProjectsProjectIdRegisteredAssertionsBodyEnvironment { fn from (value : & PostProjectsProjectIdRegisteredAssertionsBodyEnvironment) -> Self { value . clone () } } impl :: std :: fmt :: Display for PostProjectsProjectIdRegisteredAssertionsBodyEnvironment { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Staging => write ! (f , "staging") , Self :: Production => write ! (f , "production") , } } } impl std :: str :: FromStr for PostProjectsProjectIdRegisteredAssertionsBodyEnvironment { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "staging" => Ok (Self :: Staging) , "production" => Ok (Self :: Production) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PostProjectsProjectIdRegisteredAssertionsBodyEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostProjectsProjectIdRegisteredAssertionsBodyEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostProjectsProjectIdRegisteredAssertionsBodyEnvironment { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl Default for PostProjectsProjectIdRegisteredAssertionsBodyEnvironment { fn default () -> Self { PostProjectsProjectIdRegisteredAssertionsBodyEnvironment :: Production } } # [doc = "PostProjectsProjectIdRegisteredAssertionsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdRegisteredAssertionsResponse { pub success : bool , } impl From < & PostProjectsProjectIdRegisteredAssertionsResponse > for PostProjectsProjectIdRegisteredAssertionsResponse { fn from (value : & PostProjectsProjectIdRegisteredAssertionsResponse) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdSubmittedAssertionsBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertions\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertions\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"object\","] # [doc = "        \"required\": ["] # [doc = "          \"assertion_id\","] # [doc = "          \"contract_name\","] # [doc = "          \"signature\""] # [doc = "        ],"] # [doc = "        \"properties\": {"] # [doc = "          \"assertion_id\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"bytecode\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"contract_name\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"signature\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          },"] # [doc = "          \"source_code\": {"] # [doc = "            \"type\": \"string\""] # [doc = "          }"] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdSubmittedAssertionsBody { pub assertions : Vec < PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem > , } impl From < & PostProjectsProjectIdSubmittedAssertionsBody > for PostProjectsProjectIdSubmittedAssertionsBody { fn from (value : & PostProjectsProjectIdSubmittedAssertionsBody) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_id\","] # [doc = "    \"contract_name\","] # [doc = "    \"signature\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"bytecode\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"contract_name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"signature\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"source_code\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem { pub assertion_id : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub bytecode : Option < String > , pub contract_name : String , pub signature : String , # [serde (default , skip_serializing_if = "Option::is_none")] pub source_code : Option < String > , } impl From < & PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem > for PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem { fn from (value : & PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem) -> Self { value . clone () } } # [doc = "PostProjectsProjectIdSubmittedAssertionsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsProjectIdSubmittedAssertionsResponse { pub success : bool , } impl From < & PostProjectsProjectIdSubmittedAssertionsResponse > for PostProjectsProjectIdSubmittedAssertionsResponse { fn from (value : & PostProjectsProjectIdSubmittedAssertionsResponse) -> Self { value . clone () } } # [doc = "PostProjectsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"created_at\","] # [doc = "    \"project_id\","] # [doc = "    \"project_manager\","] # [doc = "    \"project_name\","] # [doc = "    \"project_networks\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chain_names\": {"] # [doc = "      \"description\": \"Array of human-readable chain names that maps 1:1 with project_networks array\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"pending_verification_contracts\": {"] # [doc = "      \"description\": \"Array of contract addresses that have pending manual verification requests\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"project_description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 1000"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"project_manager\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    },"] # [doc = "    \"project_networks\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"integer\","] # [doc = "        \"exclusiveMinimum\": 0.0"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"saved_count\": {"] # [doc = "      \"default\": 0,"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsResponse { # [doc = "Array of human-readable chain names that maps 1:1 with project_networks array"] # [serde (default , skip_serializing_if = "Vec::is_empty")] pub chain_names : Vec < String > , pub created_at : chrono :: DateTime < chrono :: offset :: Utc > , # [doc = "Array of contract addresses that have pending manual verification requests"] # [serde (default , skip_serializing_if = "Vec::is_empty")] pub pending_verification_contracts : Vec < PostProjectsResponsePendingVerificationContractsItem > , # [serde (default , skip_serializing_if = "Option::is_none")] pub profile_image_url : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_description : Option < PostProjectsResponseProjectDescription > , pub project_id : uuid :: Uuid , pub project_manager : PostProjectsResponseProjectManager , pub project_name : PostProjectsResponseProjectName , pub project_networks : Vec < std :: num :: NonZeroU64 > , # [serde (default)] pub saved_count : u64 , } impl From < & PostProjectsResponse > for PostProjectsResponse { fn from (value : & PostProjectsResponse) -> Self { value . clone () } } # [doc = "PostProjectsResponsePendingVerificationContractsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsResponsePendingVerificationContractsItem (String) ; impl :: std :: ops :: Deref for PostProjectsResponsePendingVerificationContractsItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsResponsePendingVerificationContractsItem > for String { fn from (value : PostProjectsResponsePendingVerificationContractsItem) -> Self { value . 0 } } impl From < & PostProjectsResponsePendingVerificationContractsItem > for PostProjectsResponsePendingVerificationContractsItem { fn from (value : & PostProjectsResponsePendingVerificationContractsItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsResponsePendingVerificationContractsItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsResponsePendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsResponsePendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsResponsePendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsResponsePendingVerificationContractsItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsResponseProjectDescription"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 1000"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsResponseProjectDescription (String) ; impl :: std :: ops :: Deref for PostProjectsResponseProjectDescription { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsResponseProjectDescription > for String { fn from (value : PostProjectsResponseProjectDescription) -> Self { value . 0 } } impl From < & PostProjectsResponseProjectDescription > for PostProjectsResponseProjectDescription { fn from (value : & PostProjectsResponseProjectDescription) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsResponseProjectDescription { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 1000usize { return Err ("longer than 1000 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsResponseProjectDescription { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsResponseProjectManager"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsResponseProjectManager (String) ; impl :: std :: ops :: Deref for PostProjectsResponseProjectManager { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsResponseProjectManager > for String { fn from (value : PostProjectsResponseProjectManager) -> Self { value . 0 } } impl From < & PostProjectsResponseProjectManager > for PostProjectsResponseProjectManager { fn from (value : & PostProjectsResponseProjectManager) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsResponseProjectManager { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsResponseProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsResponseProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsResponseProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsResponseProjectManager { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsResponseProjectName"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostProjectsResponseProjectName (String) ; impl :: std :: ops :: Deref for PostProjectsResponseProjectName { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostProjectsResponseProjectName > for String { fn from (value : PostProjectsResponseProjectName) -> Self { value . 0 } } impl From < & PostProjectsResponseProjectName > for PostProjectsResponseProjectName { fn from (value : & PostProjectsResponseProjectName) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostProjectsResponseProjectName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostProjectsResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostProjectsResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostProjectsResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsResponseProjectName { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostProjectsSavedBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"project_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsSavedBody { pub project_id : uuid :: Uuid , } impl From < & PostProjectsSavedBody > for PostProjectsSavedBody { fn from (value : & PostProjectsSavedBody) -> Self { value . clone () } } # [doc = "PostProjectsSavedResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostProjectsSavedResponse { pub success : bool , } impl From < & PostProjectsSavedResponse > for PostProjectsSavedResponse { fn from (value : & PostProjectsSavedResponse) -> Self { value . clone () } } # [doc = "PostTracerEventsBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"duration_ms\": {"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"error_code\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"trace_content\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"trace_format\": {"] # [doc = "      \"default\": \"ansi\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"ansi\","] # [doc = "        \"plain\","] # [doc = "        \"json\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"tracer_metadata\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"additionalProperties\": {}"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostTracerEventsBody { # [serde (default , skip_serializing_if = "Option::is_none")] pub duration_ms : Option < i64 > , # [serde (default , skip_serializing_if = "Option::is_none")] pub error : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub error_code : Option < String > , pub success : bool , # [serde (default , skip_serializing_if = "Option::is_none")] pub trace_content : Option < String > , # [serde (default = "defaults::post_tracer_events_body_trace_format")] pub trace_format : PostTracerEventsBodyTraceFormat , # [serde (default , skip_serializing_if = "::serde_json::Map::is_empty")] pub tracer_metadata : :: serde_json :: Map < String , :: serde_json :: Value > , } impl From < & PostTracerEventsBody > for PostTracerEventsBody { fn from (value : & PostTracerEventsBody) -> Self { value . clone () } } # [doc = "PostTracerEventsBodyTraceFormat"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"default\": \"ansi\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"ansi\","] # [doc = "    \"plain\","] # [doc = "    \"json\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PostTracerEventsBodyTraceFormat { # [serde (rename = "ansi")] Ansi , # [serde (rename = "plain")] Plain , # [serde (rename = "json")] Json , } impl From < & PostTracerEventsBodyTraceFormat > for PostTracerEventsBodyTraceFormat { fn from (value : & PostTracerEventsBodyTraceFormat) -> Self { value . clone () } } impl :: std :: fmt :: Display for PostTracerEventsBodyTraceFormat { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Ansi => write ! (f , "ansi") , Self :: Plain => write ! (f , "plain") , Self :: Json => write ! (f , "json") , } } } impl std :: str :: FromStr for PostTracerEventsBodyTraceFormat { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "ansi" => Ok (Self :: Ansi) , "plain" => Ok (Self :: Plain) , "json" => Ok (Self :: Json) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PostTracerEventsBodyTraceFormat { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostTracerEventsBodyTraceFormat { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostTracerEventsBodyTraceFormat { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl Default for PostTracerEventsBodyTraceFormat { fn default () -> Self { PostTracerEventsBodyTraceFormat :: Ansi } } # [doc = "PostTracerEventsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\","] # [doc = "    \"timestamp\","] # [doc = "    \"tracking_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"timestamp\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"tracking_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostTracerEventsResponse { pub message : String , pub timestamp : String , pub tracking_id : String , } impl From < & PostTracerEventsResponse > for PostTracerEventsResponse { fn from (value : & PostTracerEventsResponse) -> Self { value . clone () } } # [doc = "PostTransfersAssertionAdoptersBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"assertion_adopter_address\","] # [doc = "    \"destination_project_id\","] # [doc = "    \"network\","] # [doc = "    \"recipient_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopter_address\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"destination_project_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"network\": {"] # [doc = "      \"oneOf\": ["] # [doc = "        {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"number\""] # [doc = "        }"] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"recipient_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostTransfersAssertionAdoptersBody { pub assertion_adopter_address : String , pub destination_project_id : String , pub network : PostTransfersAssertionAdoptersBodyNetwork , pub recipient_id : String , } impl From < & PostTransfersAssertionAdoptersBody > for PostTransfersAssertionAdoptersBody { fn from (value : & PostTransfersAssertionAdoptersBody) -> Self { value . clone () } } # [doc = "PostTransfersAssertionAdoptersBodyNetwork"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum PostTransfersAssertionAdoptersBodyNetwork { Variant0 (String) , Variant1 (f64) , } impl From < & PostTransfersAssertionAdoptersBodyNetwork > for PostTransfersAssertionAdoptersBodyNetwork { fn from (value : & PostTransfersAssertionAdoptersBodyNetwork) -> Self { value . clone () } } impl std :: str :: FromStr for PostTransfersAssertionAdoptersBodyNetwork { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } } impl std :: convert :: TryFrom < & str > for PostTransfersAssertionAdoptersBodyNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostTransfersAssertionAdoptersBodyNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostTransfersAssertionAdoptersBodyNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: fmt :: Display for PostTransfersAssertionAdoptersBodyNetwork { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } } impl From < f64 > for PostTransfersAssertionAdoptersBodyNetwork { fn from (value : f64) -> Self { Self :: Variant1 (value) } } # [doc = "PostTransfersAssertionAdoptersResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"transfer_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"transfer_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostTransfersAssertionAdoptersResponse { pub transfer_id : uuid :: Uuid , } impl From < & PostTransfersAssertionAdoptersResponse > for PostTransfersAssertionAdoptersResponse { fn from (value : & PostTransfersAssertionAdoptersResponse) -> Self { value . clone () } } # [doc = "PostTransfersBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"recipient_id\","] # [doc = "    \"resource_id\","] # [doc = "    \"resource_type\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"destination_project_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"network\": {"] # [doc = "      \"oneOf\": ["] # [doc = "        {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"number\""] # [doc = "        }"] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"recipient_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"resource_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"resource_type\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"project\","] # [doc = "        \"assertion_adopter\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostTransfersBody { # [serde (default , skip_serializing_if = "Option::is_none")] pub destination_project_id : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub network : Option < PostTransfersBodyNetwork > , pub recipient_id : String , pub resource_id : String , pub resource_type : PostTransfersBodyResourceType , } impl From < & PostTransfersBody > for PostTransfersBody { fn from (value : & PostTransfersBody) -> Self { value . clone () } } # [doc = "PostTransfersBodyNetwork"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"number\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum PostTransfersBodyNetwork { Variant0 (String) , Variant1 (f64) , } impl From < & PostTransfersBodyNetwork > for PostTransfersBodyNetwork { fn from (value : & PostTransfersBodyNetwork) -> Self { value . clone () } } impl std :: str :: FromStr for PostTransfersBodyNetwork { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } } impl std :: convert :: TryFrom < & str > for PostTransfersBodyNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostTransfersBodyNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostTransfersBodyNetwork { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: fmt :: Display for PostTransfersBodyNetwork { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } } impl From < f64 > for PostTransfersBodyNetwork { fn from (value : f64) -> Self { Self :: Variant1 (value) } } # [doc = "PostTransfersBodyResourceType"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"project\","] # [doc = "    \"assertion_adopter\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PostTransfersBodyResourceType { # [serde (rename = "project")] Project , # [serde (rename = "assertion_adopter")] AssertionAdopter , } impl From < & PostTransfersBodyResourceType > for PostTransfersBodyResourceType { fn from (value : & PostTransfersBodyResourceType) -> Self { value . clone () } } impl :: std :: fmt :: Display for PostTransfersBodyResourceType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Project => write ! (f , "project") , Self :: AssertionAdopter => write ! (f , "assertion_adopter") , } } } impl std :: str :: FromStr for PostTransfersBodyResourceType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "project" => Ok (Self :: Project) , "assertion_adopter" => Ok (Self :: AssertionAdopter) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PostTransfersBodyResourceType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostTransfersBodyResourceType { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostTransfersBodyResourceType { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "PostTransfersProjectsBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"project_id\","] # [doc = "    \"recipient_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"recipient_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostTransfersProjectsBody { pub project_id : uuid :: Uuid , pub recipient_id : PostTransfersProjectsBodyRecipientId , } impl From < & PostTransfersProjectsBody > for PostTransfersProjectsBody { fn from (value : & PostTransfersProjectsBody) -> Self { value . clone () } } # [doc = "PostTransfersProjectsBodyRecipientId"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostTransfersProjectsBodyRecipientId (String) ; impl :: std :: ops :: Deref for PostTransfersProjectsBodyRecipientId { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostTransfersProjectsBodyRecipientId > for String { fn from (value : PostTransfersProjectsBodyRecipientId) -> Self { value . 0 } } impl From < & PostTransfersProjectsBodyRecipientId > for PostTransfersProjectsBodyRecipientId { fn from (value : & PostTransfersProjectsBodyRecipientId) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostTransfersProjectsBodyRecipientId { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostTransfersProjectsBodyRecipientId { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostTransfersProjectsBodyRecipientId { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostTransfersProjectsBodyRecipientId { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostTransfersProjectsBodyRecipientId { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostTransfersProjectsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"transfer_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"transfer_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostTransfersProjectsResponse { pub transfer_id : uuid :: Uuid , } impl From < & PostTransfersProjectsResponse > for PostTransfersProjectsResponse { fn from (value : & PostTransfersProjectsResponse) -> Self { value . clone () } } # [doc = "PostTransfersResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"transfer_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"transfer_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostTransfersResponse { pub transfer_id : uuid :: Uuid , } impl From < & PostTransfersResponse > for PostTransfersResponse { fn from (value : & PostTransfersResponse) -> Self { value . clone () } } # [doc = "PostWebAuthAcceptTermsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\","] # [doc = "    \"terms_accepted_at\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"terms_accepted_at\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostWebAuthAcceptTermsResponse { pub success : bool , pub terms_accepted_at : String , } impl From < & PostWebAuthAcceptTermsResponse > for PostWebAuthAcceptTermsResponse { fn from (value : & PostWebAuthAcceptTermsResponse) -> Self { value . clone () } } # [doc = "PostWebAuthLogoutResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostWebAuthLogoutResponse { # [serde (default , skip_serializing_if = "Option::is_none")] pub message : Option < String > , pub success : bool , } impl From < & PostWebAuthLogoutResponse > for PostWebAuthLogoutResponse { fn from (value : & PostWebAuthLogoutResponse) -> Self { value . clone () } } # [doc = "PostWebAuthRefreshBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"refresh_token\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"refresh_token\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostWebAuthRefreshBody { pub refresh_token : String , } impl From < & PostWebAuthRefreshBody > for PostWebAuthRefreshBody { fn from (value : & PostWebAuthRefreshBody) -> Self { value . clone () } } # [doc = "PostWebAuthRefreshResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"access_token\","] # [doc = "    \"expires_in\","] # [doc = "    \"refresh_token\","] # [doc = "    \"token_type\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"access_token\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"expires_in\": {"] # [doc = "      \"type\": \"number\""] # [doc = "    },"] # [doc = "    \"refresh_token\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"token_type\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"Bearer\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostWebAuthRefreshResponse { pub access_token : String , pub expires_in : f64 , pub refresh_token : String , pub token_type : PostWebAuthRefreshResponseTokenType , } impl From < & PostWebAuthRefreshResponse > for PostWebAuthRefreshResponse { fn from (value : & PostWebAuthRefreshResponse) -> Self { value . clone () } } # [doc = "PostWebAuthRefreshResponseTokenType"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Bearer\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum PostWebAuthRefreshResponseTokenType { Bearer , } impl From < & PostWebAuthRefreshResponseTokenType > for PostWebAuthRefreshResponseTokenType { fn from (value : & PostWebAuthRefreshResponseTokenType) -> Self { value . clone () } } impl :: std :: fmt :: Display for PostWebAuthRefreshResponseTokenType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Bearer => write ! (f , "Bearer") , } } } impl std :: str :: FromStr for PostWebAuthRefreshResponseTokenType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "Bearer" => Ok (Self :: Bearer) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for PostWebAuthRefreshResponseTokenType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for PostWebAuthRefreshResponseTokenType { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for PostWebAuthRefreshResponseTokenType { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "PostWebAuthVerifyBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"message\","] # [doc = "    \"signature\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"message\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"signature\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostWebAuthVerifyBody { pub message : String , pub signature : String , } impl From < & PostWebAuthVerifyBody > for PostWebAuthVerifyBody { fn from (value : & PostWebAuthVerifyBody) -> Self { value . clone () } } # [doc = "PostWebAuthVerifyResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\","] # [doc = "    \"success\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"success\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostWebAuthVerifyResponse { pub address : PostWebAuthVerifyResponseAddress , pub success : bool , } impl From < & PostWebAuthVerifyResponse > for PostWebAuthVerifyResponse { fn from (value : & PostWebAuthVerifyResponse) -> Self { value . clone () } } # [doc = "PostWebAuthVerifyResponseAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostWebAuthVerifyResponseAddress (String) ; impl :: std :: ops :: Deref for PostWebAuthVerifyResponseAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostWebAuthVerifyResponseAddress > for String { fn from (value : PostWebAuthVerifyResponseAddress) -> Self { value . 0 } } impl From < & PostWebAuthVerifyResponseAddress > for PostWebAuthVerifyResponseAddress { fn from (value : & PostWebAuthVerifyResponseAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostWebAuthVerifyResponseAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostWebAuthVerifyResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostWebAuthVerifyResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostWebAuthVerifyResponseAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostWebAuthVerifyResponseAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostWebFaucetBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"address\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"address\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"amount\": {"] # [doc = "      \"type\": \"number\","] # [doc = "      \"exclusiveMinimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostWebFaucetBody { pub address : PostWebFaucetBodyAddress , # [serde (default , skip_serializing_if = "Option::is_none")] pub amount : Option < f64 > , } impl From < & PostWebFaucetBody > for PostWebFaucetBody { fn from (value : & PostWebFaucetBody) -> Self { value . clone () } } # [doc = "PostWebFaucetBodyAddress"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostWebFaucetBodyAddress (String) ; impl :: std :: ops :: Deref for PostWebFaucetBodyAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostWebFaucetBodyAddress > for String { fn from (value : PostWebFaucetBodyAddress) -> Self { value . 0 } } impl From < & PostWebFaucetBodyAddress > for PostWebFaucetBodyAddress { fn from (value : & PostWebFaucetBodyAddress) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostWebFaucetBodyAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostWebFaucetBodyAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostWebFaucetBodyAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostWebFaucetBodyAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostWebFaucetBodyAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostWebFaucetResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"amount\","] # [doc = "    \"recipient\","] # [doc = "    \"txHash\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"amount\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"recipient\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"txHash\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PostWebFaucetResponse { pub amount : String , pub recipient : PostWebFaucetResponseRecipient , # [serde (rename = "txHash")] pub tx_hash : PostWebFaucetResponseTxHash , } impl From < & PostWebFaucetResponse > for PostWebFaucetResponse { fn from (value : & PostWebFaucetResponse) -> Self { value . clone () } } # [doc = "PostWebFaucetResponseRecipient"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostWebFaucetResponseRecipient (String) ; impl :: std :: ops :: Deref for PostWebFaucetResponseRecipient { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostWebFaucetResponseRecipient > for String { fn from (value : PostWebFaucetResponseRecipient) -> Self { value . 0 } } impl From < & PostWebFaucetResponseRecipient > for PostWebFaucetResponseRecipient { fn from (value : & PostWebFaucetResponseRecipient) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostWebFaucetResponseRecipient { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostWebFaucetResponseRecipient { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostWebFaucetResponseRecipient { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostWebFaucetResponseRecipient { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostWebFaucetResponseRecipient { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PostWebFaucetResponseTxHash"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PostWebFaucetResponseTxHash (String) ; impl :: std :: ops :: Deref for PostWebFaucetResponseTxHash { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PostWebFaucetResponseTxHash > for String { fn from (value : PostWebFaucetResponseTxHash) -> Self { value . 0 } } impl From < & PostWebFaucetResponseTxHash > for PostWebFaucetResponseTxHash { fn from (value : & PostWebFaucetResponseTxHash) -> Self { value . clone () } } impl :: std :: str :: FromStr for PostWebFaucetResponseTxHash { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{64}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PostWebFaucetResponseTxHash { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PostWebFaucetResponseTxHash { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PostWebFaucetResponseTxHash { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PostWebFaucetResponseTxHash { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PutProjectsProjectIdBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"assertion_adopters\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"oneOf\": ["] # [doc = "          {"] # [doc = "            \"type\": \"string\","] # [doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "          },"] # [doc = "          {"] # [doc = "            \"type\": \"object\","] # [doc = "            \"required\": ["] # [doc = "              \"address\","] # [doc = "              \"network\""] # [doc = "            ],"] # [doc = "            \"properties\": {"] # [doc = "              \"address\": {"] # [doc = "                \"type\": \"string\","] # [doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "              },"] # [doc = "              \"contract_name\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              },"] # [doc = "              \"network\": {"] # [doc = "                \"type\": \"string\""] # [doc = "              }"] # [doc = "            }"] # [doc = "          }"] # [doc = "        ]"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"project_description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 1000"] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PutProjectsProjectIdBody { # [serde (default , skip_serializing_if = "Vec::is_empty")] pub assertion_adopters : Vec < PutProjectsProjectIdBodyAssertionAdoptersItem > , # [serde (default , skip_serializing_if = "Option::is_none")] pub profile_image_url : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_description : Option < PutProjectsProjectIdBodyProjectDescription > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_name : Option < PutProjectsProjectIdBodyProjectName > , } impl From < & PutProjectsProjectIdBody > for PutProjectsProjectIdBody { fn from (value : & PutProjectsProjectIdBody) -> Self { value . clone () } } # [doc = "PutProjectsProjectIdBodyAssertionAdoptersItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"address\","] # [doc = "        \"network\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"address\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "        },"] # [doc = "        \"contract_name\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"network\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      }"] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (untagged)] pub enum PutProjectsProjectIdBodyAssertionAdoptersItem { Variant0 (PutProjectsProjectIdBodyAssertionAdoptersItemVariant0) , Variant1 { address : PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address , # [serde (default , skip_serializing_if = "Option::is_none")] contract_name : Option < String > , network : String , } , } impl From < & PutProjectsProjectIdBodyAssertionAdoptersItem > for PutProjectsProjectIdBodyAssertionAdoptersItem { fn from (value : & PutProjectsProjectIdBodyAssertionAdoptersItem) -> Self { value . clone () } } impl From < PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 > for PutProjectsProjectIdBodyAssertionAdoptersItem { fn from (value : PutProjectsProjectIdBodyAssertionAdoptersItemVariant0) -> Self { Self :: Variant0 (value) } } # [doc = "PutProjectsProjectIdBodyAssertionAdoptersItemVariant0"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 (String) ; impl :: std :: ops :: Deref for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 > for String { fn from (value : PutProjectsProjectIdBodyAssertionAdoptersItemVariant0) -> Self { value . 0 } } impl From < & PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 > for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 { fn from (value : & PutProjectsProjectIdBodyAssertionAdoptersItemVariant0) -> Self { value . clone () } } impl :: std :: str :: FromStr for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address (String) ; impl :: std :: ops :: Deref for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address > for String { fn from (value : PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address) -> Self { value . 0 } } impl From < & PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address > for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address { fn from (value : & PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address) -> Self { value . clone () } } impl :: std :: str :: FromStr for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PutProjectsProjectIdBodyProjectDescription"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 1000"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PutProjectsProjectIdBodyProjectDescription (String) ; impl :: std :: ops :: Deref for PutProjectsProjectIdBodyProjectDescription { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PutProjectsProjectIdBodyProjectDescription > for String { fn from (value : PutProjectsProjectIdBodyProjectDescription) -> Self { value . 0 } } impl From < & PutProjectsProjectIdBodyProjectDescription > for PutProjectsProjectIdBodyProjectDescription { fn from (value : & PutProjectsProjectIdBodyProjectDescription) -> Self { value . clone () } } impl :: std :: str :: FromStr for PutProjectsProjectIdBodyProjectDescription { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 1000usize { return Err ("longer than 1000 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PutProjectsProjectIdBodyProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PutProjectsProjectIdBodyProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PutProjectsProjectIdBodyProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PutProjectsProjectIdBodyProjectDescription { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PutProjectsProjectIdBodyProjectName"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PutProjectsProjectIdBodyProjectName (String) ; impl :: std :: ops :: Deref for PutProjectsProjectIdBodyProjectName { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PutProjectsProjectIdBodyProjectName > for String { fn from (value : PutProjectsProjectIdBodyProjectName) -> Self { value . 0 } } impl From < & PutProjectsProjectIdBodyProjectName > for PutProjectsProjectIdBodyProjectName { fn from (value : & PutProjectsProjectIdBodyProjectName) -> Self { value . clone () } } impl :: std :: str :: FromStr for PutProjectsProjectIdBodyProjectName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PutProjectsProjectIdBodyProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PutProjectsProjectIdBodyProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PutProjectsProjectIdBodyProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PutProjectsProjectIdBodyProjectName { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PutProjectsProjectIdResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"created_at\","] # [doc = "    \"project_id\","] # [doc = "    \"project_manager\","] # [doc = "    \"project_name\","] # [doc = "    \"project_networks\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"chain_names\": {"] # [doc = "      \"description\": \"Array of human-readable chain names that maps 1:1 with project_networks array\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"created_at\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"pending_verification_contracts\": {"] # [doc = "      \"description\": \"Array of contract addresses that have pending manual verification requests\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"string\","] # [doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"profile_image_url\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"format\": \"uri\""] # [doc = "    },"] # [doc = "    \"project_description\": {"] # [doc = "      \"type\": ["] # [doc = "        \"string\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maxLength\": 1000"] # [doc = "    },"] # [doc = "    \"project_id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"project_manager\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "    },"] # [doc = "    \"project_name\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    },"] # [doc = "    \"project_networks\": {"] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"type\": \"integer\","] # [doc = "        \"exclusiveMinimum\": 0.0"] # [doc = "      }"] # [doc = "    },"] # [doc = "    \"saved_count\": {"] # [doc = "      \"default\": 0,"] # [doc = "      \"type\": \"integer\","] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct PutProjectsProjectIdResponse { # [doc = "Array of human-readable chain names that maps 1:1 with project_networks array"] # [serde (default , skip_serializing_if = "Vec::is_empty")] pub chain_names : Vec < String > , pub created_at : chrono :: DateTime < chrono :: offset :: Utc > , # [doc = "Array of contract addresses that have pending manual verification requests"] # [serde (default , skip_serializing_if = "Vec::is_empty")] pub pending_verification_contracts : Vec < PutProjectsProjectIdResponsePendingVerificationContractsItem > , # [serde (default , skip_serializing_if = "Option::is_none")] pub profile_image_url : Option < String > , # [serde (default , skip_serializing_if = "Option::is_none")] pub project_description : Option < PutProjectsProjectIdResponseProjectDescription > , pub project_id : uuid :: Uuid , pub project_manager : PutProjectsProjectIdResponseProjectManager , pub project_name : PutProjectsProjectIdResponseProjectName , pub project_networks : Vec < std :: num :: NonZeroU64 > , # [serde (default)] pub saved_count : u64 , } impl From < & PutProjectsProjectIdResponse > for PutProjectsProjectIdResponse { fn from (value : & PutProjectsProjectIdResponse) -> Self { value . clone () } } # [doc = "PutProjectsProjectIdResponsePendingVerificationContractsItem"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PutProjectsProjectIdResponsePendingVerificationContractsItem (String) ; impl :: std :: ops :: Deref for PutProjectsProjectIdResponsePendingVerificationContractsItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PutProjectsProjectIdResponsePendingVerificationContractsItem > for String { fn from (value : PutProjectsProjectIdResponsePendingVerificationContractsItem) -> Self { value . 0 } } impl From < & PutProjectsProjectIdResponsePendingVerificationContractsItem > for PutProjectsProjectIdResponsePendingVerificationContractsItem { fn from (value : & PutProjectsProjectIdResponsePendingVerificationContractsItem) -> Self { value . clone () } } impl :: std :: str :: FromStr for PutProjectsProjectIdResponsePendingVerificationContractsItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PutProjectsProjectIdResponsePendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PutProjectsProjectIdResponsePendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PutProjectsProjectIdResponsePendingVerificationContractsItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PutProjectsProjectIdResponsePendingVerificationContractsItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PutProjectsProjectIdResponseProjectDescription"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 1000"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PutProjectsProjectIdResponseProjectDescription (String) ; impl :: std :: ops :: Deref for PutProjectsProjectIdResponseProjectDescription { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PutProjectsProjectIdResponseProjectDescription > for String { fn from (value : PutProjectsProjectIdResponseProjectDescription) -> Self { value . 0 } } impl From < & PutProjectsProjectIdResponseProjectDescription > for PutProjectsProjectIdResponseProjectDescription { fn from (value : & PutProjectsProjectIdResponseProjectDescription) -> Self { value . clone () } } impl :: std :: str :: FromStr for PutProjectsProjectIdResponseProjectDescription { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 1000usize { return Err ("longer than 1000 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PutProjectsProjectIdResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PutProjectsProjectIdResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PutProjectsProjectIdResponseProjectDescription { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PutProjectsProjectIdResponseProjectDescription { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PutProjectsProjectIdResponseProjectManager"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PutProjectsProjectIdResponseProjectManager (String) ; impl :: std :: ops :: Deref for PutProjectsProjectIdResponseProjectManager { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PutProjectsProjectIdResponseProjectManager > for String { fn from (value : PutProjectsProjectIdResponseProjectManager) -> Self { value . 0 } } impl From < & PutProjectsProjectIdResponseProjectManager > for PutProjectsProjectIdResponseProjectManager { fn from (value : & PutProjectsProjectIdResponseProjectManager) -> Self { value . clone () } } impl :: std :: str :: FromStr for PutProjectsProjectIdResponseProjectManager { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PutProjectsProjectIdResponseProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PutProjectsProjectIdResponseProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PutProjectsProjectIdResponseProjectManager { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PutProjectsProjectIdResponseProjectManager { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "PutProjectsProjectIdResponseProjectName"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct PutProjectsProjectIdResponseProjectName (String) ; impl :: std :: ops :: Deref for PutProjectsProjectIdResponseProjectName { type Target = String ; fn deref (& self) -> & String { & self . 0 } } impl From < PutProjectsProjectIdResponseProjectName > for String { fn from (value : PutProjectsProjectIdResponseProjectName) -> Self { value . 0 } } impl From < & PutProjectsProjectIdResponseProjectName > for PutProjectsProjectIdResponseProjectName { fn from (value : & PutProjectsProjectIdResponseProjectName) -> Self { value . clone () } } impl :: std :: str :: FromStr for PutProjectsProjectIdResponseProjectName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if value . len () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . len () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PutProjectsProjectIdResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & String > for PutProjectsProjectIdResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < String > for PutProjectsProjectIdResponseProjectName { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PutProjectsProjectIdResponseProjectName { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = r" Generation of default values for serde."] pub mod defaults { pub (super) fn default_bool < const V : bool > () -> bool { V } pub (super) fn post_calldata_batch_register_body_environment () -> super :: PostCalldataBatchRegisterBodyEnvironment { super :: PostCalldataBatchRegisterBodyEnvironment :: Production } pub (super) fn post_projects_project_id_reconcile_body_scopes () -> Vec < super :: PostProjectsProjectIdReconcileBodyScopesItem > { vec ! [super :: PostProjectsProjectIdReconcileBodyScopesItem :: AssertionRegistrations] } pub (super) fn post_projects_project_id_registered_assertions_body_environment () -> super :: PostProjectsProjectIdRegisteredAssertionsBodyEnvironment { super :: PostProjectsProjectIdRegisteredAssertionsBodyEnvironment :: Production } pub (super) fn post_tracer_events_body_trace_format () -> super :: PostTracerEventsBodyTraceFormat { super :: PostTracerEventsBodyTraceFormat :: Ansi } } } # [derive (Clone , Debug)] # [doc = "Client for Phylax Credible Layer API\n\nAPI for managing projects, assertions, and smart contracts.\n\n## Authentication\n\nThis API supports dual authentication modes:\n\n### 1. Bearer Token Authentication (CLI)\nFor CLI clients, use JWT Bearer tokens in the Authorization header:\n```http\nAuthorization: Bearer <jwt_token>\n```\n\n### 2. Cookie Authentication (Web)\nFor web clients, authentication is handled via secure HTTP-only cookies (iron-session).\nNo Authorization header is needed when using cookie authentication.\n\n### Endpoint Authentication\n- Most endpoints accept both authentication methods\n- Optional Authorization headers in the API spec indicate dual authentication support\n- Required Authorization headers indicate CLI-only endpoints\n- The authentication middleware automatically detects and validates the appropriate method\n\nVersion: 1.0.0"] pub struct Client { pub (crate) baseurl : String , pub (crate) client : reqwest :: Client , } impl Client { # [doc = r" Create a new client."] # [doc = r""] # [doc = r" `baseurl` is the base URL provided to the internal"] # [doc = r" `reqwest::Client`, and should include a scheme and hostname,"] # [doc = r" as well as port and a path stem if applicable."] pub fn new (baseurl : & str ,) -> Self { # [cfg (not (target_arch = "wasm32"))] let client = { let dur = std :: time :: Duration :: from_secs (15) ; reqwest :: ClientBuilder :: new () . connect_timeout (dur) . timeout (dur) } ; # [cfg (target_arch = "wasm32")] let client = reqwest :: ClientBuilder :: new () ; Self :: new_with_client (baseurl , client . build () . unwrap () ,) } # [doc = r" Construct a new client with an existing `reqwest::Client`,"] # [doc = r" allowing more control over its configuration."] # [doc = r""] # [doc = r" `baseurl` is the base URL provided to the internal"] # [doc = r" `reqwest::Client`, and should include a scheme and hostname,"] # [doc = r" as well as port and a path stem if applicable."] pub fn new_with_client (baseurl : & str , client : reqwest :: Client ,) -> Self { Self { baseurl : baseurl . to_string () , client , } } # [doc = r" Get the base URL to which requests are made."] pub fn baseurl (& self) -> & String { & self . baseurl } # [doc = r" Get the internal `reqwest::Client` used to make requests."] pub fn client (& self) -> & reqwest :: Client { & self . client } # [doc = r" Get the version of this API."] # [doc = r""] # [doc = r" This string is pulled directly from the source OpenAPI"] # [doc = r" document and may be in any format the API selects."] pub fn api_version (& self) -> & 'static str { "1.0.0" } } # [allow (clippy :: all)] impl Client { # [doc = "Get assertion adopters\n\nGet assertion adopters filtered by project or address\n\nSends a `GET` request to `/assertion_adopters`\n\n"] pub async fn get_assertion_adopters < 'a > (& 'a self , address : Option < & 'a types :: GetAssertionAdoptersAddress > , network : Option < & 'a types :: GetAssertionAdoptersNetwork > , project_id : Option < & 'a uuid :: Uuid >) -> Result < ResponseValue < Vec < types :: GetAssertionAdoptersResponseItem > > , Error < types :: GetAssertionAdoptersResponse > , > { let url = format ! ("{}/assertion_adopters" , self . baseurl ,) ; let mut query = Vec :: with_capacity (3usize) ; if let Some (v) = & address { query . push (("address" , v . to_string ())) ; } if let Some (v) = & network { query . push (("network" , v . to_string ())) ; } if let Some (v) = & project_id { query . push (("project_id" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Assign adopters to project\n\nAssign one or more assertion adopters to a project\n\nSends a `POST` request to `/assertion_adopters/assign-project`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn post_assertion_adopters_assign_project < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a types :: PostAssertionAdoptersAssignProjectBody) -> Result < ResponseValue < types :: PostAssertionAdoptersAssignProjectResponse > , Error < types :: PostAssertionAdoptersAssignProjectResponse > , > { let url = format ! ("{}/assertion_adopters/assign-project" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get unassigned adopters\n\nGet assertion adopters not assigned to any project\n\nSends a `GET` request to `/assertion_adopters/no-project`\n\n"] pub async fn get_assertion_adopters_no_project < 'a > (& 'a self , manager : & 'a types :: GetAssertionAdoptersNoProjectManager) -> Result < ResponseValue < Vec < types :: GetAssertionAdoptersNoProjectResponseItem > > , Error < types :: GetAssertionAdoptersNoProjectResponse > , > { let url = format ! ("{}/assertion_adopters/no-project" , self . baseurl ,) ; let mut query = Vec :: with_capacity (1usize) ; query . push (("manager" , manager . to_string ())) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Remove assertion from adopter\n\nRemove a specific assertion from an assertion adopter\n\nSends a `DELETE` request to `/assertion_adopters/{aa_address}/assertions/{assertion_id}`\n\n"] pub async fn delete_assertion_adopters_aa_address_assertions_assertion_id < 'a > (& 'a self , aa_address : & 'a types :: DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress , assertion_id : & 'a types :: DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId , network : Option < & 'a types :: DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork > , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse > , Error < types :: DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse > , > { let url = format ! ("{}/assertion_adopters/{}/assertions/{}" , self . baseurl , encode_path (& aa_address . to_string ()) , encode_path (& assertion_id . to_string ()) ,) ; let mut query = Vec :: with_capacity (1usize) ; if let Some (v) = & network { query . push (("network" , v . to_string ())) ; } let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . delete (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Generate remove assertions calldata\n\nGenerate calldata for removing all assertions from an adopter\n\nSends a `GET` request to `/assertion_adopters/{aa_address}/remove-assertions-calldata`\n\n"] pub async fn get_assertion_adopters_aa_address_remove_assertions_calldata < 'a > (& 'a self , aa_address : & 'a types :: GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress , network : Option < & 'a types :: GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork >) -> Result < ResponseValue < types :: GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse > , Error < types :: GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse > , > { let url = format ! ("{}/assertion_adopters/{}/remove-assertions-calldata" , self . baseurl , encode_path (& aa_address . to_string ()) ,) ; let mut query = Vec :: with_capacity (1usize) ; if let Some (v) = & network { query . push (("network" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get assertions by adopter\n\nGet all assertions for a specific assertion adopter. Use include_onchain_only=true to filter by on-chain presence.\n\nSends a `GET` request to `/assertions`\n\n"] pub async fn get_assertions < 'a > (& 'a self , adopter_address : & 'a types :: GetAssertionsAdopterAddress , environment : Option < types :: GetAssertionsEnvironment > , include_onchain_only : Option < bool > , network : Option < & 'a types :: GetAssertionsNetwork >) -> Result < ResponseValue < types :: GetAssertionsResponse > , Error < types :: GetAssertionsResponse > , > { let url = format ! ("{}/assertions" , self . baseurl ,) ; let mut query = Vec :: with_capacity (4usize) ; query . push (("adopter_address" , adopter_address . to_string ())) ; if let Some (v) = & environment { query . push (("environment" , v . to_string ())) ; } if let Some (v) = & include_onchain_only { query . push (("include_onchain_only" , v . to_string ())) ; } if let Some (v) = & network { query . push (("network" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Confirm promotion of assertions\n\nConfirm that assertions have been promoted from staging to production and trigger cleanup.\n\nSends a `POST` request to `/assertions/confirm-promotion`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn post_assertions_confirm_promotion < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a types :: PostAssertionsConfirmPromotionBody) -> Result < ResponseValue < types :: PostAssertionsConfirmPromotionResponse > , Error < types :: PostAssertionsConfirmPromotionResponse > , > { let url = format ! ("{}/assertions/confirm-promotion" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Generate batch promote calldata\n\nGenerate calldata for promoting assertions from staging to production StateOracle. Validates assertions exist in staging and not in production before generating calldata.\n\nSends a `POST` request to `/calldata/batch-promote`\n\nArguments:\n- `body`: Body\n"] pub async fn post_calldata_batch_promote < 'a > (& 'a self , body : & 'a types :: PostCalldataBatchPromoteBody) -> Result < ResponseValue < types :: PostCalldataBatchPromoteResponse > , Error < types :: PostCalldataBatchPromoteResponse > , > { let url = format ! ("{}/calldata/batch-promote" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Generate batch register calldata\n\nGenerate optimized calldata for registering assertions and assertion adopters\n\nSends a `POST` request to `/calldata/batch-register`\n\nArguments:\n- `body`: Body\n"] pub async fn post_calldata_batch_register < 'a > (& 'a self , body : & 'a types :: PostCalldataBatchRegisterBody) -> Result < ResponseValue < types :: PostCalldataBatchRegisterResponse > , Error < types :: PostCalldataBatchRegisterResponse > , > { let url = format ! ("{}/calldata/batch-register" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Request OTP code\n\nRequest a 6-digit OTP code for CLI authentication\n\nSends a `GET` request to `/cli/auth/code`\n\n"] pub async fn get_cli_auth_code < 'a > (& 'a self ,) -> Result < ResponseValue < types :: GetCliAuthCodeResponse > , Error < types :: GetCliAuthCodeResponse > , > { let url = format ! ("{}/cli/auth/code" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Refresh access token\n\nRefresh JWT access token using refresh token\n\nSends a `POST` request to `/cli/auth/refresh`\n\nArguments:\n- `body`: Body\n"] pub async fn post_cli_auth_refresh < 'a > (& 'a self , body : & 'a types :: PostCliAuthRefreshBody) -> Result < ResponseValue < types :: PostCliAuthRefreshResponse > , Error < types :: PostCliAuthRefreshResponse > , > { let url = format ! ("{}/cli/auth/refresh" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Check OTP status\n\nCheck the status of an OTP request and get tokens if verified\n\nSends a `GET` request to `/cli/auth/status`\n\n"] pub async fn get_cli_auth_status < 'a > (& 'a self , device_secret : & 'a str , session_id : & 'a uuid :: Uuid) -> Result < ResponseValue < types :: GetCliAuthStatusResponse > , Error < types :: GetCliAuthStatusResponse > , > { let url = format ! ("{}/cli/auth/status" , self . baseurl ,) ; let mut query = Vec :: with_capacity (2usize) ; query . push (("device_secret" , device_secret . to_string ())) ; query . push (("session_id" , session_id . to_string ())) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Verify OTP code\n\nVerify the 6-digit OTP code and get access tokens\n\nSends a `POST` request to `/cli/auth/verify`\n\nArguments:\n- `body`: Body\n"] pub async fn post_cli_auth_verify < 'a > (& 'a self , body : & 'a types :: PostCliAuthVerifyBody) -> Result < ResponseValue < types :: PostCliAuthVerifyResponse > , Error < types :: PostCliAuthVerifyResponse > , > { let url = format ! ("{}/cli/auth/verify" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Submit invalidation incident\n\nReport an invalidating transaction to the Credible Layer dApp. Returns immediately with a tracking ID.\n\nSends a `POST` request to `/enforcer/incidents`\n\nArguments:\n- `x_api_key`\n- `body`: Body\n"] pub async fn post_enforcer_incidents < 'a > (& 'a self , x_api_key : Option < & 'a str > , body : & 'a types :: PostEnforcerIncidentsBody) -> Result < ResponseValue < types :: PostEnforcerIncidentsResponse > , Error < types :: PostEnforcerIncidentsResponse > , > { let url = format ! ("{}/enforcer/incidents" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = x_api_key { header_map . append ("x-api-key" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 202u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Report enforcer network health status\n\nAccepts network-level health status updates from authenticated enforcers\n\nSends a `POST` request to `/enforcer/network-status`\n\nArguments:\n- `x_api_key`\n- `body`: Body\n"] pub async fn post_enforcer_network_status < 'a > (& 'a self , x_api_key : Option < & 'a str > , body : & 'a types :: PostEnforcerNetworkStatusBody) -> Result < ResponseValue < types :: PostEnforcerNetworkStatusResponse > , Error < types :: PostEnforcerNetworkStatusResponse > , > { let url = format ! ("{}/enforcer/network-status" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = x_api_key { header_map . append ("x-api-key" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 202u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Health check\n\nCheck API health status\n\nSends a `GET` request to `/health`\n\n"] pub async fn get_health < 'a > (& 'a self ,) -> Result < ResponseValue < types :: GetHealthResponse > , Error < () > , > { let url = format ! ("{}/health" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get incident details\n\nRetrieve detailed information about a specific incident including nested transactions and traces\n\nSends a `GET` request to `/incidents/{incident_id}`\n\n"] pub async fn get_incidents_incident_id < 'a > (& 'a self , incident_id : & 'a uuid :: Uuid) -> Result < ResponseValue < types :: GetIncidentsIncidentIdResponse > , Error < types :: GetIncidentsIncidentIdResponse > , > { let url = format ! ("{}/incidents/{}" , self . baseurl , encode_path (& incident_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get debug trace for a transaction\n\nRetrieve the debug trace content for a specific invalidating transaction\n\nSends a `GET` request to `/incidents/{incident_id}/transactions/{tx_id}/trace`\n\n"] pub async fn get_incidents_incident_id_transactions_tx_id_trace < 'a > (& 'a self , incident_id : & 'a uuid :: Uuid , tx_id : & 'a uuid :: Uuid) -> Result < ResponseValue < types :: GetIncidentsIncidentIdTransactionsTxIdTraceResponse > , Error < types :: GetIncidentsIncidentIdTransactionsTxIdTraceResponse > , > { let url = format ! ("{}/incidents/{}/transactions/{}/trace" , self . baseurl , encode_path (& incident_id . to_string ()) , encode_path (& tx_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get manual verification request by Airtable record ID\n\nRetrieve manual verification request details by Airtable record ID. Returns full details for authenticated users matching requested_by, minimal public data otherwise.\n\nSends a `GET` request to `/manual-verification/requests/{airtable_record_id}`\n\n"] pub async fn get_manual_verification_requests_airtable_record_id < 'a > (& 'a self , airtable_record_id : & 'a types :: GetManualVerificationRequestsAirtableRecordIdAirtableRecordId , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: GetManualVerificationRequestsAirtableRecordIdResponse > , Error < types :: GetManualVerificationRequestsAirtableRecordIdResponse > , > { let url = format ! ("{}/manual-verification/requests/{}" , self . baseurl , encode_path (& airtable_record_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get Airtable status and signature eligibility for manual verification request\n\nChecks the current status from Airtable and determines if the request is eligible for signature workflow. Does not require authentication - public endpoint for status checking.\n\nSends a `GET` request to `/manual-verification/requests/{airtable_record_id}/status`\n\n"] pub async fn get_manual_verification_requests_airtable_record_id_status < 'a > (& 'a self , airtable_record_id : & 'a types :: GetManualVerificationRequestsAirtableRecordIdStatusAirtableRecordId) -> Result < ResponseValue < types :: GetManualVerificationRequestsAirtableRecordIdStatusResponse > , Error < types :: GetManualVerificationRequestsAirtableRecordIdStatusResponse > , > { let url = format ! ("{}/manual-verification/requests/{}/status" , self . baseurl , encode_path (& airtable_record_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Prepare signature for manual verification request\n\nGenerates a nonce and canonical message for the user to sign. Requires authentication and request ownership. Returns the message to sign along with nonce and expiry.\n\nSends a `POST` request to `/manual-verification/requests/{id}/signature/prepare`\n\nArguments:\n- `id`\n- `authorization`\n- `body`: Body\n"] pub async fn post_manual_verification_requests_id_signature_prepare < 'a > (& 'a self , id : & 'a uuid :: Uuid , authorization : Option < & 'a str > , body : & 'a :: serde_json :: Map < String , :: serde_json :: Value >) -> Result < ResponseValue < types :: PostManualVerificationRequestsIdSignaturePrepareResponse > , Error < types :: PostManualVerificationRequestsIdSignaturePrepareResponse > , > { let url = format ! ("{}/manual-verification/requests/{}/signature/prepare" , self . baseurl , encode_path (& id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 409u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Verify signature for manual verification request\n\nValidates the provided signature against the canonical message. Requires authentication and request ownership. Verifies signature cryptographically using viem and stores results.\n\nSends a `POST` request to `/manual-verification/requests/{id}/signature/verify`\n\nArguments:\n- `id`\n- `authorization`\n- `body`: Body\n"] pub async fn post_manual_verification_requests_id_signature_verify < 'a > (& 'a self , id : & 'a uuid :: Uuid , authorization : Option < & 'a str > , body : & 'a types :: PostManualVerificationRequestsIdSignatureVerifyBody) -> Result < ResponseValue < types :: PostManualVerificationRequestsIdSignatureVerifyResponse > , Error < types :: PostManualVerificationRequestsIdSignatureVerifyResponse > , > { let url = format ! ("{}/manual-verification/requests/{}/signature/verify" , self . baseurl , encode_path (& id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 409u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "OpenAPI specification\n\nGet the OpenAPI specification for the API\n\nSends a `GET` request to `/openapi`\n\n"] pub async fn get_openapi < 'a > (& 'a self ,) -> Result < ResponseValue < :: serde_json :: Value > , Error < types :: GetOpenapiResponse > , > { let url = format ! ("{}/openapi" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get all projects\n\nGet all projects with optional filtering\n\nSends a `GET` request to `/projects`\n\n"] pub async fn get_projects < 'a > (& 'a self , network_id : Option < f64 > , user : Option < & 'a types :: GetProjectsUser > , with_assertions_only : Option < bool >) -> Result < ResponseValue < Vec < types :: GetProjectsResponseItem > > , Error < types :: GetProjectsResponse > , > { let url = format ! ("{}/projects" , self . baseurl ,) ; let mut query = Vec :: with_capacity (3usize) ; if let Some (v) = & network_id { query . push (("network_id" , v . to_string ())) ; } if let Some (v) = & user { query . push (("user" , v . to_string ())) ; } if let Some (v) = & with_assertions_only { query . push (("with_assertions_only" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Create a project\n\nCreate a new project with optional assertion adopters\n\nSends a `POST` request to `/projects`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn post_projects < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a types :: PostProjectsBody) -> Result < ResponseValue < types :: PostProjectsResponse > , Error < types :: PostProjectsResponse > , > { let url = format ! ("{}/projects" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Create or update a project draft\n\nCreate a new project draft or update an existing one for the authenticated user. Returns the draft ID and Airtable prefill URL.\n\nSends a `POST` request to `/projects/drafts`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn post_projects_drafts < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a types :: PostProjectsDraftsBody) -> Result < ResponseValue < types :: PostProjectsDraftsResponse > , Error < types :: PostProjectsDraftsResponse > , > { let url = format ! ("{}/projects/drafts" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get project draft by ID\n\nGet detailed information about a specific project draft\n\nSends a `GET` request to `/projects/drafts/{id}`\n\n"] pub async fn get_projects_drafts_id < 'a > (& 'a self , id : & 'a uuid :: Uuid , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: GetProjectsDraftsIdResponse > , Error < types :: GetProjectsDraftsIdResponse > , > { let url = format ! ("{}/projects/drafts/{}" , self . baseurl , encode_path (& id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get saved projects\n\nGet all projects saved by a wallet address\n\nSends a `GET` request to `/projects/saved`\n\n"] pub async fn get_projects_saved < 'a > (& 'a self , wallet_address : & 'a str) -> Result < ResponseValue < Vec < types :: GetProjectsSavedResponseItem > > , Error < types :: GetProjectsSavedResponse > , > { let url = format ! ("{}/projects/saved" , self . baseurl ,) ; let mut query = Vec :: with_capacity (1usize) ; query . push (("wallet_address" , wallet_address . to_string ())) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Save a project\n\nSave a project to the authenticated user's saved projects\n\nSends a `POST` request to `/projects/saved`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn post_projects_saved < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a types :: PostProjectsSavedBody) -> Result < ResponseValue < types :: PostProjectsSavedResponse > , Error < types :: PostProjectsSavedResponse > , > { let url = format ! ("{}/projects/saved" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 409u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Unsave a project\n\nRemove a project from the authenticated user's saved projects\n\nSends a `DELETE` request to `/projects/saved`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn delete_projects_saved < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a types :: DeleteProjectsSavedBody) -> Result < ResponseValue < types :: DeleteProjectsSavedResponse > , Error < types :: DeleteProjectsSavedResponse > , > { let url = format ! ("{}/projects/saved" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . delete (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get project by ID\n\nGet detailed information about a specific project\n\nSends a `GET` request to `/projects/{project_id}`\n\n"] pub async fn get_projects_project_id < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , include : Option < & 'a str >) -> Result < ResponseValue < types :: GetProjectsProjectIdResponse > , Error < types :: GetProjectsProjectIdResponse > , > { let url = format ! ("{}/projects/{}" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut query = Vec :: with_capacity (1usize) ; if let Some (v) = & include { query . push (("include" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Update project\n\nUpdate project details\n\nSends a `PUT` request to `/projects/{project_id}`\n\nArguments:\n- `project_id`\n- `authorization`\n- `body`: Body\n"] pub async fn put_projects_project_id < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , authorization : Option < & 'a str > , body : & 'a types :: PutProjectsProjectIdBody) -> Result < ResponseValue < types :: PutProjectsProjectIdResponse > , Error < types :: PutProjectsProjectIdResponse > , > { let url = format ! ("{}/projects/{}" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . put (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Delete project\n\nDelete a project and all associated data\n\nSends a `DELETE` request to `/projects/{project_id}`\n\n"] pub async fn delete_projects_project_id < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: DeleteProjectsProjectIdResponse > , Error < types :: DeleteProjectsProjectIdResponse > , > { let url = format ! ("{}/projects/{}" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . delete (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get project events\n\nGet all events (database + blockchain) for a specific project. Private events are only included if the user is authenticated and owns the project.\n\nSends a `GET` request to `/projects/{project_id}/events`\n\nArguments:\n- `project_id`: Project UUID to fetch events for\n- `authorization`\n"] pub async fn get_projects_project_id_events < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: GetProjectsProjectIdEventsResponse > , Error < types :: GetProjectsProjectIdEventsResponse > , > { let url = format ! ("{}/projects/{}/events" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get project incidents\n\nRetrieve a paginated list of incidents for a specific project with transaction and trace aggregates\n\nSends a `GET` request to `/projects/{project_id}/incidents`\n\n"] pub async fn get_projects_project_id_incidents < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , assertion_adopter_id : Option < & 'a str > , assertion_id : Option < & 'a str > , environment : Option < types :: GetProjectsProjectIdIncidentsEnvironment > , from_date : Option < & 'a chrono :: DateTime < chrono :: offset :: Utc > > , limit : Option < i64 > , page : Option < std :: num :: NonZeroU64 > , to_date : Option < & 'a chrono :: DateTime < chrono :: offset :: Utc > >) -> Result < ResponseValue < types :: GetProjectsProjectIdIncidentsResponse > , Error < types :: GetProjectsProjectIdIncidentsResponse > , > { let url = format ! ("{}/projects/{}/incidents" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut query = Vec :: with_capacity (7usize) ; if let Some (v) = & assertion_adopter_id { query . push (("assertion_adopter_id" , v . to_string ())) ; } if let Some (v) = & assertion_id { query . push (("assertion_id" , v . to_string ())) ; } if let Some (v) = & environment { query . push (("environment" , v . to_string ())) ; } if let Some (v) = & from_date { query . push (("from_date" , v . to_string ())) ; } if let Some (v) = & limit { query . push (("limit" , v . to_string ())) ; } if let Some (v) = & page { query . push (("page" , v . to_string ())) ; } if let Some (v) = & to_date { query . push (("to_date" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get incident statistics\n\nRetrieve aggregated statistics about incidents\n\nSends a `GET` request to `/projects/{project_id}/incidents/stats`\n\n"] pub async fn get_projects_project_id_incidents_stats < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , assertion_adopter_id : Option < & 'a str > , assertion_id : Option < & 'a str > , chain_id : Option < std :: num :: NonZeroU64 > , days : Option < i64 >) -> Result < ResponseValue < types :: GetProjectsProjectIdIncidentsStatsResponse > , Error < types :: GetProjectsProjectIdIncidentsStatsResponse > , > { let url = format ! ("{}/projects/{}/incidents/stats" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut query = Vec :: with_capacity (4usize) ; if let Some (v) = & assertion_adopter_id { query . push (("assertion_adopter_id" , v . to_string ())) ; } if let Some (v) = & assertion_id { query . push (("assertion_id" , v . to_string ())) ; } if let Some (v) = & chain_id { query . push (("chain_id" , v . to_string ())) ; } if let Some (v) = & days { query . push (("days" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get PagerDuty integration status\n\nRetrieve the current PagerDuty integration configuration and status for a project\n\nSends a `GET` request to `/projects/{project_id}/integrations/pagerduty`\n\n"] pub async fn get_projects_project_id_integrations_pagerduty < 'a > (& 'a self , project_id : & 'a uuid :: Uuid) -> Result < ResponseValue < types :: GetProjectsProjectIdIntegrationsPagerdutyResponse > , Error < types :: GetProjectsProjectIdIntegrationsPagerdutyResponse > , > { let url = format ! ("{}/projects/{}/integrations/pagerduty" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Configure PagerDuty integration\n\nCreate or update PagerDuty routing key configuration for a project\n\nSends a `POST` request to `/projects/{project_id}/integrations/pagerduty`\n\nArguments:\n- `project_id`\n- `body`: Body\n"] pub async fn post_projects_project_id_integrations_pagerduty < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , body : & 'a types :: PostProjectsProjectIdIntegrationsPagerdutyBody) -> Result < ResponseValue < types :: PostProjectsProjectIdIntegrationsPagerdutyResponse > , Error < types :: PostProjectsProjectIdIntegrationsPagerdutyResponse > , > { let url = format ! ("{}/projects/{}/integrations/pagerduty" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Delete PagerDuty integration\n\nRemove PagerDuty integration from a project (idempotent operation)\n\nSends a `DELETE` request to `/projects/{project_id}/integrations/pagerduty`\n\n"] pub async fn delete_projects_project_id_integrations_pagerduty < 'a > (& 'a self , project_id : & 'a uuid :: Uuid) -> Result < ResponseValue < types :: DeleteProjectsProjectIdIntegrationsPagerdutyResponse > , Error < types :: DeleteProjectsProjectIdIntegrationsPagerdutyResponse > , > { let url = format ! ("{}/projects/{}/integrations/pagerduty" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . delete (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Test PagerDuty integration\n\nSend a test event to verify PagerDuty routing key configuration\n\nSends a `POST` request to `/projects/{project_id}/integrations/pagerduty/test`\n\nArguments:\n- `project_id`\n- `body`: Body\n"] pub async fn post_projects_project_id_integrations_pagerduty_test < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , body : & 'a :: serde_json :: Map < String , :: serde_json :: Value >) -> Result < ResponseValue < types :: PostProjectsProjectIdIntegrationsPagerdutyTestResponse > , Error < types :: PostProjectsProjectIdIntegrationsPagerdutyTestResponse > , > { let url = format ! ("{}/projects/{}/integrations/pagerduty/test" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 429u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get Slack integration status\n\nRetrieve the current Slack integration configuration and status for a project\n\nSends a `GET` request to `/projects/{project_id}/integrations/slack`\n\n"] pub async fn get_projects_project_id_integrations_slack < 'a > (& 'a self , project_id : & 'a uuid :: Uuid) -> Result < ResponseValue < types :: GetProjectsProjectIdIntegrationsSlackResponse > , Error < types :: GetProjectsProjectIdIntegrationsSlackResponse > , > { let url = format ! ("{}/projects/{}/integrations/slack" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Configure Slack integration\n\nCreate or update Slack webhook configuration for a project\n\nSends a `POST` request to `/projects/{project_id}/integrations/slack`\n\nArguments:\n- `project_id`\n- `body`: Body\n"] pub async fn post_projects_project_id_integrations_slack < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , body : & 'a types :: PostProjectsProjectIdIntegrationsSlackBody) -> Result < ResponseValue < types :: PostProjectsProjectIdIntegrationsSlackResponse > , Error < types :: PostProjectsProjectIdIntegrationsSlackResponse > , > { let url = format ! ("{}/projects/{}/integrations/slack" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Delete Slack integration\n\nRemove Slack integration from a project (idempotent operation)\n\nSends a `DELETE` request to `/projects/{project_id}/integrations/slack`\n\n"] pub async fn delete_projects_project_id_integrations_slack < 'a > (& 'a self , project_id : & 'a uuid :: Uuid) -> Result < ResponseValue < types :: DeleteProjectsProjectIdIntegrationsSlackResponse > , Error < types :: DeleteProjectsProjectIdIntegrationsSlackResponse > , > { let url = format ! ("{}/projects/{}/integrations/slack" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . delete (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Test Slack integration\n\nSend a test notification to verify Slack webhook configuration\n\nSends a `POST` request to `/projects/{project_id}/integrations/slack/test`\n\nArguments:\n- `project_id`\n- `body`: Body\n"] pub async fn post_projects_project_id_integrations_slack_test < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , body : & 'a :: serde_json :: Map < String , :: serde_json :: Value >) -> Result < ResponseValue < types :: PostProjectsProjectIdIntegrationsSlackTestResponse > , Error < types :: PostProjectsProjectIdIntegrationsSlackTestResponse > , > { let url = format ! ("{}/projects/{}/integrations/slack/test" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 429u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Reconcile project state with on-chain data\n\nFetches latest on-chain assertion registrations for the project and logs any missing events in the database.\n\nSends a `POST` request to `/projects/{project_id}/reconcile`\n\nArguments:\n- `project_id`: Project UUID to reconcile\n- `body`: Body\n"] pub async fn post_projects_project_id_reconcile < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , body : & 'a types :: PostProjectsProjectIdReconcileBody) -> Result < ResponseValue < types :: PostProjectsProjectIdReconcileResponse > , Error < types :: PostProjectsProjectIdReconcileResponse > , > { let url = format ! ("{}/projects/{}/reconcile" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get registered assertions for project\n\nGet all registered assertions associated with a project\n\nSends a `GET` request to `/projects/{project_id}/registered-assertions`\n\n"] pub async fn get_projects_project_id_registered_assertions < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , environment : Option < types :: GetProjectsProjectIdRegisteredAssertionsEnvironment >) -> Result < ResponseValue < types :: GetProjectsProjectIdRegisteredAssertionsResponse > , Error < types :: GetProjectsProjectIdRegisteredAssertionsResponse > , > { let url = format ! ("{}/projects/{}/registered-assertions" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut query = Vec :: with_capacity (1usize) ; if let Some (v) = & environment { query . push (("environment" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Register assertions\n\nRegister assertions for a project\n\nSends a `POST` request to `/projects/{project_id}/registered-assertions`\n\nArguments:\n- `project_id`\n- `authorization`\n- `body`: Body\n"] pub async fn post_projects_project_id_registered_assertions < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , authorization : Option < & 'a str > , body : & 'a types :: PostProjectsProjectIdRegisteredAssertionsBody) -> Result < ResponseValue < types :: PostProjectsProjectIdRegisteredAssertionsResponse > , Error < types :: PostProjectsProjectIdRegisteredAssertionsResponse > , > { let url = format ! ("{}/projects/{}/registered-assertions" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Generate remove assertions calldata\n\nGenerate calldata for removing assertions from a project\n\nSends a `GET` request to `/projects/{project_id}/remove-assertions-calldata`\n\n"] pub async fn get_projects_project_id_remove_assertions_calldata < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: GetProjectsProjectIdRemoveAssertionsCalldataResponse > , Error < types :: GetProjectsProjectIdRemoveAssertionsCalldataResponse > , > { let url = format ! ("{}/projects/{}/remove-assertions-calldata" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get submitted assertions for a project\n\nGet all assertions that have been submitted for a specific project\n\nSends a `GET` request to `/projects/{project_id}/submitted-assertions`\n\n"] pub async fn get_projects_project_id_submitted_assertions < 'a > (& 'a self , project_id : & 'a str , environment : Option < types :: GetProjectsProjectIdSubmittedAssertionsEnvironment > , network : Option < & 'a str > , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: GetProjectsProjectIdSubmittedAssertionsResponse > , Error < types :: GetProjectsProjectIdSubmittedAssertionsResponse > , > { let url = format ! ("{}/projects/{}/submitted-assertions" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut query = Vec :: with_capacity (2usize) ; if let Some (v) = & environment { query . push (("environment" , v . to_string ())) ; } if let Some (v) = & network { query . push (("network" , v . to_string ())) ; } let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Submit assertions to a project\n\nSubmit one or more assertions to a specific project (CLI only)\n\nSends a `POST` request to `/projects/{project_id}/submitted-assertions`\n\nArguments:\n- `project_id`\n- `authorization`\n- `x_auth_scope`\n- `body`: Body\n"] pub async fn post_projects_project_id_submitted_assertions < 'a > (& 'a self , project_id : & 'a str , authorization : Option < & 'a str > , x_auth_scope : Option < & 'a str > , body : & 'a types :: PostProjectsProjectIdSubmittedAssertionsBody) -> Result < ResponseValue < types :: PostProjectsProjectIdSubmittedAssertionsResponse > , Error < types :: PostProjectsProjectIdSubmittedAssertionsResponse > , > { let url = format ! ("{}/projects/{}/submitted-assertions" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (2usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } if let Some (v) = x_auth_scope { header_map . append ("X-Auth-Scope" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get lightweight project widget data\n\nFetch minimal project data for widget display including counts sourced from the indexer.\n\nSends a `GET` request to `/projects/{project_id}/widget`\n\n"] pub async fn get_projects_project_id_widget < 'a > (& 'a self , project_id : & 'a uuid :: Uuid) -> Result < ResponseValue < types :: GetProjectsProjectIdWidgetResponse > , Error < types :: GetProjectsProjectIdWidgetResponse > , > { let url = format ! ("{}/projects/{}/widget" , self . baseurl , encode_path (& project_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Remove assertion adopter from project\n\nRemove an assertion adopter from a project\n\nSends a `DELETE` request to `/projects/{project_id}/{aa_contract}`\n\n"] pub async fn delete_projects_project_id_aa_contract < 'a > (& 'a self , project_id : & 'a uuid :: Uuid , aa_contract : & 'a types :: DeleteProjectsProjectIdAaContractAaContract , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: DeleteProjectsProjectIdAaContractResponse > , Error < types :: DeleteProjectsProjectIdAaContractResponse > , > { let url = format ! ("{}/projects/{}/{}" , self . baseurl , encode_path (& project_id . to_string ()) , encode_path (& aa_contract . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . delete (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get public incidents list\n\nRetrieve paginated list of incident removal events (public data only)\n\nSends a `GET` request to `/public/incidents`\n\n"] pub async fn get_public_incidents < 'a > (& 'a self , limit : Option < i64 > , network : Option < std :: num :: NonZeroU64 > , page : Option < std :: num :: NonZeroU64 > , sort : Option < types :: GetPublicIncidentsSort >) -> Result < ResponseValue < types :: GetPublicIncidentsResponse > , Error < types :: GetPublicIncidentsResponse > , > { let url = format ! ("{}/public/incidents" , self . baseurl ,) ; let mut query = Vec :: with_capacity (4usize) ; if let Some (v) = & limit { query . push (("limit" , v . to_string ())) ; } if let Some (v) = & network { query . push (("network" , v . to_string ())) ; } if let Some (v) = & page { query . push (("page" , v . to_string ())) ; } if let Some (v) = & sort { query . push (("sort" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Search\n\nSearch for projects and contracts\n\nSends a `GET` request to `/search`\n\n"] pub async fn get_search < 'a > (& 'a self , query : & 'a types :: GetSearchQuery) -> Result < ResponseValue < types :: GetSearchResponse > , Error < types :: GetSearchResponse > , > { let url = format ! ("{}/search" , self . baseurl ,) ; let mut _query = Vec :: with_capacity (1usize) ; _query . push (("query" , query . to_string ())) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& _query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get network statistics\n\nRetrieve total counts of projects and assertions with optional filtering by owner or network\n\nSends a `GET` request to `/stats`\n\n"] pub async fn get_stats < 'a > (& 'a self , network_id : Option < f64 > , user : Option < & 'a types :: GetStatsUser > , with_assertions_only : Option < bool >) -> Result < ResponseValue < types :: GetStatsResponse > , Error < types :: GetStatsResponse > , > { let url = format ! ("{}/stats" , self . baseurl ,) ; let mut query = Vec :: with_capacity (3usize) ; if let Some (v) = & network_id { query . push (("network_id" , v . to_string ())) ; } if let Some (v) = & user { query . push (("user" , v . to_string ())) ; } if let Some (v) = & with_assertions_only { query . push (("with_assertions_only" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "System status\n\nGet detailed system status information\n\nSends a `GET` request to `/system-status`\n\n"] pub async fn get_system_status < 'a > (& 'a self ,) -> Result < ResponseValue < types :: GetSystemStatusResponse > , Error < types :: GetSystemStatusResponse > , > { let url = format ! ("{}/system-status" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Receive trace result callback\n\nWebhook endpoint for the external tracer service to report trace generation results\n\nSends a `POST` request to `/tracer/events`\n\nArguments:\n- `debug_trace_id`\n- `x_api_key`\n- `body`: Body\n"] pub async fn post_tracer_events < 'a > (& 'a self , debug_trace_id : & 'a uuid :: Uuid , x_api_key : Option < & 'a str > , body : & 'a types :: PostTracerEventsBody) -> Result < ResponseValue < types :: PostTracerEventsResponse > , Error < types :: PostTracerEventsResponse > , > { let url = format ! ("{}/tracer/events" , self . baseurl ,) ; let mut query = Vec :: with_capacity (1usize) ; query . push (("debug_trace_id" , debug_trace_id . to_string ())) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = x_api_key { header_map . append ("x-api-key" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . query (& query) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 202u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get all transfers\n\nGet all transfers for the authenticated user\n\nSends a `GET` request to `/transfers`\n\n"] pub async fn get_transfers < 'a > (& 'a self , role : Option < types :: GetTransfersRole > , status : Option < & 'a str > , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: GetTransfersResponse > , Error < types :: GetTransfersResponse > , > { let url = format ! ("{}/transfers" , self . baseurl ,) ; let mut query = Vec :: with_capacity (2usize) ; if let Some (v) = & role { query . push (("role" , v . to_string ())) ; } if let Some (v) = & status { query . push (("status" , v . to_string ())) ; } let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Create transfer (generic)\n\nCreate a new transfer request for either project or assertion adopter\n\nSends a `POST` request to `/transfers`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn post_transfers < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a types :: PostTransfersBody) -> Result < ResponseValue < types :: PostTransfersResponse > , Error < types :: PostTransfersResponse > , > { let url = format ! ("{}/transfers" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 201u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 409u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Create adopter transfer\n\nInitiate a transfer of assertion adopter ownership\n\nSends a `POST` request to `/transfers/assertion-adopters`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn post_transfers_assertion_adopters < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a types :: PostTransfersAssertionAdoptersBody) -> Result < ResponseValue < types :: PostTransfersAssertionAdoptersResponse > , Error < types :: PostTransfersAssertionAdoptersResponse > , > { let url = format ! ("{}/transfers/assertion-adopters" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 201u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 409u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get adopter transfer details\n\nGet details of a specific assertion adopter transfer\n\nSends a `GET` request to `/transfers/assertion-adopters/{transfer_id}`\n\n"] pub async fn get_transfers_assertion_adopters_transfer_id < 'a > (& 'a self , transfer_id : & 'a uuid :: Uuid , authorization : Option < & 'a str >) -> Result < ResponseValue < :: serde_json :: Value > , Error < types :: GetTransfersAssertionAdoptersTransferIdResponse > , > { let url = format ! ("{}/transfers/assertion-adopters/{}" , self . baseurl , encode_path (& transfer_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Cancel adopter transfer\n\nCancel a pending assertion adopter transfer\n\nSends a `DELETE` request to `/transfers/assertion-adopters/{transfer_id}`\n\n"] pub async fn delete_transfers_assertion_adopters_transfer_id < 'a > (& 'a self , transfer_id : & 'a uuid :: Uuid , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: DeleteTransfersAssertionAdoptersTransferIdResponse > , Error < types :: DeleteTransfersAssertionAdoptersTransferIdResponse > , > { let url = format ! ("{}/transfers/assertion-adopters/{}" , self . baseurl , encode_path (& transfer_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . delete (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Update adopter transfer\n\nAccept or reject an assertion adopter transfer\n\nSends a `PATCH` request to `/transfers/assertion-adopters/{transfer_id}`\n\nArguments:\n- `transfer_id`\n- `authorization`\n- `body`: Body\n"] pub async fn patch_transfers_assertion_adopters_transfer_id < 'a > (& 'a self , transfer_id : & 'a uuid :: Uuid , authorization : Option < & 'a str > , body : & 'a types :: PatchTransfersAssertionAdoptersTransferIdBody) -> Result < ResponseValue < types :: PatchTransfersAssertionAdoptersTransferIdResponse > , Error < types :: PatchTransfersAssertionAdoptersTransferIdResponse > , > { let url = format ! ("{}/transfers/assertion-adopters/{}" , self . baseurl , encode_path (& transfer_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . patch (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Create project transfer\n\nInitiate a transfer of project ownership\n\nSends a `POST` request to `/transfers/projects`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn post_transfers_projects < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a types :: PostTransfersProjectsBody) -> Result < ResponseValue < types :: PostTransfersProjectsResponse > , Error < types :: PostTransfersProjectsResponse > , > { let url = format ! ("{}/transfers/projects" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 201u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 409u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get project transfer details\n\nGet details of a specific project transfer\n\nSends a `GET` request to `/transfers/projects/{transfer_id}`\n\n"] pub async fn get_transfers_projects_transfer_id < 'a > (& 'a self , transfer_id : & 'a uuid :: Uuid , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: GetTransfersProjectsTransferIdResponse > , Error < types :: GetTransfersProjectsTransferIdResponse > , > { let url = format ! ("{}/transfers/projects/{}" , self . baseurl , encode_path (& transfer_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Cancel project transfer\n\nCancel a pending project transfer\n\nSends a `DELETE` request to `/transfers/projects/{transfer_id}`\n\n"] pub async fn delete_transfers_projects_transfer_id < 'a > (& 'a self , transfer_id : & 'a uuid :: Uuid , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: DeleteTransfersProjectsTransferIdResponse > , Error < types :: DeleteTransfersProjectsTransferIdResponse > , > { let url = format ! ("{}/transfers/projects/{}" , self . baseurl , encode_path (& transfer_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . delete (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Update project transfer\n\nAccept or reject a project transfer\n\nSends a `PATCH` request to `/transfers/projects/{transfer_id}`\n\nArguments:\n- `transfer_id`\n- `authorization`\n- `body`: Body\n"] pub async fn patch_transfers_projects_transfer_id < 'a > (& 'a self , transfer_id : & 'a uuid :: Uuid , authorization : Option < & 'a str > , body : & 'a types :: PatchTransfersProjectsTransferIdBody) -> Result < ResponseValue < types :: PatchTransfersProjectsTransferIdResponse > , Error < types :: PatchTransfersProjectsTransferIdResponse > , > { let url = format ! ("{}/transfers/projects/{}" , self . baseurl , encode_path (& transfer_id . to_string ()) ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . patch (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Accept terms of service\n\nAccept the terms of service for the authenticated user\n\nSends a `POST` request to `/web/auth/accept-terms`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn post_web_auth_accept_terms < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a :: serde_json :: Map < String , :: serde_json :: Value >) -> Result < ResponseValue < types :: PostWebAuthAcceptTermsResponse > , Error < types :: PostWebAuthAcceptTermsResponse > , > { let url = format ! ("{}/web/auth/accept-terms" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Logout user\n\nClear user session and invalidate tokens\n\nSends a `POST` request to `/web/auth/logout`\n\nArguments:\n- `body`: Body\n"] pub async fn post_web_auth_logout < 'a > (& 'a self , body : & 'a :: serde_json :: Map < String , :: serde_json :: Value >) -> Result < ResponseValue < types :: PostWebAuthLogoutResponse > , Error < types :: PostWebAuthLogoutResponse > , > { let url = format ! ("{}/web/auth/logout" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get current user info\n\nGet information about the currently authenticated user\n\nSends a `GET` request to `/web/auth/me`\n\n"] pub async fn get_web_auth_me < 'a > (& 'a self , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: GetWebAuthMeResponse > , Error < types :: GetWebAuthMeResponse > , > { let url = format ! ("{}/web/auth/me" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get authentication nonce\n\nGet a nonce for SIWE authentication\n\nSends a `GET` request to `/web/auth/nonce`\n\n"] pub async fn get_web_auth_nonce < 'a > (& 'a self ,) -> Result < ResponseValue < types :: GetWebAuthNonceResponse > , Error < types :: GetWebAuthNonceResponse > , > { let url = format ! ("{}/web/auth/nonce" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Refresh access token\n\nRefresh JWT access token using refresh token\n\nSends a `POST` request to `/web/auth/refresh`\n\nArguments:\n- `body`: Body\n"] pub async fn post_web_auth_refresh < 'a > (& 'a self , body : & 'a types :: PostWebAuthRefreshBody) -> Result < ResponseValue < types :: PostWebAuthRefreshResponse > , Error < types :: PostWebAuthRefreshResponse > , > { let url = format ! ("{}/web/auth/refresh" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Verify SIWE signature\n\nVerify Sign-In with Ethereum message and signature\n\nSends a `POST` request to `/web/auth/verify`\n\nArguments:\n- `body`: Body\n"] pub async fn post_web_auth_verify < 'a > (& 'a self , body : & 'a types :: PostWebAuthVerifyBody) -> Result < ResponseValue < types :: PostWebAuthVerifyResponse > , Error < types :: PostWebAuthVerifyResponse > , > { let url = format ! ("{}/web/auth/verify" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 422u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Request testnet tokens\n\nRequest tokens from testnet faucet\n\nSends a `POST` request to `/web/faucet`\n\nArguments:\n- `authorization`\n- `body`: Body\n"] pub async fn post_web_faucet < 'a > (& 'a self , authorization : Option < & 'a str > , body : & 'a types :: PostWebFaucetBody) -> Result < ResponseValue < types :: PostWebFaucetResponse > , Error < types :: PostWebFaucetResponse > , > { let url = format ! ("{}/web/faucet" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 429u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get verified contract info\n\nRetrieve verified contract information from block explorer\n\nSends a `GET` request to `/web/verified-contract`\n\n"] pub async fn get_web_verified_contract < 'a > (& 'a self , address : & 'a types :: GetWebVerifiedContractAddress , chain_id : & 'a str , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: GetWebVerifiedContractResponse > , Error < types :: GetWebVerifiedContractResponse > , > { let url = format ! ("{}/web/verified-contract" , self . baseurl ,) ; let mut query = Vec :: with_capacity (2usize) ; query . push (("address" , address . to_string ())) ; query . push (("chainId" , chain_id . to_string ())) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Check whitelist status\n\nCheck whitelist status for the authenticated user\n\nSends a `GET` request to `/whitelist`\n\n"] pub async fn get_whitelist < 'a > (& 'a self , authorization : Option < & 'a str >) -> Result < ResponseValue < types :: GetWhitelistResponse > , Error < types :: GetWhitelistResponse > , > { let url = format ! ("{}/whitelist" , self . baseurl ,) ; let mut header_map = HeaderMap :: with_capacity (1usize) ; if let Some (v) = authorization { header_map . append ("Authorization" , HeaderValue :: try_from (v) ?) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . headers (header_map) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 500u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } } # [doc = r" Items consumers will typically use such as the Client."] pub mod prelude { # [allow (unused_imports)] pub use super :: Client ; }
