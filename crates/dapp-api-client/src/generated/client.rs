// @generated - This file is automatically generated. Do not edit.
// rustfmt-ignore-file

#![allow(clippy::all)]
#![allow(irrefutable_let_patterns)]
#![allow(warnings)]

#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, Error, ResponseValue};
#[allow(unused_imports)]
use progenitor_client::{RequestBuilderExt, encode_path};
#[allow(unused_imports)]
use reqwest::header::{HeaderMap, HeaderValue};
#[doc = r" Types used as operation parameters and responses."]
#[allow(clippy::all)]
pub mod types {
    #[doc = r" Error types."]
    pub mod error {
        #[doc = r" Error from a TryFrom or FromStr implementation."]
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }
        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }
        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }
        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }
    #[doc = "DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress(String);
    impl ::std::ops::Deref for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress> for String {
        fn from(value: DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress) -> Self {
            value.0
        }
    }
    impl From<&DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress
    {
        fn from(value: &DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress
    {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress
    {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId(String);
    impl ::std::ops::Deref for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId> for String {
        fn from(value: DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId) -> Self {
            value.0
        }
    }
    impl From<&DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId
    {
        fn from(value: &DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{64}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId
    {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId
    {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork {
        Variant0(String),
        Variant1(f64),
    }
    impl From<&DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork
    {
        fn from(value: &DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork) -> Self {
            value.clone()
        }
    }
    impl std::str::FromStr for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Variant0(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Variant1(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }
    impl std::convert::TryFrom<&str> for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork
    {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl From<f64> for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
        pub success: bool,
    }
    impl From<&DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse>
        for DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse
    {
        fn from(value: &DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "DeleteProjectsProjectIdAaContractAaContract"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct DeleteProjectsProjectIdAaContractAaContract(String);
    impl ::std::ops::Deref for DeleteProjectsProjectIdAaContractAaContract {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<DeleteProjectsProjectIdAaContractAaContract> for String {
        fn from(value: DeleteProjectsProjectIdAaContractAaContract) -> Self {
            value.0
        }
    }
    impl From<&DeleteProjectsProjectIdAaContractAaContract>
        for DeleteProjectsProjectIdAaContractAaContract
    {
        fn from(value: &DeleteProjectsProjectIdAaContractAaContract) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for DeleteProjectsProjectIdAaContractAaContract {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for DeleteProjectsProjectIdAaContractAaContract {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for DeleteProjectsProjectIdAaContractAaContract {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for DeleteProjectsProjectIdAaContractAaContract {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteProjectsProjectIdAaContractAaContract {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "DeleteProjectsProjectIdAaContractResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteProjectsProjectIdAaContractResponse {
        pub success: bool,
    }
    impl From<&DeleteProjectsProjectIdAaContractResponse>
        for DeleteProjectsProjectIdAaContractResponse
    {
        fn from(value: &DeleteProjectsProjectIdAaContractResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "DeleteProjectsProjectIdResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteProjectsProjectIdResponse {
        pub success: bool,
    }
    impl From<&DeleteProjectsProjectIdResponse> for DeleteProjectsProjectIdResponse {
        fn from(value: &DeleteProjectsProjectIdResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "DeleteProjectsSavedBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"project_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteProjectsSavedBody {
        pub project_id: uuid::Uuid,
    }
    impl From<&DeleteProjectsSavedBody> for DeleteProjectsSavedBody {
        fn from(value: &DeleteProjectsSavedBody) -> Self {
            value.clone()
        }
    }
    #[doc = "DeleteProjectsSavedResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteProjectsSavedResponse {
        pub success: bool,
    }
    impl From<&DeleteProjectsSavedResponse> for DeleteProjectsSavedResponse {
        fn from(value: &DeleteProjectsSavedResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "DeleteTransfersAssertionAdoptersTransferIdResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteTransfersAssertionAdoptersTransferIdResponse {
        pub message: String,
    }
    impl From<&DeleteTransfersAssertionAdoptersTransferIdResponse>
        for DeleteTransfersAssertionAdoptersTransferIdResponse
    {
        fn from(value: &DeleteTransfersAssertionAdoptersTransferIdResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "DeleteTransfersProjectsTransferIdResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteTransfersProjectsTransferIdResponse {
        pub message: String,
    }
    impl From<&DeleteTransfersProjectsTransferIdResponse>
        for DeleteTransfersProjectsTransferIdResponse
    {
        fn from(value: &DeleteTransfersProjectsTransferIdResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress(String);
    impl ::std::ops::Deref for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress> for String {
        fn from(value: GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress>
        for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress
    {
        fn from(value: &GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str>
        for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String>
        for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String>
        for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress
    {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress
    {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork {
        Variant0(String),
        Variant1(f64),
    }
    impl From<&GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork>
        for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork
    {
        fn from(value: &GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork) -> Self {
            value.clone()
        }
    }
    impl std::str::FromStr for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Variant0(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Variant1(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }
    impl std::convert::TryFrom<&str> for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
        for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
        for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork
    {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl From<f64> for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"assertions\","]
    #[doc = "        \"calldata\","]
    #[doc = "        \"total_batches\","]
    #[doc = "        \"total_calldata\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"assertions\": {"]
    #[doc = "          \"type\": \"array\","]
    #[doc = "          \"items\": {"]
    #[doc = "            \"type\": \"object\","]
    #[doc = "            \"required\": ["]
    #[doc = "              \"assertion_id\","]
    #[doc = "              \"calldata\""]
    #[doc = "            ],"]
    #[doc = "            \"properties\": {"]
    #[doc = "              \"assertion_id\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              },"]
    #[doc = "              \"calldata\": {"]
    #[doc = "                \"type\": \"array\","]
    #[doc = "                \"items\": {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                }"]
    #[doc = "              }"]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"calldata\": {"]
    #[doc = "          \"type\": \"array\","]
    #[doc = "          \"items\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"total_batches\": {"]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        },"]
    #[doc = "        \"total_calldata\": {"]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"calldata\","]
    #[doc = "        \"message\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"calldata\": {"]
    #[doc = "          \"type\": \"array\","]
    #[doc = "          \"items\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"message\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse {
        Variant0 {
            assertions: Vec<
                GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem,
            >,
            calldata: Vec<String>,
            total_batches: f64,
            total_calldata: f64,
        },
        Variant1 {
            calldata: Vec<String>,
            message: String,
        },
    }
    impl From<&GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse>
        for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse
    {
        fn from(value: &GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_id\","]
    #[doc = "    \"calldata\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"calldata\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem {
        pub assertion_id: String,
        pub calldata: Vec<String>,
    }
    impl From<&GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem>
        for GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem
    {
        fn from(
            value : & GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponseVariant0AssertionsItem,
        ) -> Self {
            value.clone()
        }
    }
    #[doc = "GetAssertionAdoptersAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionAdoptersAddress(String);
    impl ::std::ops::Deref for GetAssertionAdoptersAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionAdoptersAddress> for String {
        fn from(value: GetAssertionAdoptersAddress) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionAdoptersAddress> for GetAssertionAdoptersAddress {
        fn from(value: &GetAssertionAdoptersAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionAdoptersAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetAssertionAdoptersAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetAssertionAdoptersAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetAssertionAdoptersAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAssertionAdoptersAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionAdoptersNetwork"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetAssertionAdoptersNetwork {
        Variant0(String),
        Variant1(f64),
    }
    impl From<&GetAssertionAdoptersNetwork> for GetAssertionAdoptersNetwork {
        fn from(value: &GetAssertionAdoptersNetwork) -> Self {
            value.clone()
        }
    }
    impl std::str::FromStr for GetAssertionAdoptersNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Variant0(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Variant1(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }
    impl std::convert::TryFrom<&str> for GetAssertionAdoptersNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for GetAssertionAdoptersNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for GetAssertionAdoptersNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for GetAssertionAdoptersNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl From<f64> for GetAssertionAdoptersNetwork {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "GetAssertionAdoptersNoProjectManager"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionAdoptersNoProjectManager(String);
    impl ::std::ops::Deref for GetAssertionAdoptersNoProjectManager {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionAdoptersNoProjectManager> for String {
        fn from(value: GetAssertionAdoptersNoProjectManager) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionAdoptersNoProjectManager> for GetAssertionAdoptersNoProjectManager {
        fn from(value: &GetAssertionAdoptersNoProjectManager) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionAdoptersNoProjectManager {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetAssertionAdoptersNoProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetAssertionAdoptersNoProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetAssertionAdoptersNoProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAssertionAdoptersNoProjectManager {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionAdoptersNoProjectResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"error\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetAssertionAdoptersNoProjectResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        pub error: String,
    }
    impl From<&GetAssertionAdoptersNoProjectResponse> for GetAssertionAdoptersNoProjectResponse {
        fn from(value: &GetAssertionAdoptersNoProjectResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetAssertionAdoptersNoProjectResponseItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"assertion_adopter_manager\","]
    #[doc = "    \"contract_name\","]
    #[doc = "    \"id\","]
    #[doc = "    \"network\","]
    #[doc = "    \"registered_assertions\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"assertion_adopter_manager\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"contract_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"network\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"oneOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"registered_assertions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetAssertionAdoptersNoProjectResponseItem {
        pub address: GetAssertionAdoptersNoProjectResponseItemAddress,
        pub assertion_adopter_manager:
            GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager,
        pub contract_name: Option<String>,
        pub id: String,
        pub network: GetAssertionAdoptersNoProjectResponseItemNetwork,
        pub registered_assertions: Vec<String>,
    }
    impl From<&GetAssertionAdoptersNoProjectResponseItem>
        for GetAssertionAdoptersNoProjectResponseItem
    {
        fn from(value: &GetAssertionAdoptersNoProjectResponseItem) -> Self {
            value.clone()
        }
    }
    #[doc = "GetAssertionAdoptersNoProjectResponseItemAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionAdoptersNoProjectResponseItemAddress(String);
    impl ::std::ops::Deref for GetAssertionAdoptersNoProjectResponseItemAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionAdoptersNoProjectResponseItemAddress> for String {
        fn from(value: GetAssertionAdoptersNoProjectResponseItemAddress) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionAdoptersNoProjectResponseItemAddress>
        for GetAssertionAdoptersNoProjectResponseItemAddress
    {
        fn from(value: &GetAssertionAdoptersNoProjectResponseItemAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionAdoptersNoProjectResponseItemAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetAssertionAdoptersNoProjectResponseItemAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetAssertionAdoptersNoProjectResponseItemAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetAssertionAdoptersNoProjectResponseItemAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAssertionAdoptersNoProjectResponseItemAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager(String);
    impl ::std::ops::Deref for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager> for String {
        fn from(value: GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager>
        for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager
    {
        fn from(value: &GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str>
        for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String>
        for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String>
        for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager
    {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GetAssertionAdoptersNoProjectResponseItemAssertionAdopterManager
    {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionAdoptersNoProjectResponseItemNetwork"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetAssertionAdoptersNoProjectResponseItemNetwork {
        Variant0(String),
        Variant1(f64),
    }
    impl From<&GetAssertionAdoptersNoProjectResponseItemNetwork>
        for GetAssertionAdoptersNoProjectResponseItemNetwork
    {
        fn from(value: &GetAssertionAdoptersNoProjectResponseItemNetwork) -> Self {
            value.clone()
        }
    }
    impl std::str::FromStr for GetAssertionAdoptersNoProjectResponseItemNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Variant0(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Variant1(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }
    impl std::convert::TryFrom<&str> for GetAssertionAdoptersNoProjectResponseItemNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for GetAssertionAdoptersNoProjectResponseItemNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for GetAssertionAdoptersNoProjectResponseItemNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for GetAssertionAdoptersNoProjectResponseItemNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl From<f64> for GetAssertionAdoptersNoProjectResponseItemNetwork {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "GetAssertionAdoptersResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"error\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetAssertionAdoptersResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        pub error: String,
    }
    impl From<&GetAssertionAdoptersResponse> for GetAssertionAdoptersResponse {
        fn from(value: &GetAssertionAdoptersResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetAssertionAdoptersResponseItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"assertion_adopter_manager\","]
    #[doc = "    \"id\","]
    #[doc = "    \"network\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"assertion_adopter_manager\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"contract_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^\\\\d+_0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"network\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"oneOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"registered_assertions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetAssertionAdoptersResponseItem {
        pub address: GetAssertionAdoptersResponseItemAddress,
        pub assertion_adopter_manager: GetAssertionAdoptersResponseItemAssertionAdopterManager,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub contract_name: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<chrono::DateTime<chrono::offset::Utc>>,
        pub id: GetAssertionAdoptersResponseItemId,
        pub network: GetAssertionAdoptersResponseItemNetwork,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub registered_assertions: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub updated_at: Option<chrono::DateTime<chrono::offset::Utc>>,
    }
    impl From<&GetAssertionAdoptersResponseItem> for GetAssertionAdoptersResponseItem {
        fn from(value: &GetAssertionAdoptersResponseItem) -> Self {
            value.clone()
        }
    }
    #[doc = "GetAssertionAdoptersResponseItemAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionAdoptersResponseItemAddress(String);
    impl ::std::ops::Deref for GetAssertionAdoptersResponseItemAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionAdoptersResponseItemAddress> for String {
        fn from(value: GetAssertionAdoptersResponseItemAddress) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionAdoptersResponseItemAddress> for GetAssertionAdoptersResponseItemAddress {
        fn from(value: &GetAssertionAdoptersResponseItemAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionAdoptersResponseItemAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetAssertionAdoptersResponseItemAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetAssertionAdoptersResponseItemAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetAssertionAdoptersResponseItemAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAssertionAdoptersResponseItemAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionAdoptersResponseItemAssertionAdopterManager"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionAdoptersResponseItemAssertionAdopterManager(String);
    impl ::std::ops::Deref for GetAssertionAdoptersResponseItemAssertionAdopterManager {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionAdoptersResponseItemAssertionAdopterManager> for String {
        fn from(value: GetAssertionAdoptersResponseItemAssertionAdopterManager) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionAdoptersResponseItemAssertionAdopterManager>
        for GetAssertionAdoptersResponseItemAssertionAdopterManager
    {
        fn from(value: &GetAssertionAdoptersResponseItemAssertionAdopterManager) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionAdoptersResponseItemAssertionAdopterManager {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetAssertionAdoptersResponseItemAssertionAdopterManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetAssertionAdoptersResponseItemAssertionAdopterManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetAssertionAdoptersResponseItemAssertionAdopterManager {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAssertionAdoptersResponseItemAssertionAdopterManager {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionAdoptersResponseItemId"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^\\\\d+_0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionAdoptersResponseItemId(String);
    impl ::std::ops::Deref for GetAssertionAdoptersResponseItemId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionAdoptersResponseItemId> for String {
        fn from(value: GetAssertionAdoptersResponseItemId) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionAdoptersResponseItemId> for GetAssertionAdoptersResponseItemId {
        fn from(value: &GetAssertionAdoptersResponseItemId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionAdoptersResponseItemId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^\\d+_0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^\\d+_0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetAssertionAdoptersResponseItemId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetAssertionAdoptersResponseItemId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetAssertionAdoptersResponseItemId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAssertionAdoptersResponseItemId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionAdoptersResponseItemNetwork"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetAssertionAdoptersResponseItemNetwork {
        Variant0(String),
        Variant1(f64),
    }
    impl From<&GetAssertionAdoptersResponseItemNetwork> for GetAssertionAdoptersResponseItemNetwork {
        fn from(value: &GetAssertionAdoptersResponseItemNetwork) -> Self {
            value.clone()
        }
    }
    impl std::str::FromStr for GetAssertionAdoptersResponseItemNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Variant0(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Variant1(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }
    impl std::convert::TryFrom<&str> for GetAssertionAdoptersResponseItemNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for GetAssertionAdoptersResponseItemNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for GetAssertionAdoptersResponseItemNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for GetAssertionAdoptersResponseItemNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl From<f64> for GetAssertionAdoptersResponseItemNetwork {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "GetAssertionsAdopterAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionsAdopterAddress(String);
    impl ::std::ops::Deref for GetAssertionsAdopterAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionsAdopterAddress> for String {
        fn from(value: GetAssertionsAdopterAddress) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionsAdopterAddress> for GetAssertionsAdopterAddress {
        fn from(value: &GetAssertionsAdopterAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionsAdopterAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetAssertionsAdopterAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetAssertionsAdopterAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetAssertionsAdopterAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAssertionsAdopterAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionsNetwork"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"default\": \"1\","]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetAssertionsNetwork {
        Variant0(String),
        Variant1(f64),
    }
    impl From<&GetAssertionsNetwork> for GetAssertionsNetwork {
        fn from(value: &GetAssertionsNetwork) -> Self {
            value.clone()
        }
    }
    impl Default for GetAssertionsNetwork {
        fn default() -> Self {
            GetAssertionsNetwork::Variant0("1".to_string())
        }
    }
    impl std::str::FromStr for GetAssertionsNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Variant0(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Variant1(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }
    impl std::convert::TryFrom<&str> for GetAssertionsNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for GetAssertionsNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for GetAssertionsNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for GetAssertionsNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl From<f64> for GetAssertionsNetwork {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "GetAssertionsResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"error\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetAssertionsResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        pub error: String,
    }
    impl From<&GetAssertionsResponse> for GetAssertionsResponse {
        fn from(value: &GetAssertionsResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetAssertionsResponseItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_functions\","]
    #[doc = "    \"assertion_id\","]
    #[doc = "    \"bytecode\","]
    #[doc = "    \"constructor_abi_signature\","]
    #[doc = "    \"constructor_args\","]
    #[doc = "    \"contract_name\","]
    #[doc = "    \"linked_adopters\","]
    #[doc = "    \"registered_address\","]
    #[doc = "    \"registered_at\","]
    #[doc = "    \"signature\","]
    #[doc = "    \"source_code\","]
    #[doc = "    \"status\","]
    #[doc = "    \"submitted_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_functions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"assertion_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "    },"]
    #[doc = "    \"bytecode\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"constructor_abi_signature\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"constructor_args\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {}"]
    #[doc = "    },"]
    #[doc = "    \"contract_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"linked_adopters\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"registered_address\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"registered_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source_code\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"pending\","]
    #[doc = "        \"submitted\","]
    #[doc = "        \"registered\","]
    #[doc = "        \"failed\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"submitted_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetAssertionsResponseItem {
        pub assertion_functions: Vec<String>,
        pub assertion_id: GetAssertionsResponseItemAssertionId,
        pub bytecode: Option<String>,
        pub constructor_abi_signature: Option<String>,
        pub constructor_args: Vec<::serde_json::Value>,
        pub contract_name: String,
        pub linked_adopters: Vec<GetAssertionsResponseItemLinkedAdoptersItem>,
        pub registered_address: Option<GetAssertionsResponseItemRegisteredAddress>,
        pub registered_at: Option<chrono::DateTime<chrono::offset::Utc>>,
        pub signature: String,
        pub source_code: Option<String>,
        pub status: GetAssertionsResponseItemStatus,
        pub submitted_at: chrono::DateTime<chrono::offset::Utc>,
    }
    impl From<&GetAssertionsResponseItem> for GetAssertionsResponseItem {
        fn from(value: &GetAssertionsResponseItem) -> Self {
            value.clone()
        }
    }
    #[doc = "GetAssertionsResponseItemAssertionId"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionsResponseItemAssertionId(String);
    impl ::std::ops::Deref for GetAssertionsResponseItemAssertionId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionsResponseItemAssertionId> for String {
        fn from(value: GetAssertionsResponseItemAssertionId) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionsResponseItemAssertionId> for GetAssertionsResponseItemAssertionId {
        fn from(value: &GetAssertionsResponseItemAssertionId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionsResponseItemAssertionId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{64}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetAssertionsResponseItemAssertionId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetAssertionsResponseItemAssertionId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetAssertionsResponseItemAssertionId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAssertionsResponseItemAssertionId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionsResponseItemLinkedAdoptersItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionsResponseItemLinkedAdoptersItem(String);
    impl ::std::ops::Deref for GetAssertionsResponseItemLinkedAdoptersItem {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionsResponseItemLinkedAdoptersItem> for String {
        fn from(value: GetAssertionsResponseItemLinkedAdoptersItem) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionsResponseItemLinkedAdoptersItem>
        for GetAssertionsResponseItemLinkedAdoptersItem
    {
        fn from(value: &GetAssertionsResponseItemLinkedAdoptersItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionsResponseItemLinkedAdoptersItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetAssertionsResponseItemLinkedAdoptersItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetAssertionsResponseItemLinkedAdoptersItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetAssertionsResponseItemLinkedAdoptersItem {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAssertionsResponseItemLinkedAdoptersItem {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionsResponseItemRegisteredAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetAssertionsResponseItemRegisteredAddress(String);
    impl ::std::ops::Deref for GetAssertionsResponseItemRegisteredAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetAssertionsResponseItemRegisteredAddress> for String {
        fn from(value: GetAssertionsResponseItemRegisteredAddress) -> Self {
            value.0
        }
    }
    impl From<&GetAssertionsResponseItemRegisteredAddress>
        for GetAssertionsResponseItemRegisteredAddress
    {
        fn from(value: &GetAssertionsResponseItemRegisteredAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetAssertionsResponseItemRegisteredAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetAssertionsResponseItemRegisteredAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetAssertionsResponseItemRegisteredAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetAssertionsResponseItemRegisteredAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAssertionsResponseItemRegisteredAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetAssertionsResponseItemStatus"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"pending\","]
    #[doc = "    \"submitted\","]
    #[doc = "    \"registered\","]
    #[doc = "    \"failed\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetAssertionsResponseItemStatus {
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "submitted")]
        Submitted,
        #[serde(rename = "registered")]
        Registered,
        #[serde(rename = "failed")]
        Failed,
    }
    impl From<&GetAssertionsResponseItemStatus> for GetAssertionsResponseItemStatus {
        fn from(value: &GetAssertionsResponseItemStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetAssertionsResponseItemStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => write!(f, "pending"),
                Self::Submitted => write!(f, "submitted"),
                Self::Registered => write!(f, "registered"),
                Self::Failed => write!(f, "failed"),
            }
        }
    }
    impl std::str::FromStr for GetAssertionsResponseItemStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "submitted" => Ok(Self::Submitted),
                "registered" => Ok(Self::Registered),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for GetAssertionsResponseItemStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for GetAssertionsResponseItemStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for GetAssertionsResponseItemStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "GetCliAuthCodeResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"code\","]
    #[doc = "    \"deviceSecret\","]
    #[doc = "    \"expiresAt\","]
    #[doc = "    \"sessionId\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 6,"]
    #[doc = "      \"minLength\": 6"]
    #[doc = "    },"]
    #[doc = "    \"deviceSecret\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"expiresAt\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"sessionId\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetCliAuthCodeResponse {
        pub code: GetCliAuthCodeResponseCode,
        #[serde(rename = "deviceSecret")]
        pub device_secret: String,
        #[serde(rename = "expiresAt")]
        pub expires_at: chrono::DateTime<chrono::offset::Utc>,
        #[serde(rename = "sessionId")]
        pub session_id: uuid::Uuid,
    }
    impl From<&GetCliAuthCodeResponse> for GetCliAuthCodeResponse {
        fn from(value: &GetCliAuthCodeResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetCliAuthCodeResponseCode"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 6,"]
    #[doc = "  \"minLength\": 6"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetCliAuthCodeResponseCode(String);
    impl ::std::ops::Deref for GetCliAuthCodeResponseCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetCliAuthCodeResponseCode> for String {
        fn from(value: GetCliAuthCodeResponseCode) -> Self {
            value.0
        }
    }
    impl From<&GetCliAuthCodeResponseCode> for GetCliAuthCodeResponseCode {
        fn from(value: &GetCliAuthCodeResponseCode) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetCliAuthCodeResponseCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 6usize {
                return Err("longer than 6 characters".into());
            }
            if value.len() < 6usize {
                return Err("shorter than 6 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetCliAuthCodeResponseCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetCliAuthCodeResponseCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetCliAuthCodeResponseCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetCliAuthCodeResponseCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetCliAuthStatusResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"verified\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"refresh_token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"verified\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetCliAuthStatusResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<GetCliAuthStatusResponseAddress>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub refresh_token: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub token: Option<String>,
        pub verified: bool,
    }
    impl From<&GetCliAuthStatusResponse> for GetCliAuthStatusResponse {
        fn from(value: &GetCliAuthStatusResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetCliAuthStatusResponseAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetCliAuthStatusResponseAddress(String);
    impl ::std::ops::Deref for GetCliAuthStatusResponseAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetCliAuthStatusResponseAddress> for String {
        fn from(value: GetCliAuthStatusResponseAddress) -> Self {
            value.0
        }
    }
    impl From<&GetCliAuthStatusResponseAddress> for GetCliAuthStatusResponseAddress {
        fn from(value: &GetCliAuthStatusResponseAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetCliAuthStatusResponseAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetCliAuthStatusResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetCliAuthStatusResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetCliAuthStatusResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetCliAuthStatusResponseAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetHealthResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"environment\","]
    #[doc = "    \"status\","]
    #[doc = "    \"timestamp\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"environment\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ok\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"timestamp\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetHealthResponse {
        pub environment: String,
        pub status: GetHealthResponseStatus,
        pub timestamp: String,
    }
    impl From<&GetHealthResponse> for GetHealthResponse {
        fn from(value: &GetHealthResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetHealthResponseStatus"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ok\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetHealthResponseStatus {
        #[serde(rename = "ok")]
        Ok,
    }
    impl From<&GetHealthResponseStatus> for GetHealthResponseStatus {
        fn from(value: &GetHealthResponseStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetHealthResponseStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ok => write!(f, "ok"),
            }
        }
    }
    impl std::str::FromStr for GetHealthResponseStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ok" => Ok(Self::Ok),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for GetHealthResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for GetHealthResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for GetHealthResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "GetOpenapiResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"error\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetOpenapiResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        pub error: String,
    }
    impl From<&GetOpenapiResponse> for GetOpenapiResponse {
        fn from(value: &GetOpenapiResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsProjectIdRegisteredAssertionsResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"registered_assertions\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"registered_assertions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"assertion_functions\","]
    #[doc = "          \"assertion_id\","]
    #[doc = "          \"bytecode\","]
    #[doc = "          \"constructor_abi_signature\","]
    #[doc = "          \"constructor_args\","]
    #[doc = "          \"contract_name\","]
    #[doc = "          \"linked_adopters\","]
    #[doc = "          \"registered_address\","]
    #[doc = "          \"registered_at\","]
    #[doc = "          \"signature\","]
    #[doc = "          \"source_code\","]
    #[doc = "          \"status\","]
    #[doc = "          \"submitted_at\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"assertion_functions\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"assertion_id\": {"]
    #[doc = "            \"type\": \"string\","]
    #[doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "          },"]
    #[doc = "          \"bytecode\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"constructor_abi_signature\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"constructor_args\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {}"]
    #[doc = "          },"]
    #[doc = "          \"contract_name\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"linked_adopters\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"registered_address\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ],"]
    #[doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "          },"]
    #[doc = "          \"registered_at\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ],"]
    #[doc = "            \"format\": \"date-time\""]
    #[doc = "          },"]
    #[doc = "          \"signature\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"source_code\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"status\": {"]
    #[doc = "            \"type\": \"string\","]
    #[doc = "            \"enum\": ["]
    #[doc = "              \"pending\","]
    #[doc = "              \"submitted\","]
    #[doc = "              \"registered\","]
    #[doc = "              \"failed\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"submitted_at\": {"]
    #[doc = "            \"type\": \"string\","]
    #[doc = "            \"format\": \"date-time\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetProjectsProjectIdRegisteredAssertionsResponse {
        pub registered_assertions:
            Vec<GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem>,
    }
    impl From<&GetProjectsProjectIdRegisteredAssertionsResponse>
        for GetProjectsProjectIdRegisteredAssertionsResponse
    {
        fn from(value: &GetProjectsProjectIdRegisteredAssertionsResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_functions\","]
    #[doc = "    \"assertion_id\","]
    #[doc = "    \"bytecode\","]
    #[doc = "    \"constructor_abi_signature\","]
    #[doc = "    \"constructor_args\","]
    #[doc = "    \"contract_name\","]
    #[doc = "    \"linked_adopters\","]
    #[doc = "    \"registered_address\","]
    #[doc = "    \"registered_at\","]
    #[doc = "    \"signature\","]
    #[doc = "    \"source_code\","]
    #[doc = "    \"status\","]
    #[doc = "    \"submitted_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_functions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"assertion_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "    },"]
    #[doc = "    \"bytecode\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"constructor_abi_signature\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"constructor_args\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {}"]
    #[doc = "    },"]
    #[doc = "    \"contract_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"linked_adopters\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"registered_address\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"registered_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source_code\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"pending\","]
    #[doc = "        \"submitted\","]
    #[doc = "        \"registered\","]
    #[doc = "        \"failed\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"submitted_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem { pub assertion_functions : Vec < String > , pub assertion_id : GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId , pub bytecode : Option < String > , pub constructor_abi_signature : Option < String > , pub constructor_args : Vec < :: serde_json :: Value > , pub contract_name : String , pub linked_adopters : Vec < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem > , pub registered_address : Option < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress > , pub registered_at : Option < chrono :: DateTime < chrono :: offset :: Utc > > , pub signature : String , pub source_code : Option < String > , pub status : GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus , pub submitted_at : chrono :: DateTime < chrono :: offset :: Utc > , }
    impl From<&GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem>
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem
    {
        fn from(
            value: &GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItem,
        ) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId(
        String,
    );
    impl ::std::ops::Deref
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId
    {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId>
        for String
    {
        fn from(
            value : GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId,
        ) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId>
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId
    {
        fn from(
            value : & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{64}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str>
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String>
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String>
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId
    {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemAssertionId
    {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem(
        String,
    );
    impl :: std :: ops :: Deref for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { type Target = String ; fn deref (& self) -> & String { & self . 0 } }
    impl From < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem > for String { fn from (value : GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem) -> Self { value . 0 } }
    impl From < & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { fn from (value : & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem) -> Self { value . clone () } }
    impl :: std :: str :: FromStr for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } }
    impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemLinkedAdoptersItem { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } }
    #[doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress(
        String,
    );
    impl :: std :: ops :: Deref for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { type Target = String ; fn deref (& self) -> & String { & self . 0 } }
    impl From < GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress > for String { fn from (value : GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress) -> Self { value . 0 } }
    impl From < & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { fn from (value : & GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress) -> Self { value . clone () } }
    impl :: std :: str :: FromStr for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } }
    impl :: std :: convert :: TryFrom < & str > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl :: std :: convert :: TryFrom < & String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl :: std :: convert :: TryFrom < String > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl < 'de > :: serde :: Deserialize < 'de > for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemRegisteredAddress { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } }
    #[doc = "GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"pending\","]
    #[doc = "    \"submitted\","]
    #[doc = "    \"registered\","]
    #[doc = "    \"failed\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus {
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "submitted")]
        Submitted,
        #[serde(rename = "registered")]
        Registered,
        #[serde(rename = "failed")]
        Failed,
    }
    impl From<&GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus>
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus
    {
        fn from(
            value: &GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus
    {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => write!(f, "pending"),
                Self::Submitted => write!(f, "submitted"),
                Self::Registered => write!(f, "registered"),
                Self::Failed => write!(f, "failed"),
            }
        }
    }
    impl std::str::FromStr
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "submitted" => Ok(Self::Submitted),
                "registered" => Ok(Self::Registered),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str>
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String>
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String>
        for GetProjectsProjectIdRegisteredAssertionsResponseRegisteredAssertionsItemStatus
    {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "GetProjectsProjectIdRemoveAssertionsCalldataResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_ids\","]
    #[doc = "    \"calldata\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_ids\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"calldata\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetProjectsProjectIdRemoveAssertionsCalldataResponse {
        pub assertion_ids: Vec<String>,
        pub calldata: String,
    }
    impl From<&GetProjectsProjectIdRemoveAssertionsCalldataResponse>
        for GetProjectsProjectIdRemoveAssertionsCalldataResponse
    {
        fn from(value: &GetProjectsProjectIdRemoveAssertionsCalldataResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsProjectIdResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"project_id\","]
    #[doc = "    \"project_manager\","]
    #[doc = "    \"project_name\","]
    #[doc = "    \"project_networks\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"profile_image_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uri\""]
    #[doc = "    },"]
    #[doc = "    \"project_description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"maxLength\": 1000"]
    #[doc = "    },"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"project_manager\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"project_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    },"]
    #[doc = "    \"project_networks\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"saved_count\": {"]
    #[doc = "      \"default\": 0,"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetProjectsProjectIdResponse {
        pub created_at: chrono::DateTime<chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub profile_image_url: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_description: Option<GetProjectsProjectIdResponseProjectDescription>,
        pub project_id: uuid::Uuid,
        pub project_manager: GetProjectsProjectIdResponseProjectManager,
        pub project_name: GetProjectsProjectIdResponseProjectName,
        pub project_networks: Vec<String>,
        #[serde(default)]
        pub saved_count: u64,
    }
    impl From<&GetProjectsProjectIdResponse> for GetProjectsProjectIdResponse {
        fn from(value: &GetProjectsProjectIdResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsProjectIdResponseProjectDescription"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 1000"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsProjectIdResponseProjectDescription(String);
    impl ::std::ops::Deref for GetProjectsProjectIdResponseProjectDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsProjectIdResponseProjectDescription> for String {
        fn from(value: GetProjectsProjectIdResponseProjectDescription) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsProjectIdResponseProjectDescription>
        for GetProjectsProjectIdResponseProjectDescription
    {
        fn from(value: &GetProjectsProjectIdResponseProjectDescription) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetProjectsProjectIdResponseProjectDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 1000usize {
                return Err("longer than 1000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetProjectsProjectIdResponseProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetProjectsProjectIdResponseProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetProjectsProjectIdResponseProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetProjectsProjectIdResponseProjectDescription {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetProjectsProjectIdResponseProjectManager"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsProjectIdResponseProjectManager(String);
    impl ::std::ops::Deref for GetProjectsProjectIdResponseProjectManager {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsProjectIdResponseProjectManager> for String {
        fn from(value: GetProjectsProjectIdResponseProjectManager) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsProjectIdResponseProjectManager>
        for GetProjectsProjectIdResponseProjectManager
    {
        fn from(value: &GetProjectsProjectIdResponseProjectManager) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetProjectsProjectIdResponseProjectManager {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetProjectsProjectIdResponseProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetProjectsProjectIdResponseProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetProjectsProjectIdResponseProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetProjectsProjectIdResponseProjectManager {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetProjectsProjectIdResponseProjectName"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsProjectIdResponseProjectName(String);
    impl ::std::ops::Deref for GetProjectsProjectIdResponseProjectName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsProjectIdResponseProjectName> for String {
        fn from(value: GetProjectsProjectIdResponseProjectName) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsProjectIdResponseProjectName> for GetProjectsProjectIdResponseProjectName {
        fn from(value: &GetProjectsProjectIdResponseProjectName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetProjectsProjectIdResponseProjectName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetProjectsProjectIdResponseProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetProjectsProjectIdResponseProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetProjectsProjectIdResponseProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetProjectsProjectIdResponseProjectName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetProjectsProjectIdSubmittedAssertionsResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"submitted_assertions\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"submitted_assertions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"assertion_functions\","]
    #[doc = "          \"assertion_id\","]
    #[doc = "          \"bytecode\","]
    #[doc = "          \"contract_name\","]
    #[doc = "          \"registered_at\","]
    #[doc = "          \"signature\","]
    #[doc = "          \"source_code\","]
    #[doc = "          \"status\","]
    #[doc = "          \"submitted_at\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"assertion_adopters\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"assertion_functions\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"assertion_id\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"bytecode\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"contract_name\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"registered_at\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"signature\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"source_code\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"status\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"submitted_at\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetProjectsProjectIdSubmittedAssertionsResponse {
        pub submitted_assertions:
            Vec<GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem>,
    }
    impl From<&GetProjectsProjectIdSubmittedAssertionsResponse>
        for GetProjectsProjectIdSubmittedAssertionsResponse
    {
        fn from(value: &GetProjectsProjectIdSubmittedAssertionsResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_functions\","]
    #[doc = "    \"assertion_id\","]
    #[doc = "    \"bytecode\","]
    #[doc = "    \"contract_name\","]
    #[doc = "    \"registered_at\","]
    #[doc = "    \"signature\","]
    #[doc = "    \"source_code\","]
    #[doc = "    \"status\","]
    #[doc = "    \"submitted_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_adopters\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"assertion_functions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"assertion_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"bytecode\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"contract_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"registered_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source_code\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"submitted_at\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assertion_adopters: Vec<String>,
        pub assertion_functions: Vec<String>,
        pub assertion_id: String,
        pub bytecode: Option<String>,
        pub contract_name: String,
        pub registered_at: Option<String>,
        pub signature: String,
        pub source_code: Option<String>,
        pub status: String,
        pub submitted_at: String,
    }
    impl From<&GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem>
        for GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem
    {
        fn from(
            value: &GetProjectsProjectIdSubmittedAssertionsResponseSubmittedAssertionsItem,
        ) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"error\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetProjectsResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        pub error: String,
    }
    impl From<&GetProjectsResponse> for GetProjectsResponse {
        fn from(value: &GetProjectsResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsResponseItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"project_id\","]
    #[doc = "    \"project_manager\","]
    #[doc = "    \"project_name\","]
    #[doc = "    \"project_networks\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"profile_image_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uri\""]
    #[doc = "    },"]
    #[doc = "    \"project_description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"maxLength\": 1000"]
    #[doc = "    },"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"project_manager\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"project_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    },"]
    #[doc = "    \"project_networks\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"saved_count\": {"]
    #[doc = "      \"default\": 0,"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetProjectsResponseItem {
        pub created_at: chrono::DateTime<chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub profile_image_url: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_description: Option<GetProjectsResponseItemProjectDescription>,
        pub project_id: uuid::Uuid,
        pub project_manager: GetProjectsResponseItemProjectManager,
        pub project_name: GetProjectsResponseItemProjectName,
        pub project_networks: Vec<String>,
        #[serde(default)]
        pub saved_count: u64,
    }
    impl From<&GetProjectsResponseItem> for GetProjectsResponseItem {
        fn from(value: &GetProjectsResponseItem) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsResponseItemProjectDescription"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 1000"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsResponseItemProjectDescription(String);
    impl ::std::ops::Deref for GetProjectsResponseItemProjectDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsResponseItemProjectDescription> for String {
        fn from(value: GetProjectsResponseItemProjectDescription) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsResponseItemProjectDescription>
        for GetProjectsResponseItemProjectDescription
    {
        fn from(value: &GetProjectsResponseItemProjectDescription) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetProjectsResponseItemProjectDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 1000usize {
                return Err("longer than 1000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetProjectsResponseItemProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetProjectsResponseItemProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetProjectsResponseItemProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetProjectsResponseItemProjectDescription {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetProjectsResponseItemProjectManager"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsResponseItemProjectManager(String);
    impl ::std::ops::Deref for GetProjectsResponseItemProjectManager {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsResponseItemProjectManager> for String {
        fn from(value: GetProjectsResponseItemProjectManager) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsResponseItemProjectManager> for GetProjectsResponseItemProjectManager {
        fn from(value: &GetProjectsResponseItemProjectManager) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetProjectsResponseItemProjectManager {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetProjectsResponseItemProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetProjectsResponseItemProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetProjectsResponseItemProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetProjectsResponseItemProjectManager {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetProjectsResponseItemProjectName"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsResponseItemProjectName(String);
    impl ::std::ops::Deref for GetProjectsResponseItemProjectName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsResponseItemProjectName> for String {
        fn from(value: GetProjectsResponseItemProjectName) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsResponseItemProjectName> for GetProjectsResponseItemProjectName {
        fn from(value: &GetProjectsResponseItemProjectName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetProjectsResponseItemProjectName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetProjectsResponseItemProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetProjectsResponseItemProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetProjectsResponseItemProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetProjectsResponseItemProjectName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetProjectsSavedResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"error\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetProjectsSavedResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        pub error: String,
    }
    impl From<&GetProjectsSavedResponse> for GetProjectsSavedResponse {
        fn from(value: &GetProjectsSavedResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsSavedResponseItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"project_id\","]
    #[doc = "    \"project_manager\","]
    #[doc = "    \"project_name\","]
    #[doc = "    \"project_networks\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"profile_image_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uri\""]
    #[doc = "    },"]
    #[doc = "    \"project_description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"maxLength\": 1000"]
    #[doc = "    },"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"project_manager\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"project_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    },"]
    #[doc = "    \"project_networks\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"saved_count\": {"]
    #[doc = "      \"default\": 0,"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetProjectsSavedResponseItem {
        pub created_at: chrono::DateTime<chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub profile_image_url: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_description: Option<GetProjectsSavedResponseItemProjectDescription>,
        pub project_id: uuid::Uuid,
        pub project_manager: GetProjectsSavedResponseItemProjectManager,
        pub project_name: GetProjectsSavedResponseItemProjectName,
        pub project_networks: Vec<String>,
        #[serde(default)]
        pub saved_count: u64,
    }
    impl From<&GetProjectsSavedResponseItem> for GetProjectsSavedResponseItem {
        fn from(value: &GetProjectsSavedResponseItem) -> Self {
            value.clone()
        }
    }
    #[doc = "GetProjectsSavedResponseItemProjectDescription"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 1000"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsSavedResponseItemProjectDescription(String);
    impl ::std::ops::Deref for GetProjectsSavedResponseItemProjectDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsSavedResponseItemProjectDescription> for String {
        fn from(value: GetProjectsSavedResponseItemProjectDescription) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsSavedResponseItemProjectDescription>
        for GetProjectsSavedResponseItemProjectDescription
    {
        fn from(value: &GetProjectsSavedResponseItemProjectDescription) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetProjectsSavedResponseItemProjectDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 1000usize {
                return Err("longer than 1000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetProjectsSavedResponseItemProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetProjectsSavedResponseItemProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetProjectsSavedResponseItemProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetProjectsSavedResponseItemProjectDescription {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetProjectsSavedResponseItemProjectManager"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsSavedResponseItemProjectManager(String);
    impl ::std::ops::Deref for GetProjectsSavedResponseItemProjectManager {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsSavedResponseItemProjectManager> for String {
        fn from(value: GetProjectsSavedResponseItemProjectManager) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsSavedResponseItemProjectManager>
        for GetProjectsSavedResponseItemProjectManager
    {
        fn from(value: &GetProjectsSavedResponseItemProjectManager) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetProjectsSavedResponseItemProjectManager {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetProjectsSavedResponseItemProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetProjectsSavedResponseItemProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetProjectsSavedResponseItemProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetProjectsSavedResponseItemProjectManager {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetProjectsSavedResponseItemProjectName"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsSavedResponseItemProjectName(String);
    impl ::std::ops::Deref for GetProjectsSavedResponseItemProjectName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsSavedResponseItemProjectName> for String {
        fn from(value: GetProjectsSavedResponseItemProjectName) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsSavedResponseItemProjectName> for GetProjectsSavedResponseItemProjectName {
        fn from(value: &GetProjectsSavedResponseItemProjectName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetProjectsSavedResponseItemProjectName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetProjectsSavedResponseItemProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetProjectsSavedResponseItemProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetProjectsSavedResponseItemProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetProjectsSavedResponseItemProjectName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetProjectsUser"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetProjectsUser(String);
    impl ::std::ops::Deref for GetProjectsUser {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetProjectsUser> for String {
        fn from(value: GetProjectsUser) -> Self {
            value.0
        }
    }
    impl From<&GetProjectsUser> for GetProjectsUser {
        fn from(value: &GetProjectsUser) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetProjectsUser {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetProjectsUser {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetProjectsUser {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetProjectsUser {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetProjectsUser {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetSearchQuery"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetSearchQuery(String);
    impl ::std::ops::Deref for GetSearchQuery {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetSearchQuery> for String {
        fn from(value: GetSearchQuery) -> Self {
            value.0
        }
    }
    impl From<&GetSearchQuery> for GetSearchQuery {
        fn from(value: &GetSearchQuery) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetSearchQuery {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetSearchQuery {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetSearchQuery {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetSearchQuery {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSearchQuery {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetSearchResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"contracts\","]
    #[doc = "    \"projects\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"contracts\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"data\","]
    #[doc = "          \"foundBy\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"data\": {"]
    #[doc = "            \"type\": \"object\","]
    #[doc = "            \"required\": ["]
    #[doc = "              \"address\","]
    #[doc = "              \"id\","]
    #[doc = "              \"network\""]
    #[doc = "            ],"]
    #[doc = "            \"properties\": {"]
    #[doc = "              \"address\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              },"]
    #[doc = "              \"contract_name\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              },"]
    #[doc = "              \"id\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              },"]
    #[doc = "              \"network\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              },"]
    #[doc = "              \"related_project_id\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              }"]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"foundBy\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"projects\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"profile_image_url\","]
    #[doc = "          \"project_id\","]
    #[doc = "          \"project_name\","]
    #[doc = "          \"project_networks\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"profile_image_url\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"project_id\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"project_name\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"project_networks\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetSearchResponse {
        pub contracts: Vec<GetSearchResponseContractsItem>,
        pub projects: Vec<GetSearchResponseProjectsItem>,
    }
    impl From<&GetSearchResponse> for GetSearchResponse {
        fn from(value: &GetSearchResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetSearchResponseContractsItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"data\","]
    #[doc = "    \"foundBy\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"address\","]
    #[doc = "        \"id\","]
    #[doc = "        \"network\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"address\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"contract_name\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"id\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"network\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"related_project_id\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"foundBy\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetSearchResponseContractsItem {
        pub data: GetSearchResponseContractsItemData,
        #[serde(rename = "foundBy")]
        pub found_by: String,
    }
    impl From<&GetSearchResponseContractsItem> for GetSearchResponseContractsItem {
        fn from(value: &GetSearchResponseContractsItem) -> Self {
            value.clone()
        }
    }
    #[doc = "GetSearchResponseContractsItemData"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"id\","]
    #[doc = "    \"network\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"contract_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"network\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"related_project_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetSearchResponseContractsItemData {
        pub address: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub contract_name: Option<String>,
        pub id: String,
        pub network: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub related_project_id: Option<String>,
    }
    impl From<&GetSearchResponseContractsItemData> for GetSearchResponseContractsItemData {
        fn from(value: &GetSearchResponseContractsItemData) -> Self {
            value.clone()
        }
    }
    #[doc = "GetSearchResponseProjectsItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"profile_image_url\","]
    #[doc = "    \"project_id\","]
    #[doc = "    \"project_name\","]
    #[doc = "    \"project_networks\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"profile_image_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"project_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"project_networks\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetSearchResponseProjectsItem {
        pub profile_image_url: Option<String>,
        pub project_id: String,
        pub project_name: String,
        pub project_networks: Vec<String>,
    }
    impl From<&GetSearchResponseProjectsItem> for GetSearchResponseProjectsItem {
        fn from(value: &GetSearchResponseProjectsItem) -> Self {
            value.clone()
        }
    }
    #[doc = "GetSystemStatusResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertionDa\","]
    #[doc = "    \"assertionEnforcer\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertionDa\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"operational\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"message\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"operational\": {"]
    #[doc = "          \"type\": \"boolean\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"assertionEnforcer\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"operational\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"message\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"operational\": {"]
    #[doc = "          \"type\": \"boolean\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetSystemStatusResponse {
        #[serde(rename = "assertionDa")]
        pub assertion_da: GetSystemStatusResponseAssertionDa,
        #[serde(rename = "assertionEnforcer")]
        pub assertion_enforcer: GetSystemStatusResponseAssertionEnforcer,
    }
    impl From<&GetSystemStatusResponse> for GetSystemStatusResponse {
        fn from(value: &GetSystemStatusResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetSystemStatusResponseAssertionDa"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"operational\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"operational\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetSystemStatusResponseAssertionDa {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
        pub operational: bool,
    }
    impl From<&GetSystemStatusResponseAssertionDa> for GetSystemStatusResponseAssertionDa {
        fn from(value: &GetSystemStatusResponseAssertionDa) -> Self {
            value.clone()
        }
    }
    #[doc = "GetSystemStatusResponseAssertionEnforcer"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"operational\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"operational\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetSystemStatusResponseAssertionEnforcer {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
        pub operational: bool,
    }
    impl From<&GetSystemStatusResponseAssertionEnforcer> for GetSystemStatusResponseAssertionEnforcer {
        fn from(value: &GetSystemStatusResponseAssertionEnforcer) -> Self {
            value.clone()
        }
    }
    #[doc = "GetTransfersAssertionAdoptersTransferIdResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"error\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetTransfersAssertionAdoptersTransferIdResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub details: Option<String>,
        pub error: String,
    }
    impl From<&GetTransfersAssertionAdoptersTransferIdResponse>
        for GetTransfersAssertionAdoptersTransferIdResponse
    {
        fn from(value: &GetTransfersAssertionAdoptersTransferIdResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetTransfersProjectsTransferIdResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_adopters\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"expires_at\","]
    #[doc = "    \"initial_owner\","]
    #[doc = "    \"new_owner\","]
    #[doc = "    \"project\","]
    #[doc = "    \"project_id\","]
    #[doc = "    \"responded_at\","]
    #[doc = "    \"status\","]
    #[doc = "    \"transfer_id\","]
    #[doc = "    \"updated_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_adopters\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"address\","]
    #[doc = "          \"assertion_adopter_manager\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"address\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"assertion_adopter_manager\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"expires_at\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"initial_owner\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"new_owner\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"project\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"profile_image_url\","]
    #[doc = "        \"project_id\","]
    #[doc = "        \"project_name\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"profile_image_url\": {"]
    #[doc = "          \"type\": ["]
    #[doc = "            \"string\","]
    #[doc = "            \"null\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"project_id\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"project_name\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"responded_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"transfer_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"updated_at\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetTransfersProjectsTransferIdResponse {
        pub assertion_adopters: Vec<GetTransfersProjectsTransferIdResponseAssertionAdoptersItem>,
        pub created_at: String,
        pub expires_at: String,
        pub initial_owner: String,
        pub new_owner: String,
        pub project: GetTransfersProjectsTransferIdResponseProject,
        pub project_id: String,
        pub responded_at: Option<String>,
        pub status: String,
        pub transfer_id: String,
        pub updated_at: String,
    }
    impl From<&GetTransfersProjectsTransferIdResponse> for GetTransfersProjectsTransferIdResponse {
        fn from(value: &GetTransfersProjectsTransferIdResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetTransfersProjectsTransferIdResponseAssertionAdoptersItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"assertion_adopter_manager\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"assertion_adopter_manager\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetTransfersProjectsTransferIdResponseAssertionAdoptersItem {
        pub address: String,
        pub assertion_adopter_manager: String,
    }
    impl From<&GetTransfersProjectsTransferIdResponseAssertionAdoptersItem>
        for GetTransfersProjectsTransferIdResponseAssertionAdoptersItem
    {
        fn from(value: &GetTransfersProjectsTransferIdResponseAssertionAdoptersItem) -> Self {
            value.clone()
        }
    }
    #[doc = "GetTransfersProjectsTransferIdResponseProject"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"profile_image_url\","]
    #[doc = "    \"project_id\","]
    #[doc = "    \"project_name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"profile_image_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"project_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetTransfersProjectsTransferIdResponseProject {
        pub profile_image_url: Option<String>,
        pub project_id: String,
        pub project_name: String,
    }
    impl From<&GetTransfersProjectsTransferIdResponseProject>
        for GetTransfersProjectsTransferIdResponseProject
    {
        fn from(value: &GetTransfersProjectsTransferIdResponseProject) -> Self {
            value.clone()
        }
    }
    #[doc = "GetTransfersResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_adopter_transfers\","]
    #[doc = "    \"project_transfers\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_adopter_transfers\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"project_transfers\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetTransfersResponse {
        pub assertion_adopter_transfers: Vec<String>,
        pub project_transfers: Vec<String>,
    }
    impl From<&GetTransfersResponse> for GetTransfersResponse {
        fn from(value: &GetTransfersResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetTransfersRole"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"sender\","]
    #[doc = "    \"receiver\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetTransfersRole {
        #[serde(rename = "sender")]
        Sender,
        #[serde(rename = "receiver")]
        Receiver,
    }
    impl From<&GetTransfersRole> for GetTransfersRole {
        fn from(value: &GetTransfersRole) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetTransfersRole {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sender => write!(f, "sender"),
                Self::Receiver => write!(f, "receiver"),
            }
        }
    }
    impl std::str::FromStr for GetTransfersRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "sender" => Ok(Self::Sender),
                "receiver" => Ok(Self::Receiver),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for GetTransfersRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for GetTransfersRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for GetTransfersRole {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "GetWebAuthMeResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"scope\","]
    #[doc = "    \"whitelisted\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"scope\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"web\","]
    #[doc = "        \"cli\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"whitelisted\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWebAuthMeResponse {
        pub address: GetWebAuthMeResponseAddress,
        pub scope: GetWebAuthMeResponseScope,
        pub whitelisted: bool,
    }
    impl From<&GetWebAuthMeResponse> for GetWebAuthMeResponse {
        fn from(value: &GetWebAuthMeResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetWebAuthMeResponseAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetWebAuthMeResponseAddress(String);
    impl ::std::ops::Deref for GetWebAuthMeResponseAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetWebAuthMeResponseAddress> for String {
        fn from(value: GetWebAuthMeResponseAddress) -> Self {
            value.0
        }
    }
    impl From<&GetWebAuthMeResponseAddress> for GetWebAuthMeResponseAddress {
        fn from(value: &GetWebAuthMeResponseAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetWebAuthMeResponseAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWebAuthMeResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetWebAuthMeResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetWebAuthMeResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetWebAuthMeResponseAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetWebAuthMeResponseScope"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"web\","]
    #[doc = "    \"cli\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWebAuthMeResponseScope {
        #[serde(rename = "web")]
        Web,
        #[serde(rename = "cli")]
        Cli,
    }
    impl From<&GetWebAuthMeResponseScope> for GetWebAuthMeResponseScope {
        fn from(value: &GetWebAuthMeResponseScope) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWebAuthMeResponseScope {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Web => write!(f, "web"),
                Self::Cli => write!(f, "cli"),
            }
        }
    }
    impl std::str::FromStr for GetWebAuthMeResponseScope {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "web" => Ok(Self::Web),
                "cli" => Ok(Self::Cli),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for GetWebAuthMeResponseScope {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for GetWebAuthMeResponseScope {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for GetWebAuthMeResponseScope {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "GetWebAuthNonceResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"nonce\","]
    #[doc = "    \"ttl\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"nonce\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"ttl\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWebAuthNonceResponse {
        pub nonce: String,
        pub ttl: f64,
    }
    impl From<&GetWebAuthNonceResponse> for GetWebAuthNonceResponse {
        fn from(value: &GetWebAuthNonceResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetWebVerifiedContractAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GetWebVerifiedContractAddress(String);
    impl ::std::ops::Deref for GetWebVerifiedContractAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<GetWebVerifiedContractAddress> for String {
        fn from(value: GetWebVerifiedContractAddress) -> Self {
            value.0
        }
    }
    impl From<&GetWebVerifiedContractAddress> for GetWebVerifiedContractAddress {
        fn from(value: &GetWebVerifiedContractAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetWebVerifiedContractAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWebVerifiedContractAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for GetWebVerifiedContractAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for GetWebVerifiedContractAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetWebVerifiedContractAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "GetWebVerifiedContractResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chainId\","]
    #[doc = "    \"isVerified\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chainId\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"contractName\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"isVerified\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWebVerifiedContractResponse {
        pub address: String,
        #[serde(rename = "chainId")]
        pub chain_id: f64,
        #[serde(
            rename = "contractName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub contract_name: Option<String>,
        #[serde(rename = "isVerified")]
        pub is_verified: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
    }
    impl From<&GetWebVerifiedContractResponse> for GetWebVerifiedContractResponse {
        fn from(value: &GetWebVerifiedContractResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "GetWhitelistResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"whitelisted\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"whitelisted\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWhitelistResponse {
        pub address: String,
        pub whitelisted: bool,
    }
    impl From<&GetWhitelistResponse> for GetWhitelistResponse {
        fn from(value: &GetWhitelistResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PatchTransfersAssertionAdoptersTransferIdBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"action\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"action\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"accept\","]
    #[doc = "        \"reject\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PatchTransfersAssertionAdoptersTransferIdBody {
        pub action: PatchTransfersAssertionAdoptersTransferIdBodyAction,
    }
    impl From<&PatchTransfersAssertionAdoptersTransferIdBody>
        for PatchTransfersAssertionAdoptersTransferIdBody
    {
        fn from(value: &PatchTransfersAssertionAdoptersTransferIdBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PatchTransfersAssertionAdoptersTransferIdBodyAction"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"accept\","]
    #[doc = "    \"reject\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PatchTransfersAssertionAdoptersTransferIdBodyAction {
        #[serde(rename = "accept")]
        Accept,
        #[serde(rename = "reject")]
        Reject,
    }
    impl From<&PatchTransfersAssertionAdoptersTransferIdBodyAction>
        for PatchTransfersAssertionAdoptersTransferIdBodyAction
    {
        fn from(value: &PatchTransfersAssertionAdoptersTransferIdBodyAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PatchTransfersAssertionAdoptersTransferIdBodyAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Accept => write!(f, "accept"),
                Self::Reject => write!(f, "reject"),
            }
        }
    }
    impl std::str::FromStr for PatchTransfersAssertionAdoptersTransferIdBodyAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "accept" => Ok(Self::Accept),
                "reject" => Ok(Self::Reject),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PatchTransfersAssertionAdoptersTransferIdBodyAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PatchTransfersAssertionAdoptersTransferIdBodyAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PatchTransfersAssertionAdoptersTransferIdBodyAction {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "PatchTransfersAssertionAdoptersTransferIdResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PatchTransfersAssertionAdoptersTransferIdResponse {
        pub message: String,
    }
    impl From<&PatchTransfersAssertionAdoptersTransferIdResponse>
        for PatchTransfersAssertionAdoptersTransferIdResponse
    {
        fn from(value: &PatchTransfersAssertionAdoptersTransferIdResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PatchTransfersProjectsTransferIdBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"action\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"action\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"accept\","]
    #[doc = "        \"reject\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PatchTransfersProjectsTransferIdBody {
        pub action: PatchTransfersProjectsTransferIdBodyAction,
    }
    impl From<&PatchTransfersProjectsTransferIdBody> for PatchTransfersProjectsTransferIdBody {
        fn from(value: &PatchTransfersProjectsTransferIdBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PatchTransfersProjectsTransferIdBodyAction"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"accept\","]
    #[doc = "    \"reject\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PatchTransfersProjectsTransferIdBodyAction {
        #[serde(rename = "accept")]
        Accept,
        #[serde(rename = "reject")]
        Reject,
    }
    impl From<&PatchTransfersProjectsTransferIdBodyAction>
        for PatchTransfersProjectsTransferIdBodyAction
    {
        fn from(value: &PatchTransfersProjectsTransferIdBodyAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PatchTransfersProjectsTransferIdBodyAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Accept => write!(f, "accept"),
                Self::Reject => write!(f, "reject"),
            }
        }
    }
    impl std::str::FromStr for PatchTransfersProjectsTransferIdBodyAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "accept" => Ok(Self::Accept),
                "reject" => Ok(Self::Reject),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PatchTransfersProjectsTransferIdBodyAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PatchTransfersProjectsTransferIdBodyAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PatchTransfersProjectsTransferIdBodyAction {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "PatchTransfersProjectsTransferIdResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PatchTransfersProjectsTransferIdResponse {
        pub message: String,
    }
    impl From<&PatchTransfersProjectsTransferIdResponse> for PatchTransfersProjectsTransferIdResponse {
        fn from(value: &PatchTransfersProjectsTransferIdResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostAssertionAdoptersAssignProjectBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_adopter_id\","]
    #[doc = "    \"project_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_adopter_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostAssertionAdoptersAssignProjectBody {
        pub assertion_adopter_id: String,
        pub project_id: uuid::Uuid,
    }
    impl From<&PostAssertionAdoptersAssignProjectBody> for PostAssertionAdoptersAssignProjectBody {
        fn from(value: &PostAssertionAdoptersAssignProjectBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostAssertionAdoptersAssignProjectResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostAssertionAdoptersAssignProjectResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
        pub success: bool,
    }
    impl From<&PostAssertionAdoptersAssignProjectResponse>
        for PostAssertionAdoptersAssignProjectResponse
    {
        fn from(value: &PostAssertionAdoptersAssignProjectResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostCalldataBatchRegisterBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertions\","]
    #[doc = "    \"chainId\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"adminVerifier\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"assertions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"assertion_adopters\","]
    #[doc = "          \"assertion_id\","]
    #[doc = "          \"assertion_metadata\","]
    #[doc = "          \"assertion_proof\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"assertion_adopters\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"pattern\": \"^\\\\d+_0x[a-fA-F0-9]{40}$\""]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"assertion_id\": {"]
    #[doc = "            \"type\": \"string\","]
    #[doc = "            \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "          },"]
    #[doc = "          \"assertion_metadata\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"assertion_proof\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"chainId\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"exclusiveMinimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]*$\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostCalldataBatchRegisterBody {
        #[serde(
            rename = "adminVerifier",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub admin_verifier: Option<PostCalldataBatchRegisterBodyAdminVerifier>,
        pub assertions: Vec<PostCalldataBatchRegisterBodyAssertionsItem>,
        #[serde(rename = "chainId")]
        pub chain_id: std::num::NonZeroU64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub data: Option<PostCalldataBatchRegisterBodyData>,
    }
    impl From<&PostCalldataBatchRegisterBody> for PostCalldataBatchRegisterBody {
        fn from(value: &PostCalldataBatchRegisterBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostCalldataBatchRegisterBodyAdminVerifier"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostCalldataBatchRegisterBodyAdminVerifier(String);
    impl ::std::ops::Deref for PostCalldataBatchRegisterBodyAdminVerifier {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostCalldataBatchRegisterBodyAdminVerifier> for String {
        fn from(value: PostCalldataBatchRegisterBodyAdminVerifier) -> Self {
            value.0
        }
    }
    impl From<&PostCalldataBatchRegisterBodyAdminVerifier>
        for PostCalldataBatchRegisterBodyAdminVerifier
    {
        fn from(value: &PostCalldataBatchRegisterBodyAdminVerifier) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostCalldataBatchRegisterBodyAdminVerifier {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostCalldataBatchRegisterBodyAdminVerifier {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostCalldataBatchRegisterBodyAdminVerifier {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostCalldataBatchRegisterBodyAdminVerifier {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostCalldataBatchRegisterBodyAdminVerifier {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostCalldataBatchRegisterBodyAssertionsItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_adopters\","]
    #[doc = "    \"assertion_id\","]
    #[doc = "    \"assertion_metadata\","]
    #[doc = "    \"assertion_proof\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_adopters\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"pattern\": \"^\\\\d+_0x[a-fA-F0-9]{40}$\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"assertion_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "    },"]
    #[doc = "    \"assertion_metadata\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"assertion_proof\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostCalldataBatchRegisterBodyAssertionsItem {
        pub assertion_adopters:
            Vec<PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem>,
        pub assertion_id: PostCalldataBatchRegisterBodyAssertionsItemAssertionId,
        pub assertion_metadata: String,
        pub assertion_proof: String,
    }
    impl From<&PostCalldataBatchRegisterBodyAssertionsItem>
        for PostCalldataBatchRegisterBodyAssertionsItem
    {
        fn from(value: &PostCalldataBatchRegisterBodyAssertionsItem) -> Self {
            value.clone()
        }
    }
    #[doc = "PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^\\\\d+_0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem(String);
    impl ::std::ops::Deref for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem> for String {
        fn from(value: PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem) -> Self {
            value.0
        }
    }
    impl From<&PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem>
        for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem
    {
        fn from(value: &PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^\\d+_0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^\\d+_0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str>
        for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String>
        for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String>
        for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem
    {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for PostCalldataBatchRegisterBodyAssertionsItemAssertionAdoptersItem
    {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostCalldataBatchRegisterBodyAssertionsItemAssertionId"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostCalldataBatchRegisterBodyAssertionsItemAssertionId(String);
    impl ::std::ops::Deref for PostCalldataBatchRegisterBodyAssertionsItemAssertionId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostCalldataBatchRegisterBodyAssertionsItemAssertionId> for String {
        fn from(value: PostCalldataBatchRegisterBodyAssertionsItemAssertionId) -> Self {
            value.0
        }
    }
    impl From<&PostCalldataBatchRegisterBodyAssertionsItemAssertionId>
        for PostCalldataBatchRegisterBodyAssertionsItemAssertionId
    {
        fn from(value: &PostCalldataBatchRegisterBodyAssertionsItemAssertionId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostCalldataBatchRegisterBodyAssertionsItemAssertionId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{64}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostCalldataBatchRegisterBodyAssertionsItemAssertionId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostCalldataBatchRegisterBodyAssertionsItemAssertionId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostCalldataBatchRegisterBodyAssertionsItemAssertionId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostCalldataBatchRegisterBodyAssertionsItemAssertionId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostCalldataBatchRegisterBodyData"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]*$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostCalldataBatchRegisterBodyData(String);
    impl ::std::ops::Deref for PostCalldataBatchRegisterBodyData {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostCalldataBatchRegisterBodyData> for String {
        fn from(value: PostCalldataBatchRegisterBodyData) -> Self {
            value.0
        }
    }
    impl From<&PostCalldataBatchRegisterBodyData> for PostCalldataBatchRegisterBodyData {
        fn from(value: &PostCalldataBatchRegisterBodyData) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostCalldataBatchRegisterBodyData {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]*$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]*$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostCalldataBatchRegisterBodyData {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostCalldataBatchRegisterBodyData {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostCalldataBatchRegisterBodyData {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostCalldataBatchRegisterBodyData {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostCalldataBatchRegisterResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"calldata\","]
    #[doc = "    \"registered_adopters\","]
    #[doc = "    \"registered_assertions\","]
    #[doc = "    \"total_calldata\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"calldata\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"registered_adopters\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"registered_assertions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"total_calldata\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostCalldataBatchRegisterResponse {
        pub calldata: Vec<String>,
        pub registered_adopters: Vec<String>,
        pub registered_assertions: Vec<String>,
        pub total_calldata: f64,
    }
    impl From<&PostCalldataBatchRegisterResponse> for PostCalldataBatchRegisterResponse {
        fn from(value: &PostCalldataBatchRegisterResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostCliAuthRefreshBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"refresh_token\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"refresh_token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostCliAuthRefreshBody {
        pub refresh_token: String,
    }
    impl From<&PostCliAuthRefreshBody> for PostCliAuthRefreshBody {
        fn from(value: &PostCliAuthRefreshBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostCliAuthRefreshResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"token\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostCliAuthRefreshResponse {
        pub token: String,
    }
    impl From<&PostCliAuthRefreshResponse> for PostCliAuthRefreshResponse {
        fn from(value: &PostCliAuthRefreshResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostCliAuthVerifyBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"code\","]
    #[doc = "    \"sessionId\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 6,"]
    #[doc = "      \"minLength\": 6"]
    #[doc = "    },"]
    #[doc = "    \"sessionId\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostCliAuthVerifyBody {
        pub code: PostCliAuthVerifyBodyCode,
        #[serde(rename = "sessionId")]
        pub session_id: uuid::Uuid,
    }
    impl From<&PostCliAuthVerifyBody> for PostCliAuthVerifyBody {
        fn from(value: &PostCliAuthVerifyBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostCliAuthVerifyBodyCode"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 6,"]
    #[doc = "  \"minLength\": 6"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostCliAuthVerifyBodyCode(String);
    impl ::std::ops::Deref for PostCliAuthVerifyBodyCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostCliAuthVerifyBodyCode> for String {
        fn from(value: PostCliAuthVerifyBodyCode) -> Self {
            value.0
        }
    }
    impl From<&PostCliAuthVerifyBodyCode> for PostCliAuthVerifyBodyCode {
        fn from(value: &PostCliAuthVerifyBodyCode) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostCliAuthVerifyBodyCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 6usize {
                return Err("longer than 6 characters".into());
            }
            if value.len() < 6usize {
                return Err("shorter than 6 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostCliAuthVerifyBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostCliAuthVerifyBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostCliAuthVerifyBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostCliAuthVerifyBodyCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostCliAuthVerifyResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostCliAuthVerifyResponse {
        pub address: PostCliAuthVerifyResponseAddress,
        pub success: bool,
    }
    impl From<&PostCliAuthVerifyResponse> for PostCliAuthVerifyResponse {
        fn from(value: &PostCliAuthVerifyResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostCliAuthVerifyResponseAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostCliAuthVerifyResponseAddress(String);
    impl ::std::ops::Deref for PostCliAuthVerifyResponseAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostCliAuthVerifyResponseAddress> for String {
        fn from(value: PostCliAuthVerifyResponseAddress) -> Self {
            value.0
        }
    }
    impl From<&PostCliAuthVerifyResponseAddress> for PostCliAuthVerifyResponseAddress {
        fn from(value: &PostCliAuthVerifyResponseAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostCliAuthVerifyResponseAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostCliAuthVerifyResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostCliAuthVerifyResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostCliAuthVerifyResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostCliAuthVerifyResponseAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostProjectsBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"chain_id\","]
    #[doc = "    \"project_name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_adopters\": {"]
    #[doc = "      \"default\": [],"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"exclusiveMinimum\": 0.0"]
    #[doc = "    },"]
    #[doc = "    \"profile_image_url\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uri\""]
    #[doc = "    },"]
    #[doc = "    \"project_description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"maxLength\": 1000"]
    #[doc = "    },"]
    #[doc = "    \"project_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostProjectsBody {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assertion_adopters: Vec<PostProjectsBodyAssertionAdoptersItem>,
        pub chain_id: std::num::NonZeroU64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub profile_image_url: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_description: Option<PostProjectsBodyProjectDescription>,
        pub project_name: PostProjectsBodyProjectName,
    }
    impl From<&PostProjectsBody> for PostProjectsBody {
        fn from(value: &PostProjectsBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostProjectsBodyAssertionAdoptersItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostProjectsBodyAssertionAdoptersItem(String);
    impl ::std::ops::Deref for PostProjectsBodyAssertionAdoptersItem {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostProjectsBodyAssertionAdoptersItem> for String {
        fn from(value: PostProjectsBodyAssertionAdoptersItem) -> Self {
            value.0
        }
    }
    impl From<&PostProjectsBodyAssertionAdoptersItem> for PostProjectsBodyAssertionAdoptersItem {
        fn from(value: &PostProjectsBodyAssertionAdoptersItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostProjectsBodyAssertionAdoptersItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostProjectsBodyAssertionAdoptersItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostProjectsBodyAssertionAdoptersItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostProjectsBodyAssertionAdoptersItem {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostProjectsBodyAssertionAdoptersItem {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostProjectsBodyProjectDescription"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 1000"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostProjectsBodyProjectDescription(String);
    impl ::std::ops::Deref for PostProjectsBodyProjectDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostProjectsBodyProjectDescription> for String {
        fn from(value: PostProjectsBodyProjectDescription) -> Self {
            value.0
        }
    }
    impl From<&PostProjectsBodyProjectDescription> for PostProjectsBodyProjectDescription {
        fn from(value: &PostProjectsBodyProjectDescription) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostProjectsBodyProjectDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 1000usize {
                return Err("longer than 1000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostProjectsBodyProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostProjectsBodyProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostProjectsBodyProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostProjectsBodyProjectDescription {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostProjectsBodyProjectName"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostProjectsBodyProjectName(String);
    impl ::std::ops::Deref for PostProjectsBodyProjectName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostProjectsBodyProjectName> for String {
        fn from(value: PostProjectsBodyProjectName) -> Self {
            value.0
        }
    }
    impl From<&PostProjectsBodyProjectName> for PostProjectsBodyProjectName {
        fn from(value: &PostProjectsBodyProjectName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostProjectsBodyProjectName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostProjectsBodyProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostProjectsBodyProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostProjectsBodyProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostProjectsBodyProjectName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostProjectsProjectIdRegisteredAssertionsBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertions\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"assertion_adopters\","]
    #[doc = "          \"assertion_id\","]
    #[doc = "          \"registered_address\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"assertion_adopters\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"oneOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"object\","]
    #[doc = "                  \"required\": ["]
    #[doc = "                    \"id\""]
    #[doc = "                  ],"]
    #[doc = "                  \"properties\": {"]
    #[doc = "                    \"id\": {"]
    #[doc = "                      \"type\": \"string\""]
    #[doc = "                    }"]
    #[doc = "                  }"]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"object\","]
    #[doc = "                  \"required\": ["]
    #[doc = "                    \"address\""]
    #[doc = "                  ],"]
    #[doc = "                  \"properties\": {"]
    #[doc = "                    \"address\": {"]
    #[doc = "                      \"type\": \"string\","]
    #[doc = "                      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "                    },"]
    #[doc = "                    \"network\": {"]
    #[doc = "                      \"oneOf\": ["]
    #[doc = "                        {"]
    #[doc = "                          \"type\": \"string\""]
    #[doc = "                        },"]
    #[doc = "                        {"]
    #[doc = "                          \"type\": \"number\""]
    #[doc = "                        }"]
    #[doc = "                      ]"]
    #[doc = "                    }"]
    #[doc = "                  }"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"assertion_id\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"registered_address\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostProjectsProjectIdRegisteredAssertionsBody {
        pub assertions: Vec<PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signature: Option<String>,
    }
    impl From<&PostProjectsProjectIdRegisteredAssertionsBody>
        for PostProjectsProjectIdRegisteredAssertionsBody
    {
        fn from(value: &PostProjectsProjectIdRegisteredAssertionsBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_adopters\","]
    #[doc = "    \"assertion_id\","]
    #[doc = "    \"registered_address\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_adopters\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"oneOf\": ["]
    #[doc = "          {"]
    #[doc = "            \"type\": \"object\","]
    #[doc = "            \"required\": ["]
    #[doc = "              \"id\""]
    #[doc = "            ],"]
    #[doc = "            \"properties\": {"]
    #[doc = "              \"id\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              }"]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"type\": \"object\","]
    #[doc = "            \"required\": ["]
    #[doc = "              \"address\""]
    #[doc = "            ],"]
    #[doc = "            \"properties\": {"]
    #[doc = "              \"address\": {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "              },"]
    #[doc = "              \"network\": {"]
    #[doc = "                \"oneOf\": ["]
    #[doc = "                  {"]
    #[doc = "                    \"type\": \"string\""]
    #[doc = "                  },"]
    #[doc = "                  {"]
    #[doc = "                    \"type\": \"number\""]
    #[doc = "                  }"]
    #[doc = "                ]"]
    #[doc = "              }"]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        ]"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"assertion_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"registered_address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem {
        pub assertion_adopters:
            Vec<PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem>,
        pub assertion_id: String,
        pub registered_address: String,
    }
    impl From<&PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem>
        for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem
    {
        fn from(value: &PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItem) -> Self {
            value.clone()
        }
    }
    #[doc = "PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"id\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"id\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"address\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"address\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "        },"]
    #[doc = "        \"network\": {"]
    #[doc = "          \"oneOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"number\""]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem {
        Variant0 { id : String , } , Variant1 { address : PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address , # [serde (default , skip_serializing_if = "Option::is_none")] network : Option < PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network > , } , }
    impl From<&PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem>
        for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem
    {
        fn from(
            value : & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItem,
        ) -> Self {
            value.clone()
        }
    }
    #[doc = "PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address(
        String,
    );
    impl :: std :: ops :: Deref for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { type Target = String ; fn deref (& self) -> & String { & self . 0 } }
    impl From < PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address > for String { fn from (value : PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address) -> Self { value . 0 } }
    impl From < & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { fn from (value : & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address) -> Self { value . clone () } }
    impl :: std :: str :: FromStr for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if regress :: Regex :: new ("^0x[a-fA-F0-9]{40}$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"" . into ()) ; } Ok (Self (value . to_string ())) } }
    impl :: std :: convert :: TryFrom < & str > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl :: std :: convert :: TryFrom < & String > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl :: std :: convert :: TryFrom < String > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl < 'de > :: serde :: Deserialize < 'de > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Address { fn deserialize < D > (deserializer : D ,) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } }
    #[doc = "PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network
    {
        Variant0(String),
        Variant1(f64),
    }
    impl From < & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { fn from (value : & PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network) -> Self { value . clone () } }
    impl std :: str :: FromStr for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { if let Ok (v) = value . parse () { Ok (Self :: Variant0 (v)) } else if let Ok (v) = value . parse () { Ok (Self :: Variant1 (v)) } else { Err ("string conversion failed for all variants" . into ()) } } }
    impl std :: convert :: TryFrom < & str > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl std :: convert :: TryFrom < & String > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl std :: convert :: TryFrom < String > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } }
    impl :: std :: fmt :: Display for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { Self :: Variant0 (x) => x . fmt (f) , Self :: Variant1 (x) => x . fmt (f) , } } }
    impl From < f64 > for PostProjectsProjectIdRegisteredAssertionsBodyAssertionsItemAssertionAdoptersItemVariant1Network { fn from (value : f64) -> Self { Self :: Variant1 (value) } }
    #[doc = "PostProjectsProjectIdRegisteredAssertionsResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostProjectsProjectIdRegisteredAssertionsResponse {
        pub success: bool,
    }
    impl From<&PostProjectsProjectIdRegisteredAssertionsResponse>
        for PostProjectsProjectIdRegisteredAssertionsResponse
    {
        fn from(value: &PostProjectsProjectIdRegisteredAssertionsResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostProjectsProjectIdSubmittedAssertionsBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertions\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"assertion_id\","]
    #[doc = "          \"contract_name\","]
    #[doc = "          \"signature\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"assertion_id\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"bytecode\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"contract_name\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"signature\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"source_code\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostProjectsProjectIdSubmittedAssertionsBody {
        pub assertions: Vec<PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem>,
    }
    impl From<&PostProjectsProjectIdSubmittedAssertionsBody>
        for PostProjectsProjectIdSubmittedAssertionsBody
    {
        fn from(value: &PostProjectsProjectIdSubmittedAssertionsBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_id\","]
    #[doc = "    \"contract_name\","]
    #[doc = "    \"signature\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"bytecode\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"contract_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"source_code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem {
        pub assertion_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub bytecode: Option<String>,
        pub contract_name: String,
        pub signature: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source_code: Option<String>,
    }
    impl From<&PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem>
        for PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem
    {
        fn from(value: &PostProjectsProjectIdSubmittedAssertionsBodyAssertionsItem) -> Self {
            value.clone()
        }
    }
    #[doc = "PostProjectsProjectIdSubmittedAssertionsResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostProjectsProjectIdSubmittedAssertionsResponse {
        pub success: bool,
    }
    impl From<&PostProjectsProjectIdSubmittedAssertionsResponse>
        for PostProjectsProjectIdSubmittedAssertionsResponse
    {
        fn from(value: &PostProjectsProjectIdSubmittedAssertionsResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostProjectsResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"project_id\","]
    #[doc = "    \"project_manager\","]
    #[doc = "    \"project_name\","]
    #[doc = "    \"project_networks\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"profile_image_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uri\""]
    #[doc = "    },"]
    #[doc = "    \"project_description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"maxLength\": 1000"]
    #[doc = "    },"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"project_manager\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"project_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    },"]
    #[doc = "    \"project_networks\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"saved_count\": {"]
    #[doc = "      \"default\": 0,"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostProjectsResponse {
        pub created_at: chrono::DateTime<chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub profile_image_url: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_description: Option<PostProjectsResponseProjectDescription>,
        pub project_id: uuid::Uuid,
        pub project_manager: PostProjectsResponseProjectManager,
        pub project_name: PostProjectsResponseProjectName,
        pub project_networks: Vec<String>,
        #[serde(default)]
        pub saved_count: u64,
    }
    impl From<&PostProjectsResponse> for PostProjectsResponse {
        fn from(value: &PostProjectsResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostProjectsResponseProjectDescription"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 1000"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostProjectsResponseProjectDescription(String);
    impl ::std::ops::Deref for PostProjectsResponseProjectDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostProjectsResponseProjectDescription> for String {
        fn from(value: PostProjectsResponseProjectDescription) -> Self {
            value.0
        }
    }
    impl From<&PostProjectsResponseProjectDescription> for PostProjectsResponseProjectDescription {
        fn from(value: &PostProjectsResponseProjectDescription) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostProjectsResponseProjectDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 1000usize {
                return Err("longer than 1000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostProjectsResponseProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostProjectsResponseProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostProjectsResponseProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostProjectsResponseProjectDescription {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostProjectsResponseProjectManager"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostProjectsResponseProjectManager(String);
    impl ::std::ops::Deref for PostProjectsResponseProjectManager {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostProjectsResponseProjectManager> for String {
        fn from(value: PostProjectsResponseProjectManager) -> Self {
            value.0
        }
    }
    impl From<&PostProjectsResponseProjectManager> for PostProjectsResponseProjectManager {
        fn from(value: &PostProjectsResponseProjectManager) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostProjectsResponseProjectManager {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostProjectsResponseProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostProjectsResponseProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostProjectsResponseProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostProjectsResponseProjectManager {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostProjectsResponseProjectName"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostProjectsResponseProjectName(String);
    impl ::std::ops::Deref for PostProjectsResponseProjectName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostProjectsResponseProjectName> for String {
        fn from(value: PostProjectsResponseProjectName) -> Self {
            value.0
        }
    }
    impl From<&PostProjectsResponseProjectName> for PostProjectsResponseProjectName {
        fn from(value: &PostProjectsResponseProjectName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostProjectsResponseProjectName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostProjectsResponseProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostProjectsResponseProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostProjectsResponseProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostProjectsResponseProjectName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostProjectsSavedBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"project_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostProjectsSavedBody {
        pub project_id: uuid::Uuid,
    }
    impl From<&PostProjectsSavedBody> for PostProjectsSavedBody {
        fn from(value: &PostProjectsSavedBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostProjectsSavedResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostProjectsSavedResponse {
        pub success: bool,
    }
    impl From<&PostProjectsSavedResponse> for PostProjectsSavedResponse {
        fn from(value: &PostProjectsSavedResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostTransfersAssertionAdoptersBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"assertion_adopter_address\","]
    #[doc = "    \"destination_project_id\","]
    #[doc = "    \"network\","]
    #[doc = "    \"recipient_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_adopter_address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"destination_project_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"network\": {"]
    #[doc = "      \"oneOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"recipient_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostTransfersAssertionAdoptersBody {
        pub assertion_adopter_address: String,
        pub destination_project_id: String,
        pub network: PostTransfersAssertionAdoptersBodyNetwork,
        pub recipient_id: String,
    }
    impl From<&PostTransfersAssertionAdoptersBody> for PostTransfersAssertionAdoptersBody {
        fn from(value: &PostTransfersAssertionAdoptersBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostTransfersAssertionAdoptersBodyNetwork"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PostTransfersAssertionAdoptersBodyNetwork {
        Variant0(String),
        Variant1(f64),
    }
    impl From<&PostTransfersAssertionAdoptersBodyNetwork>
        for PostTransfersAssertionAdoptersBodyNetwork
    {
        fn from(value: &PostTransfersAssertionAdoptersBodyNetwork) -> Self {
            value.clone()
        }
    }
    impl std::str::FromStr for PostTransfersAssertionAdoptersBodyNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Variant0(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Variant1(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostTransfersAssertionAdoptersBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostTransfersAssertionAdoptersBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostTransfersAssertionAdoptersBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for PostTransfersAssertionAdoptersBodyNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl From<f64> for PostTransfersAssertionAdoptersBodyNetwork {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "PostTransfersAssertionAdoptersResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"transfer_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"transfer_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostTransfersAssertionAdoptersResponse {
        pub transfer_id: uuid::Uuid,
    }
    impl From<&PostTransfersAssertionAdoptersResponse> for PostTransfersAssertionAdoptersResponse {
        fn from(value: &PostTransfersAssertionAdoptersResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostTransfersBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"recipient_id\","]
    #[doc = "    \"resource_id\","]
    #[doc = "    \"resource_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"destination_project_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"network\": {"]
    #[doc = "      \"oneOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"recipient_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"resource_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"resource_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"project\","]
    #[doc = "        \"assertion_adopter\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostTransfersBody {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub destination_project_id: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network: Option<PostTransfersBodyNetwork>,
        pub recipient_id: String,
        pub resource_id: String,
        pub resource_type: PostTransfersBodyResourceType,
    }
    impl From<&PostTransfersBody> for PostTransfersBody {
        fn from(value: &PostTransfersBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostTransfersBodyNetwork"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PostTransfersBodyNetwork {
        Variant0(String),
        Variant1(f64),
    }
    impl From<&PostTransfersBodyNetwork> for PostTransfersBodyNetwork {
        fn from(value: &PostTransfersBodyNetwork) -> Self {
            value.clone()
        }
    }
    impl std::str::FromStr for PostTransfersBodyNetwork {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Variant0(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Variant1(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostTransfersBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostTransfersBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostTransfersBodyNetwork {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for PostTransfersBodyNetwork {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl From<f64> for PostTransfersBodyNetwork {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "PostTransfersBodyResourceType"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"project\","]
    #[doc = "    \"assertion_adopter\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PostTransfersBodyResourceType {
        #[serde(rename = "project")]
        Project,
        #[serde(rename = "assertion_adopter")]
        AssertionAdopter,
    }
    impl From<&PostTransfersBodyResourceType> for PostTransfersBodyResourceType {
        fn from(value: &PostTransfersBodyResourceType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PostTransfersBodyResourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Project => write!(f, "project"),
                Self::AssertionAdopter => write!(f, "assertion_adopter"),
            }
        }
    }
    impl std::str::FromStr for PostTransfersBodyResourceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "project" => Ok(Self::Project),
                "assertion_adopter" => Ok(Self::AssertionAdopter),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostTransfersBodyResourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostTransfersBodyResourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostTransfersBodyResourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "PostTransfersProjectsBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"project_id\","]
    #[doc = "    \"recipient_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"recipient_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostTransfersProjectsBody {
        pub project_id: uuid::Uuid,
        pub recipient_id: PostTransfersProjectsBodyRecipientId,
    }
    impl From<&PostTransfersProjectsBody> for PostTransfersProjectsBody {
        fn from(value: &PostTransfersProjectsBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostTransfersProjectsBodyRecipientId"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostTransfersProjectsBodyRecipientId(String);
    impl ::std::ops::Deref for PostTransfersProjectsBodyRecipientId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostTransfersProjectsBodyRecipientId> for String {
        fn from(value: PostTransfersProjectsBodyRecipientId) -> Self {
            value.0
        }
    }
    impl From<&PostTransfersProjectsBodyRecipientId> for PostTransfersProjectsBodyRecipientId {
        fn from(value: &PostTransfersProjectsBodyRecipientId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostTransfersProjectsBodyRecipientId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostTransfersProjectsBodyRecipientId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostTransfersProjectsBodyRecipientId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostTransfersProjectsBodyRecipientId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostTransfersProjectsBodyRecipientId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostTransfersProjectsResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"transfer_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"transfer_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostTransfersProjectsResponse {
        pub transfer_id: uuid::Uuid,
    }
    impl From<&PostTransfersProjectsResponse> for PostTransfersProjectsResponse {
        fn from(value: &PostTransfersProjectsResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostTransfersResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"transfer_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"transfer_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostTransfersResponse {
        pub transfer_id: uuid::Uuid,
    }
    impl From<&PostTransfersResponse> for PostTransfersResponse {
        fn from(value: &PostTransfersResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostWebAuthLogoutResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostWebAuthLogoutResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
        pub success: bool,
    }
    impl From<&PostWebAuthLogoutResponse> for PostWebAuthLogoutResponse {
        fn from(value: &PostWebAuthLogoutResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostWebAuthRefreshBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"refresh_token\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"refresh_token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostWebAuthRefreshBody {
        pub refresh_token: String,
    }
    impl From<&PostWebAuthRefreshBody> for PostWebAuthRefreshBody {
        fn from(value: &PostWebAuthRefreshBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostWebAuthRefreshResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"access_token\","]
    #[doc = "    \"expires_in\","]
    #[doc = "    \"refresh_token\","]
    #[doc = "    \"token_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"access_token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"expires_in\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"refresh_token\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"token_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"Bearer\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostWebAuthRefreshResponse {
        pub access_token: String,
        pub expires_in: f64,
        pub refresh_token: String,
        pub token_type: PostWebAuthRefreshResponseTokenType,
    }
    impl From<&PostWebAuthRefreshResponse> for PostWebAuthRefreshResponse {
        fn from(value: &PostWebAuthRefreshResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostWebAuthRefreshResponseTokenType"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"Bearer\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PostWebAuthRefreshResponseTokenType {
        Bearer,
    }
    impl From<&PostWebAuthRefreshResponseTokenType> for PostWebAuthRefreshResponseTokenType {
        fn from(value: &PostWebAuthRefreshResponseTokenType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PostWebAuthRefreshResponseTokenType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bearer => write!(f, "Bearer"),
            }
        }
    }
    impl std::str::FromStr for PostWebAuthRefreshResponseTokenType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "Bearer" => Ok(Self::Bearer),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl std::convert::TryFrom<&str> for PostWebAuthRefreshResponseTokenType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<&String> for PostWebAuthRefreshResponseTokenType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl std::convert::TryFrom<String> for PostWebAuthRefreshResponseTokenType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "PostWebAuthVerifyBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"message\","]
    #[doc = "    \"signature\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostWebAuthVerifyBody {
        pub message: String,
        pub signature: String,
    }
    impl From<&PostWebAuthVerifyBody> for PostWebAuthVerifyBody {
        fn from(value: &PostWebAuthVerifyBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostWebAuthVerifyResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"success\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"success\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostWebAuthVerifyResponse {
        pub address: PostWebAuthVerifyResponseAddress,
        pub success: bool,
    }
    impl From<&PostWebAuthVerifyResponse> for PostWebAuthVerifyResponse {
        fn from(value: &PostWebAuthVerifyResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostWebAuthVerifyResponseAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostWebAuthVerifyResponseAddress(String);
    impl ::std::ops::Deref for PostWebAuthVerifyResponseAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostWebAuthVerifyResponseAddress> for String {
        fn from(value: PostWebAuthVerifyResponseAddress) -> Self {
            value.0
        }
    }
    impl From<&PostWebAuthVerifyResponseAddress> for PostWebAuthVerifyResponseAddress {
        fn from(value: &PostWebAuthVerifyResponseAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostWebAuthVerifyResponseAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostWebAuthVerifyResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostWebAuthVerifyResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostWebAuthVerifyResponseAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostWebAuthVerifyResponseAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostWebFaucetBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"amount\": {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"exclusiveMinimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostWebFaucetBody {
        pub address: PostWebFaucetBodyAddress,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub amount: Option<f64>,
    }
    impl From<&PostWebFaucetBody> for PostWebFaucetBody {
        fn from(value: &PostWebFaucetBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PostWebFaucetBodyAddress"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostWebFaucetBodyAddress(String);
    impl ::std::ops::Deref for PostWebFaucetBodyAddress {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostWebFaucetBodyAddress> for String {
        fn from(value: PostWebFaucetBodyAddress) -> Self {
            value.0
        }
    }
    impl From<&PostWebFaucetBodyAddress> for PostWebFaucetBodyAddress {
        fn from(value: &PostWebFaucetBodyAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostWebFaucetBodyAddress {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostWebFaucetBodyAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostWebFaucetBodyAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostWebFaucetBodyAddress {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostWebFaucetBodyAddress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostWebFaucetResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"amount\","]
    #[doc = "    \"recipient\","]
    #[doc = "    \"txHash\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"amount\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"recipient\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"txHash\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PostWebFaucetResponse {
        pub amount: String,
        pub recipient: PostWebFaucetResponseRecipient,
        #[serde(rename = "txHash")]
        pub tx_hash: PostWebFaucetResponseTxHash,
    }
    impl From<&PostWebFaucetResponse> for PostWebFaucetResponse {
        fn from(value: &PostWebFaucetResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PostWebFaucetResponseRecipient"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostWebFaucetResponseRecipient(String);
    impl ::std::ops::Deref for PostWebFaucetResponseRecipient {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostWebFaucetResponseRecipient> for String {
        fn from(value: PostWebFaucetResponseRecipient) -> Self {
            value.0
        }
    }
    impl From<&PostWebFaucetResponseRecipient> for PostWebFaucetResponseRecipient {
        fn from(value: &PostWebFaucetResponseRecipient) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostWebFaucetResponseRecipient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostWebFaucetResponseRecipient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostWebFaucetResponseRecipient {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostWebFaucetResponseRecipient {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostWebFaucetResponseRecipient {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PostWebFaucetResponseTxHash"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{64}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PostWebFaucetResponseTxHash(String);
    impl ::std::ops::Deref for PostWebFaucetResponseTxHash {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PostWebFaucetResponseTxHash> for String {
        fn from(value: PostWebFaucetResponseTxHash) -> Self {
            value.0
        }
    }
    impl From<&PostWebFaucetResponseTxHash> for PostWebFaucetResponseTxHash {
        fn from(value: &PostWebFaucetResponseTxHash) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PostWebFaucetResponseTxHash {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{64}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{64}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PostWebFaucetResponseTxHash {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PostWebFaucetResponseTxHash {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PostWebFaucetResponseTxHash {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PostWebFaucetResponseTxHash {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PutProjectsProjectIdBody"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"assertion_adopters\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"oneOf\": ["]
    #[doc = "          {"]
    #[doc = "            \"type\": \"string\","]
    #[doc = "            \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"type\": \"object\","]
    #[doc = "            \"required\": ["]
    #[doc = "              \"address\","]
    #[doc = "              \"network\""]
    #[doc = "            ],"]
    #[doc = "            \"properties\": {"]
    #[doc = "              \"address\": {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "              },"]
    #[doc = "              \"contract_name\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              },"]
    #[doc = "              \"network\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              }"]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        ]"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"profile_image_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uri\""]
    #[doc = "    },"]
    #[doc = "    \"project_description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"maxLength\": 1000"]
    #[doc = "    },"]
    #[doc = "    \"project_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PutProjectsProjectIdBody {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assertion_adopters: Vec<PutProjectsProjectIdBodyAssertionAdoptersItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub profile_image_url: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_description: Option<PutProjectsProjectIdBodyProjectDescription>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_name: Option<PutProjectsProjectIdBodyProjectName>,
    }
    impl From<&PutProjectsProjectIdBody> for PutProjectsProjectIdBody {
        fn from(value: &PutProjectsProjectIdBody) -> Self {
            value.clone()
        }
    }
    #[doc = "PutProjectsProjectIdBodyAssertionAdoptersItem"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"address\","]
    #[doc = "        \"network\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"address\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "        },"]
    #[doc = "        \"contract_name\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"network\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PutProjectsProjectIdBodyAssertionAdoptersItem {
        Variant0(PutProjectsProjectIdBodyAssertionAdoptersItemVariant0),
        Variant1 {
            address: PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            contract_name: Option<String>,
            network: String,
        },
    }
    impl From<&PutProjectsProjectIdBodyAssertionAdoptersItem>
        for PutProjectsProjectIdBodyAssertionAdoptersItem
    {
        fn from(value: &PutProjectsProjectIdBodyAssertionAdoptersItem) -> Self {
            value.clone()
        }
    }
    impl From<PutProjectsProjectIdBodyAssertionAdoptersItemVariant0>
        for PutProjectsProjectIdBodyAssertionAdoptersItem
    {
        fn from(value: PutProjectsProjectIdBodyAssertionAdoptersItemVariant0) -> Self {
            Self::Variant0(value)
        }
    }
    #[doc = "PutProjectsProjectIdBodyAssertionAdoptersItemVariant0"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PutProjectsProjectIdBodyAssertionAdoptersItemVariant0(String);
    impl ::std::ops::Deref for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PutProjectsProjectIdBodyAssertionAdoptersItemVariant0> for String {
        fn from(value: PutProjectsProjectIdBodyAssertionAdoptersItemVariant0) -> Self {
            value.0
        }
    }
    impl From<&PutProjectsProjectIdBodyAssertionAdoptersItemVariant0>
        for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0
    {
        fn from(value: &PutProjectsProjectIdBodyAssertionAdoptersItemVariant0) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PutProjectsProjectIdBodyAssertionAdoptersItemVariant0 {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address(String);
    impl ::std::ops::Deref for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address> for String {
        fn from(value: PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address) -> Self {
            value.0
        }
    }
    impl From<&PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address>
        for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address
    {
        fn from(value: &PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str>
        for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String>
        for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String>
        for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address
    {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for PutProjectsProjectIdBodyAssertionAdoptersItemVariant1Address
    {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PutProjectsProjectIdBodyProjectDescription"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 1000"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PutProjectsProjectIdBodyProjectDescription(String);
    impl ::std::ops::Deref for PutProjectsProjectIdBodyProjectDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PutProjectsProjectIdBodyProjectDescription> for String {
        fn from(value: PutProjectsProjectIdBodyProjectDescription) -> Self {
            value.0
        }
    }
    impl From<&PutProjectsProjectIdBodyProjectDescription>
        for PutProjectsProjectIdBodyProjectDescription
    {
        fn from(value: &PutProjectsProjectIdBodyProjectDescription) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PutProjectsProjectIdBodyProjectDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 1000usize {
                return Err("longer than 1000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PutProjectsProjectIdBodyProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PutProjectsProjectIdBodyProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PutProjectsProjectIdBodyProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PutProjectsProjectIdBodyProjectDescription {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PutProjectsProjectIdBodyProjectName"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PutProjectsProjectIdBodyProjectName(String);
    impl ::std::ops::Deref for PutProjectsProjectIdBodyProjectName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PutProjectsProjectIdBodyProjectName> for String {
        fn from(value: PutProjectsProjectIdBodyProjectName) -> Self {
            value.0
        }
    }
    impl From<&PutProjectsProjectIdBodyProjectName> for PutProjectsProjectIdBodyProjectName {
        fn from(value: &PutProjectsProjectIdBodyProjectName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PutProjectsProjectIdBodyProjectName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PutProjectsProjectIdBodyProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PutProjectsProjectIdBodyProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PutProjectsProjectIdBodyProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PutProjectsProjectIdBodyProjectName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PutProjectsProjectIdResponse"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"project_id\","]
    #[doc = "    \"project_manager\","]
    #[doc = "    \"project_name\","]
    #[doc = "    \"project_networks\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"date-time\""]
    #[doc = "    },"]
    #[doc = "    \"profile_image_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"format\": \"uri\""]
    #[doc = "    },"]
    #[doc = "    \"project_description\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"maxLength\": 1000"]
    #[doc = "    },"]
    #[doc = "    \"project_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uuid\""]
    #[doc = "    },"]
    #[doc = "    \"project_manager\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "    },"]
    #[doc = "    \"project_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    },"]
    #[doc = "    \"project_networks\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"saved_count\": {"]
    #[doc = "      \"default\": 0,"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PutProjectsProjectIdResponse {
        pub created_at: chrono::DateTime<chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub profile_image_url: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_description: Option<PutProjectsProjectIdResponseProjectDescription>,
        pub project_id: uuid::Uuid,
        pub project_manager: PutProjectsProjectIdResponseProjectManager,
        pub project_name: PutProjectsProjectIdResponseProjectName,
        pub project_networks: Vec<String>,
        #[serde(default)]
        pub saved_count: u64,
    }
    impl From<&PutProjectsProjectIdResponse> for PutProjectsProjectIdResponse {
        fn from(value: &PutProjectsProjectIdResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "PutProjectsProjectIdResponseProjectDescription"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 1000"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PutProjectsProjectIdResponseProjectDescription(String);
    impl ::std::ops::Deref for PutProjectsProjectIdResponseProjectDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PutProjectsProjectIdResponseProjectDescription> for String {
        fn from(value: PutProjectsProjectIdResponseProjectDescription) -> Self {
            value.0
        }
    }
    impl From<&PutProjectsProjectIdResponseProjectDescription>
        for PutProjectsProjectIdResponseProjectDescription
    {
        fn from(value: &PutProjectsProjectIdResponseProjectDescription) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PutProjectsProjectIdResponseProjectDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 1000usize {
                return Err("longer than 1000 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PutProjectsProjectIdResponseProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PutProjectsProjectIdResponseProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PutProjectsProjectIdResponseProjectDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PutProjectsProjectIdResponseProjectDescription {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PutProjectsProjectIdResponseProjectManager"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^0x[a-fA-F0-9]{40}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PutProjectsProjectIdResponseProjectManager(String);
    impl ::std::ops::Deref for PutProjectsProjectIdResponseProjectManager {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PutProjectsProjectIdResponseProjectManager> for String {
        fn from(value: PutProjectsProjectIdResponseProjectManager) -> Self {
            value.0
        }
    }
    impl From<&PutProjectsProjectIdResponseProjectManager>
        for PutProjectsProjectIdResponseProjectManager
    {
        fn from(value: &PutProjectsProjectIdResponseProjectManager) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PutProjectsProjectIdResponseProjectManager {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^0x[a-fA-F0-9]{40}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^0x[a-fA-F0-9]{40}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PutProjectsProjectIdResponseProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PutProjectsProjectIdResponseProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PutProjectsProjectIdResponseProjectManager {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PutProjectsProjectIdResponseProjectManager {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "PutProjectsProjectIdResponseProjectName"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PutProjectsProjectIdResponseProjectName(String);
    impl ::std::ops::Deref for PutProjectsProjectIdResponseProjectName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }
    impl From<PutProjectsProjectIdResponseProjectName> for String {
        fn from(value: PutProjectsProjectIdResponseProjectName) -> Self {
            value.0
        }
    }
    impl From<&PutProjectsProjectIdResponseProjectName> for PutProjectsProjectIdResponseProjectName {
        fn from(value: &PutProjectsProjectIdResponseProjectName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PutProjectsProjectIdResponseProjectName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PutProjectsProjectIdResponseProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&String> for PutProjectsProjectIdResponseProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for PutProjectsProjectIdResponseProjectName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PutProjectsProjectIdResponseProjectName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
}
#[derive(Clone, Debug)]
#[doc = "Client for Phylax Credible Layer API\n\nAPI for managing projects, assertions, and smart contracts.\n\n## Authentication\n\nThis API supports dual authentication modes:\n\n### 1. Bearer Token Authentication (CLI)\nFor CLI clients, use JWT Bearer tokens in the Authorization header:\n```http\nAuthorization: Bearer <jwt_token>\n```\n\n### 2. Cookie Authentication (Web)\nFor web clients, authentication is handled via secure HTTP-only cookies (iron-session).\nNo Authorization header is needed when using cookie authentication.\n\n### Endpoint Authentication\n- Most endpoints accept both authentication methods\n- Optional Authorization headers in the API spec indicate dual authentication support\n- Required Authorization headers indicate CLI-only endpoints\n- The authentication middleware automatically detects and validates the appropriate method\n\nVersion: 0.1.0"]
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}
impl Client {
    #[doc = r" Create a new client."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }
    #[doc = r" Construct a new client with an existing `reqwest::Client`,"]
    #[doc = r" allowing more control over its configuration."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
    #[doc = r" Get the base URL to which requests are made."]
    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }
    #[doc = r" Get the internal `reqwest::Client` used to make requests."]
    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }
    #[doc = r" Get the version of this API."]
    #[doc = r""]
    #[doc = r" This string is pulled directly from the source OpenAPI"]
    #[doc = r" document and may be in any format the API selects."]
    pub fn api_version(&self) -> &'static str {
        "0.1.0"
    }
}
#[allow(clippy::all)]
impl Client {
    #[doc = "Get assertion adopters\n\nGet assertion adopters filtered by project or address\n\nSends a `GET` request to `/assertion_adopters`\n\n"]
    pub async fn get_assertion_adopters<'a>(
        &'a self,
        address: Option<&'a types::GetAssertionAdoptersAddress>,
        network: Option<&'a types::GetAssertionAdoptersNetwork>,
        project_id: Option<&'a uuid::Uuid>,
    ) -> Result<
        ResponseValue<Vec<types::GetAssertionAdoptersResponseItem>>,
        Error<types::GetAssertionAdoptersResponse>,
    > {
        let url = format!("{}/assertion_adopters", self.baseurl,);
        let mut query = Vec::with_capacity(3usize);
        if let Some(v) = &address {
            query.push(("address", v.to_string()));
        }
        if let Some(v) = &network {
            query.push(("network", v.to_string()));
        }
        if let Some(v) = &project_id {
            query.push(("project_id", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Assign adopters to project\n\nAssign one or more assertion adopters to a project\n\nSends a `POST` request to `/assertion_adopters/assign-project`\n\nArguments:\n- `authorization`\n- `body`: Body\n"]
    pub async fn post_assertion_adopters_assign_project<'a>(
        &'a self,
        authorization: Option<&'a str>,
        body: &'a types::PostAssertionAdoptersAssignProjectBody,
    ) -> Result<
        ResponseValue<types::PostAssertionAdoptersAssignProjectResponse>,
        Error<types::PostAssertionAdoptersAssignProjectResponse>,
    > {
        let url = format!("{}/assertion_adopters/assign-project", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            403u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get unassigned adopters\n\nGet assertion adopters not assigned to any project\n\nSends a `GET` request to `/assertion_adopters/no-project`\n\n"]
    pub async fn get_assertion_adopters_no_project<'a>(
        &'a self,
        manager: &'a types::GetAssertionAdoptersNoProjectManager,
    ) -> Result<
        ResponseValue<Vec<types::GetAssertionAdoptersNoProjectResponseItem>>,
        Error<types::GetAssertionAdoptersNoProjectResponse>,
    > {
        let url = format!("{}/assertion_adopters/no-project", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        query.push(("manager", manager.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Remove assertion from adopter\n\nRemove a specific assertion from an assertion adopter\n\nSends a `DELETE` request to `/assertion_adopters/{aa_address}/assertions/{assertion_id}`\n\n"]
    pub async fn delete_assertion_adopters_aa_address_assertions_assertion_id<'a>(
        &'a self,
        aa_address: &'a types::DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAaAddress,
        assertion_id: &'a types::DeleteAssertionAdoptersAaAddressAssertionsAssertionIdAssertionId,
        network: Option<&'a types::DeleteAssertionAdoptersAaAddressAssertionsAssertionIdNetwork>,
        authorization: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse>,
        Error<types::DeleteAssertionAdoptersAaAddressAssertionsAssertionIdResponse>,
    > {
        let url = format!(
            "{}/assertion_adopters/{}/assertions/{}",
            self.baseurl,
            encode_path(&aa_address.to_string()),
            encode_path(&assertion_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &network {
            query.push(("network", v.to_string()));
        }
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            403u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Generate remove assertions calldata\n\nGenerate calldata for removing all assertions from an adopter\n\nSends a `GET` request to `/assertion_adopters/{aa_address}/remove-assertions-calldata`\n\n"]
    pub async fn get_assertion_adopters_aa_address_remove_assertions_calldata<'a>(
        &'a self,
        aa_address: &'a types::GetAssertionAdoptersAaAddressRemoveAssertionsCalldataAaAddress,
        network: Option<&'a types::GetAssertionAdoptersAaAddressRemoveAssertionsCalldataNetwork>,
    ) -> Result<
        ResponseValue<types::GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse>,
        Error<types::GetAssertionAdoptersAaAddressRemoveAssertionsCalldataResponse>,
    > {
        let url = format!(
            "{}/assertion_adopters/{}/remove-assertions-calldata",
            self.baseurl,
            encode_path(&aa_address.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &network {
            query.push(("network", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get assertions by adopter\n\nGet all assertions for a specific assertion adopter\n\nSends a `GET` request to `/assertions`\n\n"]
    pub async fn get_assertions<'a>(
        &'a self,
        adopter_address: &'a types::GetAssertionsAdopterAddress,
        network: Option<&'a types::GetAssertionsNetwork>,
    ) -> Result<
        ResponseValue<Vec<types::GetAssertionsResponseItem>>,
        Error<types::GetAssertionsResponse>,
    > {
        let url = format!("{}/assertions", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        query.push(("adopter_address", adopter_address.to_string()));
        if let Some(v) = &network {
            query.push(("network", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Generate batch register calldata\n\nGenerate optimized calldata for registering assertions and assertion adopters\n\nSends a `POST` request to `/calldata/batch-register`\n\nArguments:\n- `body`: Body\n"]
    pub async fn post_calldata_batch_register<'a>(
        &'a self,
        body: &'a types::PostCalldataBatchRegisterBody,
    ) -> Result<
        ResponseValue<types::PostCalldataBatchRegisterResponse>,
        Error<types::PostCalldataBatchRegisterResponse>,
    > {
        let url = format!("{}/calldata/batch-register", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Request OTP code\n\nRequest a 6-digit OTP code for CLI authentication\n\nSends a `GET` request to `/cli/auth/code`\n\n"]
    pub async fn get_cli_auth_code<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::GetCliAuthCodeResponse>, Error<types::GetCliAuthCodeResponse>>
    {
        let url = format!("{}/cli/auth/code", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Refresh access token\n\nRefresh JWT access token using refresh token\n\nSends a `POST` request to `/cli/auth/refresh`\n\nArguments:\n- `body`: Body\n"]
    pub async fn post_cli_auth_refresh<'a>(
        &'a self,
        body: &'a types::PostCliAuthRefreshBody,
    ) -> Result<
        ResponseValue<types::PostCliAuthRefreshResponse>,
        Error<types::PostCliAuthRefreshResponse>,
    > {
        let url = format!("{}/cli/auth/refresh", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Check OTP status\n\nCheck the status of an OTP request and get tokens if verified\n\nSends a `GET` request to `/cli/auth/status`\n\n"]
    pub async fn get_cli_auth_status<'a>(
        &'a self,
        device_secret: &'a str,
        session_id: &'a uuid::Uuid,
    ) -> Result<
        ResponseValue<types::GetCliAuthStatusResponse>,
        Error<types::GetCliAuthStatusResponse>,
    > {
        let url = format!("{}/cli/auth/status", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        query.push(("device_secret", device_secret.to_string()));
        query.push(("session_id", session_id.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Verify OTP code\n\nVerify the 6-digit OTP code and get access tokens\n\nSends a `POST` request to `/cli/auth/verify`\n\nArguments:\n- `body`: Body\n"]
    pub async fn post_cli_auth_verify<'a>(
        &'a self,
        body: &'a types::PostCliAuthVerifyBody,
    ) -> Result<
        ResponseValue<types::PostCliAuthVerifyResponse>,
        Error<types::PostCliAuthVerifyResponse>,
    > {
        let url = format!("{}/cli/auth/verify", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Health check\n\nCheck API health status\n\nSends a `GET` request to `/health`\n\n"]
    pub async fn get_health<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::GetHealthResponse>, Error<()>> {
        let url = format!("{}/health", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "OpenAPI specification\n\nGet the OpenAPI specification for the API\n\nSends a `GET` request to `/openapi`\n\n"]
    pub async fn get_openapi<'a>(
        &'a self,
    ) -> Result<ResponseValue<::serde_json::Value>, Error<types::GetOpenapiResponse>> {
        let url = format!("{}/openapi", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get all projects\n\nGet all projects with optional filtering\n\nSends a `GET` request to `/projects`\n\n"]
    pub async fn get_projects<'a>(
        &'a self,
        network_id: Option<f64>,
        user: Option<&'a types::GetProjectsUser>,
    ) -> Result<ResponseValue<Vec<types::GetProjectsResponseItem>>, Error<types::GetProjectsResponse>>
    {
        let url = format!("{}/projects", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &network_id {
            query.push(("network_id", v.to_string()));
        }
        if let Some(v) = &user {
            query.push(("user", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Create a project\n\nCreate a new project with optional assertion adopters\n\nSends a `POST` request to `/projects`\n\nArguments:\n- `authorization`\n- `body`: Body\n"]
    pub async fn post_projects<'a>(
        &'a self,
        authorization: Option<&'a str>,
        body: &'a types::PostProjectsBody,
    ) -> Result<ResponseValue<types::PostProjectsResponse>, Error<types::PostProjectsResponse>>
    {
        let url = format!("{}/projects", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get saved projects\n\nGet all projects saved by a wallet address\n\nSends a `GET` request to `/projects/saved`\n\n"]
    pub async fn get_projects_saved<'a>(
        &'a self,
        wallet_address: &'a str,
    ) -> Result<
        ResponseValue<Vec<types::GetProjectsSavedResponseItem>>,
        Error<types::GetProjectsSavedResponse>,
    > {
        let url = format!("{}/projects/saved", self.baseurl,);
        let mut query = Vec::with_capacity(1usize);
        query.push(("wallet_address", wallet_address.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Save a project\n\nSave a project to the authenticated user's saved projects\n\nSends a `POST` request to `/projects/saved`\n\nArguments:\n- `authorization`\n- `body`: Body\n"]
    pub async fn post_projects_saved<'a>(
        &'a self,
        authorization: Option<&'a str>,
        body: &'a types::PostProjectsSavedBody,
    ) -> Result<
        ResponseValue<types::PostProjectsSavedResponse>,
        Error<types::PostProjectsSavedResponse>,
    > {
        let url = format!("{}/projects/saved", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            409u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Unsave a project\n\nRemove a project from the authenticated user's saved projects\n\nSends a `DELETE` request to `/projects/saved`\n\nArguments:\n- `authorization`\n- `body`: Body\n"]
    pub async fn delete_projects_saved<'a>(
        &'a self,
        authorization: Option<&'a str>,
        body: &'a types::DeleteProjectsSavedBody,
    ) -> Result<
        ResponseValue<types::DeleteProjectsSavedResponse>,
        Error<types::DeleteProjectsSavedResponse>,
    > {
        let url = format!("{}/projects/saved", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get project by ID\n\nGet detailed information about a specific project\n\nSends a `GET` request to `/projects/{project_id}`\n\n"]
    pub async fn get_projects_project_id<'a>(
        &'a self,
        project_id: &'a uuid::Uuid,
        include: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::GetProjectsProjectIdResponse>,
        Error<types::GetProjectsProjectIdResponse>,
    > {
        let url = format!(
            "{}/projects/{}",
            self.baseurl,
            encode_path(&project_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &include {
            query.push(("include", v.to_string()));
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Update project\n\nUpdate project details\n\nSends a `PUT` request to `/projects/{project_id}`\n\nArguments:\n- `project_id`\n- `authorization`\n- `body`: Body\n"]
    pub async fn put_projects_project_id<'a>(
        &'a self,
        project_id: &'a uuid::Uuid,
        authorization: Option<&'a str>,
        body: &'a types::PutProjectsProjectIdBody,
    ) -> Result<
        ResponseValue<types::PutProjectsProjectIdResponse>,
        Error<types::PutProjectsProjectIdResponse>,
    > {
        let url = format!(
            "{}/projects/{}",
            self.baseurl,
            encode_path(&project_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            403u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Delete project\n\nDelete a project and all associated data\n\nSends a `DELETE` request to `/projects/{project_id}`\n\n"]
    pub async fn delete_projects_project_id<'a>(
        &'a self,
        project_id: &'a uuid::Uuid,
        authorization: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::DeleteProjectsProjectIdResponse>,
        Error<types::DeleteProjectsProjectIdResponse>,
    > {
        let url = format!(
            "{}/projects/{}",
            self.baseurl,
            encode_path(&project_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            403u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get registered assertions for project\n\nGet all registered assertions associated with a project\n\nSends a `GET` request to `/projects/{project_id}/registered-assertions`\n\n"]
    pub async fn get_projects_project_id_registered_assertions<'a>(
        &'a self,
        project_id: &'a uuid::Uuid,
    ) -> Result<
        ResponseValue<types::GetProjectsProjectIdRegisteredAssertionsResponse>,
        Error<types::GetProjectsProjectIdRegisteredAssertionsResponse>,
    > {
        let url = format!(
            "{}/projects/{}/registered-assertions",
            self.baseurl,
            encode_path(&project_id.to_string()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Register assertions\n\nRegister assertions for a project\n\nSends a `POST` request to `/projects/{project_id}/registered-assertions`\n\nArguments:\n- `project_id`\n- `authorization`\n- `body`: Body\n"]
    pub async fn post_projects_project_id_registered_assertions<'a>(
        &'a self,
        project_id: &'a uuid::Uuid,
        authorization: Option<&'a str>,
        body: &'a types::PostProjectsProjectIdRegisteredAssertionsBody,
    ) -> Result<
        ResponseValue<types::PostProjectsProjectIdRegisteredAssertionsResponse>,
        Error<types::PostProjectsProjectIdRegisteredAssertionsResponse>,
    > {
        let url = format!(
            "{}/projects/{}/registered-assertions",
            self.baseurl,
            encode_path(&project_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Generate remove assertions calldata\n\nGenerate calldata for removing assertions from a project\n\nSends a `GET` request to `/projects/{project_id}/remove-assertions-calldata`\n\n"]
    pub async fn get_projects_project_id_remove_assertions_calldata<'a>(
        &'a self,
        project_id: &'a uuid::Uuid,
        authorization: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::GetProjectsProjectIdRemoveAssertionsCalldataResponse>,
        Error<types::GetProjectsProjectIdRemoveAssertionsCalldataResponse>,
    > {
        let url = format!(
            "{}/projects/{}/remove-assertions-calldata",
            self.baseurl,
            encode_path(&project_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get submitted assertions for a project\n\nGet all assertions that have been submitted for a specific project\n\nSends a `GET` request to `/projects/{project_id}/submitted-assertions`\n\n"]
    pub async fn get_projects_project_id_submitted_assertions<'a>(
        &'a self,
        project_id: &'a str,
        network: Option<&'a str>,
        authorization: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::GetProjectsProjectIdSubmittedAssertionsResponse>,
        Error<types::GetProjectsProjectIdSubmittedAssertionsResponse>,
    > {
        let url = format!(
            "{}/projects/{}/submitted-assertions",
            self.baseurl,
            encode_path(&project_id.to_string()),
        );
        let mut query = Vec::with_capacity(1usize);
        if let Some(v) = &network {
            query.push(("network", v.to_string()));
        }
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Submit assertions to a project\n\nSubmit one or more assertions to a specific project (CLI only)\n\nSends a `POST` request to `/projects/{project_id}/submitted-assertions`\n\nArguments:\n- `project_id`\n- `authorization`\n- `x_auth_scope`\n- `body`: Body\n"]
    pub async fn post_projects_project_id_submitted_assertions<'a>(
        &'a self,
        project_id: &'a str,
        authorization: Option<&'a str>,
        x_auth_scope: Option<&'a str>,
        body: &'a types::PostProjectsProjectIdSubmittedAssertionsBody,
    ) -> Result<
        ResponseValue<types::PostProjectsProjectIdSubmittedAssertionsResponse>,
        Error<types::PostProjectsProjectIdSubmittedAssertionsResponse>,
    > {
        let url = format!(
            "{}/projects/{}/submitted-assertions",
            self.baseurl,
            encode_path(&project_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(2usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        if let Some(v) = x_auth_scope {
            header_map.append("X-Auth-Scope", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Remove assertion adopter from project\n\nRemove an assertion adopter from a project\n\nSends a `DELETE` request to `/projects/{project_id}/{aa_contract}`\n\n"]
    pub async fn delete_projects_project_id_aa_contract<'a>(
        &'a self,
        project_id: &'a uuid::Uuid,
        aa_contract: &'a types::DeleteProjectsProjectIdAaContractAaContract,
        authorization: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::DeleteProjectsProjectIdAaContractResponse>,
        Error<types::DeleteProjectsProjectIdAaContractResponse>,
    > {
        let url = format!(
            "{}/projects/{}/{}",
            self.baseurl,
            encode_path(&project_id.to_string()),
            encode_path(&aa_contract.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            403u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Search\n\nSearch for projects and contracts\n\nSends a `GET` request to `/search`\n\n"]
    pub async fn get_search<'a>(
        &'a self,
        query: &'a types::GetSearchQuery,
    ) -> Result<ResponseValue<types::GetSearchResponse>, Error<types::GetSearchResponse>> {
        let url = format!("{}/search", self.baseurl,);
        let mut _query = Vec::with_capacity(1usize);
        _query.push(("query", query.to_string()));
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&_query)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "System status\n\nGet detailed system status information\n\nSends a `GET` request to `/system-status`\n\n"]
    pub async fn get_system_status<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::GetSystemStatusResponse>, Error<types::GetSystemStatusResponse>>
    {
        let url = format!("{}/system-status", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get all transfers\n\nGet all transfers for the authenticated user\n\nSends a `GET` request to `/transfers`\n\n"]
    pub async fn get_transfers<'a>(
        &'a self,
        role: Option<types::GetTransfersRole>,
        status: Option<&'a str>,
        authorization: Option<&'a str>,
    ) -> Result<ResponseValue<types::GetTransfersResponse>, Error<types::GetTransfersResponse>>
    {
        let url = format!("{}/transfers", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        if let Some(v) = &role {
            query.push(("role", v.to_string()));
        }
        if let Some(v) = &status {
            query.push(("status", v.to_string()));
        }
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Create transfer (generic)\n\nCreate a new transfer request for either project or assertion adopter\n\nSends a `POST` request to `/transfers`\n\nArguments:\n- `authorization`\n- `body`: Body\n"]
    pub async fn post_transfers<'a>(
        &'a self,
        authorization: Option<&'a str>,
        body: &'a types::PostTransfersBody,
    ) -> Result<ResponseValue<types::PostTransfersResponse>, Error<types::PostTransfersResponse>>
    {
        let url = format!("{}/transfers", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            409u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Create adopter transfer\n\nInitiate a transfer of assertion adopter ownership\n\nSends a `POST` request to `/transfers/assertion-adopters`\n\nArguments:\n- `authorization`\n- `body`: Body\n"]
    pub async fn post_transfers_assertion_adopters<'a>(
        &'a self,
        authorization: Option<&'a str>,
        body: &'a types::PostTransfersAssertionAdoptersBody,
    ) -> Result<
        ResponseValue<types::PostTransfersAssertionAdoptersResponse>,
        Error<types::PostTransfersAssertionAdoptersResponse>,
    > {
        let url = format!("{}/transfers/assertion-adopters", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            409u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get adopter transfer details\n\nGet details of a specific assertion adopter transfer\n\nSends a `GET` request to `/transfers/assertion-adopters/{transfer_id}`\n\n"]
    pub async fn get_transfers_assertion_adopters_transfer_id<'a>(
        &'a self,
        transfer_id: &'a uuid::Uuid,
        authorization: Option<&'a str>,
    ) -> Result<
        ResponseValue<::serde_json::Value>,
        Error<types::GetTransfersAssertionAdoptersTransferIdResponse>,
    > {
        let url = format!(
            "{}/transfers/assertion-adopters/{}",
            self.baseurl,
            encode_path(&transfer_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Cancel adopter transfer\n\nCancel a pending assertion adopter transfer\n\nSends a `DELETE` request to `/transfers/assertion-adopters/{transfer_id}`\n\n"]
    pub async fn delete_transfers_assertion_adopters_transfer_id<'a>(
        &'a self,
        transfer_id: &'a uuid::Uuid,
        authorization: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::DeleteTransfersAssertionAdoptersTransferIdResponse>,
        Error<types::DeleteTransfersAssertionAdoptersTransferIdResponse>,
    > {
        let url = format!(
            "{}/transfers/assertion-adopters/{}",
            self.baseurl,
            encode_path(&transfer_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            403u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Update adopter transfer\n\nAccept or reject an assertion adopter transfer\n\nSends a `PATCH` request to `/transfers/assertion-adopters/{transfer_id}`\n\nArguments:\n- `transfer_id`\n- `authorization`\n- `body`: Body\n"]
    pub async fn patch_transfers_assertion_adopters_transfer_id<'a>(
        &'a self,
        transfer_id: &'a uuid::Uuid,
        authorization: Option<&'a str>,
        body: &'a types::PatchTransfersAssertionAdoptersTransferIdBody,
    ) -> Result<
        ResponseValue<types::PatchTransfersAssertionAdoptersTransferIdResponse>,
        Error<types::PatchTransfersAssertionAdoptersTransferIdResponse>,
    > {
        let url = format!(
            "{}/transfers/assertion-adopters/{}",
            self.baseurl,
            encode_path(&transfer_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            403u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Create project transfer\n\nInitiate a transfer of project ownership\n\nSends a `POST` request to `/transfers/projects`\n\nArguments:\n- `authorization`\n- `body`: Body\n"]
    pub async fn post_transfers_projects<'a>(
        &'a self,
        authorization: Option<&'a str>,
        body: &'a types::PostTransfersProjectsBody,
    ) -> Result<
        ResponseValue<types::PostTransfersProjectsResponse>,
        Error<types::PostTransfersProjectsResponse>,
    > {
        let url = format!("{}/transfers/projects", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            409u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get project transfer details\n\nGet details of a specific project transfer\n\nSends a `GET` request to `/transfers/projects/{transfer_id}`\n\n"]
    pub async fn get_transfers_projects_transfer_id<'a>(
        &'a self,
        transfer_id: &'a uuid::Uuid,
        authorization: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::GetTransfersProjectsTransferIdResponse>,
        Error<types::GetTransfersProjectsTransferIdResponse>,
    > {
        let url = format!(
            "{}/transfers/projects/{}",
            self.baseurl,
            encode_path(&transfer_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Cancel project transfer\n\nCancel a pending project transfer\n\nSends a `DELETE` request to `/transfers/projects/{transfer_id}`\n\n"]
    pub async fn delete_transfers_projects_transfer_id<'a>(
        &'a self,
        transfer_id: &'a uuid::Uuid,
        authorization: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::DeleteTransfersProjectsTransferIdResponse>,
        Error<types::DeleteTransfersProjectsTransferIdResponse>,
    > {
        let url = format!(
            "{}/transfers/projects/{}",
            self.baseurl,
            encode_path(&transfer_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            403u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Update project transfer\n\nAccept or reject a project transfer\n\nSends a `PATCH` request to `/transfers/projects/{transfer_id}`\n\nArguments:\n- `transfer_id`\n- `authorization`\n- `body`: Body\n"]
    pub async fn patch_transfers_projects_transfer_id<'a>(
        &'a self,
        transfer_id: &'a uuid::Uuid,
        authorization: Option<&'a str>,
        body: &'a types::PatchTransfersProjectsTransferIdBody,
    ) -> Result<
        ResponseValue<types::PatchTransfersProjectsTransferIdResponse>,
        Error<types::PatchTransfersProjectsTransferIdResponse>,
    > {
        let url = format!(
            "{}/transfers/projects/{}",
            self.baseurl,
            encode_path(&transfer_id.to_string()),
        );
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            403u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Logout user\n\nClear user session and invalidate tokens\n\nSends a `POST` request to `/web/auth/logout`\n\nArguments:\n- `body`: Body\n"]
    pub async fn post_web_auth_logout<'a>(
        &'a self,
        body: &'a ::serde_json::Map<String, ::serde_json::Value>,
    ) -> Result<
        ResponseValue<types::PostWebAuthLogoutResponse>,
        Error<types::PostWebAuthLogoutResponse>,
    > {
        let url = format!("{}/web/auth/logout", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get current user info\n\nGet information about the currently authenticated user\n\nSends a `GET` request to `/web/auth/me`\n\n"]
    pub async fn get_web_auth_me<'a>(
        &'a self,
        authorization: Option<&'a str>,
    ) -> Result<ResponseValue<types::GetWebAuthMeResponse>, Error<types::GetWebAuthMeResponse>>
    {
        let url = format!("{}/web/auth/me", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get authentication nonce\n\nGet a nonce for SIWE authentication\n\nSends a `GET` request to `/web/auth/nonce`\n\n"]
    pub async fn get_web_auth_nonce<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::GetWebAuthNonceResponse>, Error<types::GetWebAuthNonceResponse>>
    {
        let url = format!("{}/web/auth/nonce", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Refresh access token\n\nRefresh JWT access token using refresh token\n\nSends a `POST` request to `/web/auth/refresh`\n\nArguments:\n- `body`: Body\n"]
    pub async fn post_web_auth_refresh<'a>(
        &'a self,
        body: &'a types::PostWebAuthRefreshBody,
    ) -> Result<
        ResponseValue<types::PostWebAuthRefreshResponse>,
        Error<types::PostWebAuthRefreshResponse>,
    > {
        let url = format!("{}/web/auth/refresh", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Verify SIWE signature\n\nVerify Sign-In with Ethereum message and signature\n\nSends a `POST` request to `/web/auth/verify`\n\nArguments:\n- `body`: Body\n"]
    pub async fn post_web_auth_verify<'a>(
        &'a self,
        body: &'a types::PostWebAuthVerifyBody,
    ) -> Result<
        ResponseValue<types::PostWebAuthVerifyResponse>,
        Error<types::PostWebAuthVerifyResponse>,
    > {
        let url = format!("{}/web/auth/verify", self.baseurl,);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            422u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Request testnet tokens\n\nRequest tokens from testnet faucet\n\nSends a `POST` request to `/web/faucet`\n\nArguments:\n- `authorization`\n- `body`: Body\n"]
    pub async fn post_web_faucet<'a>(
        &'a self,
        authorization: Option<&'a str>,
        body: &'a types::PostWebFaucetBody,
    ) -> Result<ResponseValue<types::PostWebFaucetResponse>, Error<types::PostWebFaucetResponse>>
    {
        let url = format!("{}/web/faucet", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            429u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Get verified contract info\n\nRetrieve verified contract information from block explorer\n\nSends a `GET` request to `/web/verified-contract`\n\n"]
    pub async fn get_web_verified_contract<'a>(
        &'a self,
        address: &'a types::GetWebVerifiedContractAddress,
        chain_id: &'a str,
        authorization: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::GetWebVerifiedContractResponse>,
        Error<types::GetWebVerifiedContractResponse>,
    > {
        let url = format!("{}/web/verified-contract", self.baseurl,);
        let mut query = Vec::with_capacity(2usize);
        query.push(("address", address.to_string()));
        query.push(("chainId", chain_id.to_string()));
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&query)
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            404u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Check whitelist status\n\nCheck whitelist status for the authenticated user\n\nSends a `GET` request to `/whitelist`\n\n"]
    pub async fn get_whitelist<'a>(
        &'a self,
        authorization: Option<&'a str>,
    ) -> Result<ResponseValue<types::GetWhitelistResponse>, Error<types::GetWhitelistResponse>>
    {
        let url = format!("{}/whitelist", self.baseurl,);
        let mut header_map = HeaderMap::with_capacity(1usize);
        if let Some(v) = authorization {
            header_map.append("Authorization", HeaderValue::try_from(v)?);
        }
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                reqwest::header::ACCEPT,
                reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            401u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
}
#[doc = r" Items consumers will typically use such as the Client."]
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
}
