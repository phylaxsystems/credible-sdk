//! Core orchestration loop that monitors the state of the engine and the
//! client.
//!
//! The orchestration loop is responsible for:
//!
//! - Tracing the state of the engine at each block
//! - Tracing the state of the client at each block
//! - Comparing the two traces
//! - Reporting any discrepancies

use crate::critical;
use alloy::{
    eips::BlockId,
    primitives::{
        TxHash,
        U64,
    },
    providers::WsConnect,
    rpc::types::Header,
};
use alloy_provider::{
    Provider,
    ProviderBuilder,
    RootProvider,
    ext::TraceApi,
};
use alloy_rpc_types_trace::parity::TraceType;
use anyhow::{
    Result,
    anyhow,
};
use assertion_executor::primitives::{
    Account,
    B256,
    Bytecode,
    EvmState,
    EvmStorage,
    U256,
};
use dashmap::DashMap;
use futures::StreamExt;
use std::{
    collections::BTreeMap,
    sync::Arc,
    time::Duration,
};
use tokio::time;
use tracing::{
    debug,
    error,
    info,
    warn,
};

const SUBSCRIPTION_RETRY_DELAY_SECS: u64 = 5;

/// Coordinates block ingestion, tracing, and state comparison between the engine and the client.
pub(in crate::engine) struct CacheChecker {
    provider: Arc<RootProvider>,
    processed_transactions: Arc<DashMap<TxHash, EvmState>>,
}

impl CacheChecker {
    /// Build a checker that listens for new heads and compares the transaction state diff with the
    /// ones generated by the engine
    pub async fn try_new(
        provider_ws_url: &str,
        processed_transactions: Arc<DashMap<TxHash, EvmState>>,
    ) -> Result<Arc<Self>> {
        let ws = WsConnect::new(provider_ws_url);
        let provider = Arc::new(ProviderBuilder::new().connect_ws(ws).await?.root().clone());
        Ok(Arc::new(Self {
            provider,
            processed_transactions,
        }))
    }

    /// We keep retrying the subscription because websocket connections can drop in practice.
    pub async fn run(self: Arc<Self>) -> Result<()> {
        let mut next_block = self.provider.get_block_number().await?;
        loop {
            if let Err(err) = self.clone().stream_blocks(&mut next_block).await {
                warn!(error = %err, "block subscription ended, retrying");
                time::sleep(Duration::from_secs(SUBSCRIPTION_RETRY_DELAY_SECS)).await;
            }
        }
    }

    /// Follow the `newHeads` stream and process new blocks in order, tolerating
    /// duplicate/stale headers after reconnects.
    async fn stream_blocks(self: Arc<Self>, next_block: &mut u64) -> Result<()> {
        let subscription = self.provider.subscribe_blocks().await?;
        let mut stream = subscription.into_stream();

        while let Some(header) = stream.next().await {
            let Header { hash: _, inner, .. } = header;
            let block_number = inner.number;

            info!(block_number = block_number, "new block header");

            // We may receive a header we already processed if the stream
            // briefly disconnects; skip without rewinding because we do not
            // currently handle reorgs.
            if block_number + 1 < *next_block {
                debug!(block_number, next_block, "skipping stale header");
                continue;
            }

            // If we are missing a block, trigger an error
            if block_number > *next_block {
                error!("Missing block {block_number} (next block: {next_block})");
                return Err(anyhow!(
                    "Missing block {block_number} (next block: {next_block})"
                ));
            }

            while *next_block <= block_number {
                self.clone().process_block(*next_block).await?;
                *next_block += 1;
            }
        }

        Err(anyhow!("block subscription completed"))
    }

    /// Get all the block transaction state diff and check if the state diff from the client matches
    /// the one generated by the engine
    async fn process_block(self: Arc<Self>, block_number: u64) -> Result<()> {
        info!(block_number, "processing block");

        let traces = match self
            .provider
            .trace_replay_block_transactions(BlockId::Number(block_number.into()))
            .trace_type(TraceType::StateDiff)
            .await
        {
            Ok(traces) => traces,
            Err(err) => {
                error!(error = ?err, block_number, "failed to trace block");
                return Err(anyhow!("failed to trace block {block_number}"));
            }
        };

        'main: for trace in traces {
            {
                // It can happen that there is a tx error and the tx is discarded by the engine.
                // Therefore, we need to add a timeout to skip a transaction check if we don't see it
                // in the results
                let mut counter = 3;
                while self
                    .processed_transactions
                    .get(&trace.transaction_hash)
                    .is_none()
                {
                    tokio::time::sleep(Duration::from_millis(5)).await;
                    counter -= 1;
                    if counter == 0 {
                        warn!(
                            "Transaction {} not found in processed transactions",
                            trace.transaction_hash
                        );
                        continue 'main;
                    }
                }
            }

            if let Some(engine_tx_state_diff) =
                self.processed_transactions.get(&trace.transaction_hash)
                && let Some(client_tx_state_diff) = trace.full_trace.state_diff
            {
                // Compare the two state representations
                if !Self::compare_state_changes(&engine_tx_state_diff, &client_tx_state_diff) {
                    critical!("State mismatch for transaction {}", trace.transaction_hash);
                    return Ok(());
                }
            }
        }

        Ok(())
    }

    /// Compare `EvmState` (Geth-style) with `StateDiff` (Parity-style)
    /// Returns true if they match, false otherwise
    pub fn compare_state_changes(
        engine_state: &EvmState,
        client_state_diff: &alloy_rpc_types_trace::parity::StateDiff,
    ) -> bool {
        // Get all unique addresses from both states
        let engine_addrs: std::collections::HashSet<_> = engine_state.keys().collect();
        let client_addrs: std::collections::HashSet<_> = client_state_diff.0.keys().collect();

        // Check if addresses match
        for addr in engine_addrs.union(&client_addrs) {
            let engine_account = engine_state.get(*addr);
            let client_account_diff = client_state_diff.0.get(*addr);

            match (engine_account, client_account_diff) {
                (Some(engine_acc), Some(client_diff)) => {
                    if !Self::account_matches(engine_acc, client_diff) {
                        return false;
                    }
                }
                (Some(engine_acc), None) => {
                    if !Self::is_account_empty(engine_acc) {
                        return false;
                    }
                }
                (None, Some(client_diff)) => {
                    if !Self::is_diff_empty(client_diff) {
                        return false;
                    }
                }
                (None, None) => unreachable!(),
            }
        }

        true
    }

    fn account_matches(
        engine_account: &Account,
        client_diff: &alloy_rpc_types_trace::parity::AccountDiff,
    ) -> bool {
        // Extract final values from deltas
        let client_balance = Self::extract_final_value(&client_diff.balance, U256::ZERO);
        let client_nonce = Self::extract_final_value(&client_diff.nonce, U64::ZERO).to::<u64>();
        let client_code =
            Self::extract_final_value_option(&client_diff.code).map(Bytecode::new_raw);

        // Compare balance, nonce, code
        if engine_account.info.balance != client_balance {
            return false;
        }
        if engine_account.info.nonce != client_nonce {
            return false;
        }
        if engine_account.info.code != client_code {
            return false;
        }

        // Compare storage
        Self::storage_matches(&engine_account.storage, &client_diff.storage)
    }

    fn storage_matches(
        engine_storage: &EvmStorage,
        client_storage_diff: &BTreeMap<B256, alloy_rpc_types_trace::parity::Delta<B256>>,
    ) -> bool {
        // Collect all unique keys as U256
        let mut all_keys = std::collections::HashSet::new();

        // Add engine keys
        for key in engine_storage.keys() {
            all_keys.insert(*key);
        }

        // Add client keys
        for key in client_storage_diff.keys() {
            all_keys.insert(U256::from_be_bytes(key.0));
        }

        for key in all_keys {
            let engine_value = engine_storage.get(&key).cloned().unwrap_or_default();

            let key_b256 = B256::from(key.to_be_bytes::<32>());
            let client_value = client_storage_diff
                .get(&key_b256)
                .map_or(U256::ZERO, |delta| {
                    let val_b256 = Self::extract_final_value(delta, B256::ZERO);
                    U256::from_be_bytes(val_b256.0)
                });

            if engine_value.present_value() != client_value {
                return false;
            }
        }

        true
    }

    fn is_account_empty(account: &Account) -> bool {
        account.info.balance == U256::ZERO
            && account.info.nonce == 0
            && account.info.code.is_none()
            && account.storage.is_empty()
    }

    fn is_diff_empty(diff: &alloy_rpc_types_trace::parity::AccountDiff) -> bool {
        matches!(
            diff.balance,
            alloy_rpc_types_trace::parity::Delta::Unchanged
        ) && matches!(diff.nonce, alloy_rpc_types_trace::parity::Delta::Unchanged)
            && matches!(diff.code, alloy_rpc_types_trace::parity::Delta::Unchanged)
            && diff.storage.is_empty()
    }

    fn extract_final_value<T: Clone + Default>(
        delta: &alloy_rpc_types_trace::parity::Delta<T>,
        default: T,
    ) -> T {
        match delta {
            alloy_rpc_types_trace::parity::Delta::Added(val) => val.clone(),
            alloy_rpc_types_trace::parity::Delta::Removed(_)
            | alloy_rpc_types_trace::parity::Delta::Unchanged => default,
            alloy_rpc_types_trace::parity::Delta::Changed(change) => change.to.clone(),
        }
    }

    fn extract_final_value_option<T: Clone>(
        delta: &alloy_rpc_types_trace::parity::Delta<T>,
    ) -> Option<T> {
        match delta {
            alloy_rpc_types_trace::parity::Delta::Unchanged
            | alloy_rpc_types_trace::parity::Delta::Removed(_) => None,
            alloy_rpc_types_trace::parity::Delta::Added(val) => Some(val.clone()),
            alloy_rpc_types_trace::parity::Delta::Changed(change) => Some(change.to.clone()),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use alloy_rpc_types_trace::parity::{
        AccountDiff,
        ChangedType,
        Delta,
        StateDiff,
    };
    use assertion_executor::primitives::{
        Account,
        AccountInfo,
        AccountStatus,
        EvmStorageSlot,
    };
    use std::{
        collections::BTreeMap,
        time::Duration,
    };
    use tracing_test::traced_test;

    fn create_test_account(balance: u64, nonce: u64, code: Option<Vec<u8>>) -> Account {
        Account {
            info: AccountInfo {
                balance: U256::from(balance),
                nonce,
                code_hash: B256::ZERO,
                code: code.map(|c| Bytecode::new_raw(c.into())),
            },
            storage: assertion_executor::primitives::EvmStorage::default(),
            status: AccountStatus::default(),
        }
    }

    fn create_storage_slot(value: u64) -> EvmStorageSlot {
        EvmStorageSlot::new(U256::from(value))
    }

    #[test]
    fn test_identical_states_match() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, None);
        engine_state.insert(addr, account);

        let mut client_diff = BTreeMap::new();
        let account_diff = AccountDiff {
            balance: Delta::Added(U256::from(1000)),
            nonce: Delta::Added(U64::from(5)),
            code: Delta::Unchanged,
            storage: BTreeMap::new(),
        };
        client_diff.insert(addr, account_diff);

        let client_state_diff = StateDiff(client_diff);

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_balance_mismatch() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, None);
        engine_state.insert(addr, account);

        let mut client_diff = BTreeMap::new();
        let account_diff = AccountDiff {
            balance: Delta::Added(U256::from(2000)), // Different!
            nonce: Delta::Added(U64::from(5)),
            code: Delta::Unchanged,
            storage: BTreeMap::new(),
        };
        client_diff.insert(addr, account_diff);

        let client_state_diff = StateDiff(client_diff);

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_nonce_mismatch() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, None);
        engine_state.insert(addr, account);

        let mut client_diff = BTreeMap::new();
        let account_diff = AccountDiff {
            balance: Delta::Added(U256::from(1000)),
            nonce: Delta::Added(U64::from(10)), // Different!
            code: Delta::Unchanged,
            storage: BTreeMap::new(),
        };
        client_diff.insert(addr, account_diff);

        let client_state_diff = StateDiff(client_diff);

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_code_mismatch() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, Some(vec![0x60, 0x80]));
        engine_state.insert(addr, account);

        let mut client_diff = BTreeMap::new();
        let account_diff = AccountDiff {
            balance: Delta::Added(U256::from(1000)),
            nonce: Delta::Added(U64::from(5)),
            code: Delta::Added(vec![0x60, 0x60].into()), // Different code!
            storage: BTreeMap::new(),
        };
        client_diff.insert(addr, account_diff);

        let client_state_diff = StateDiff(client_diff);

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_storage_match() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let mut account = create_test_account(1000, 5, None);
        let storage_key = U256::from(1);
        account
            .storage
            .insert(storage_key, create_storage_slot(100));
        engine_state.insert(addr, account);

        let mut client_diff = BTreeMap::new();
        let mut storage_diff = BTreeMap::new();
        let key_b256 = B256::from(storage_key.to_be_bytes::<32>());
        let value_b256 = B256::from(U256::from(100).to_be_bytes::<32>());
        storage_diff.insert(key_b256, Delta::Added(value_b256));

        let account_diff = AccountDiff {
            balance: Delta::Added(U256::from(1000)),
            nonce: Delta::Added(U64::from(5)),
            code: Delta::Unchanged,
            storage: storage_diff,
        };
        client_diff.insert(addr, account_diff);

        let client_state_diff = StateDiff(client_diff);

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_storage_mismatch() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let mut account = create_test_account(1000, 5, None);
        let storage_key = U256::from(1);
        account
            .storage
            .insert(storage_key, create_storage_slot(100));
        engine_state.insert(addr, account);

        let mut client_diff = BTreeMap::new();
        let mut storage_diff = BTreeMap::new();
        let key_b256 = B256::from(storage_key.to_be_bytes::<32>());
        let value_b256 = B256::from(U256::from(200).to_be_bytes::<32>()); // Different!
        storage_diff.insert(key_b256, Delta::Added(value_b256));

        let account_diff = AccountDiff {
            balance: Delta::Added(U256::from(1000)),
            nonce: Delta::Added(U64::from(5)),
            code: Delta::Unchanged,
            storage: storage_diff,
        };
        client_diff.insert(addr, account_diff);

        let client_state_diff = StateDiff(client_diff);

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_empty_account_is_ignored() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        // Empty account
        let account = create_test_account(0, 0, None);
        engine_state.insert(addr, account);

        // Client has no diff for this address
        let client_state_diff = StateDiff(BTreeMap::new());

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_account_only_in_engine() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, None);
        engine_state.insert(addr, account);

        // Client has no diff
        let client_state_diff = StateDiff(BTreeMap::new());

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_account_only_in_client() {
        let engine_state = assertion_executor::primitives::EvmState::default();

        let mut client_diff = BTreeMap::new();
        let addr = assertion_executor::primitives::Address::ZERO;
        let account_diff = AccountDiff {
            balance: Delta::Added(U256::from(1000)),
            nonce: Delta::Added(U64::from(5)),
            code: Delta::Unchanged,
            storage: BTreeMap::new(),
        };
        client_diff.insert(addr, account_diff);

        let client_state_diff = StateDiff(client_diff);

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_delta_changed_type() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(2000, 5, None);
        engine_state.insert(addr, account);

        let mut client_diff = BTreeMap::new();
        let account_diff = AccountDiff {
            balance: Delta::Changed(ChangedType {
                from: U256::from(1000),
                to: U256::from(2000), // Final value matches
            }),
            nonce: Delta::Added(U64::from(5)),
            code: Delta::Unchanged,
            storage: BTreeMap::new(),
        };
        client_diff.insert(addr, account_diff);

        let client_state_diff = StateDiff(client_diff);

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_multiple_accounts() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr1 = assertion_executor::primitives::Address::from([1u8; 20]);
        let addr2 = assertion_executor::primitives::Address::from([2u8; 20]);

        engine_state.insert(addr1, create_test_account(1000, 1, None));
        engine_state.insert(addr2, create_test_account(2000, 2, None));

        let mut client_diff = BTreeMap::new();
        client_diff.insert(
            addr1,
            AccountDiff {
                balance: Delta::Added(U256::from(1000)),
                nonce: Delta::Added(U64::from(1)),
                code: Delta::Unchanged,
                storage: BTreeMap::new(),
            },
        );
        client_diff.insert(
            addr2,
            AccountDiff {
                balance: Delta::Added(U256::from(2000)),
                nonce: Delta::Added(U64::from(2)),
                code: Delta::Unchanged,
                storage: BTreeMap::new(),
            },
        );

        let client_state_diff = StateDiff(client_diff);

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[test]
    fn test_zero_storage_values_treated_as_empty() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, None);
        // Don't insert any storage (implicitly zero)
        engine_state.insert(addr, account);

        let mut client_diff = BTreeMap::new();
        let mut storage_diff = BTreeMap::new();
        let key_b256 = B256::from(U256::from(1).to_be_bytes::<32>());
        storage_diff.insert(key_b256, Delta::Added(B256::ZERO)); // Zero value

        let account_diff = AccountDiff {
            balance: Delta::Added(U256::from(1000)),
            nonce: Delta::Added(U64::from(5)),
            code: Delta::Unchanged,
            storage: storage_diff,
        };
        client_diff.insert(addr, account_diff);

        let client_state_diff = StateDiff(client_diff);

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_state_diff
        ));
    }

    #[traced_test]
    #[crate::utils::engine_test(all)]
    async fn test_cache_checker_state_diff_mismatch(mut instance: crate::utils::LocalInstance) {
        use serde_json::json;

        // Step 1: Send a real transaction and wait for it to be processed by the engine
        let (tx_address, tx_hash) = instance.send_create_tx_with_cache_miss().await.unwrap();

        // Wait for the engine to process it
        let _ = instance.is_transaction_successful(&tx_hash).await;

        // Step 2: Mock the trace_replayBlockTransactions RPC response with MISMATCHED state
        let mock_trace_response = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "result": [{
                "transactionHash": format!("{:#x}", tx_hash),
                "output": "0x",
                "trace": [],
                "vmTrace": null,
                "stateDiff": {
                    format!("{:#x}", tx_address): {
                        "balance": {
                            "*": {
                                "from": "0x0",
                                "to": "0x989680"  // 10000000 in hex - WRONG VALUE
                            }
                        },
                        "nonce": {
                            "*": {
                                "from": "0x0",
                                "to": "0x2a"  // 42 - WRONG NONCE
                            }
                        },
                        "code": {
                            "+": "0x6060604052"  // WRONG BYTECODE
                        },
                        "storage": {}
                    }
                }
            }]
        });

        instance
            .besu_client_http_mock
            .add_response("trace_replayBlockTransactions", mock_trace_response);

        // Step 3: Send a newHeads notification for BLOCK 0 (not block 1!)
        // The transaction was processed in block 0, so we need to trigger block 0
        instance
            .besu_client_http_mock
            .send_new_head_with_block_number(0);

        // Step 4: Wait for the CacheChecker to detect the mismatch
        let mut attempts = 0;
        let max_attempts = 50;

        while !logs_contain("critical") && attempts < max_attempts {
            tokio::time::sleep(Duration::from_millis(100)).await;
            attempts += 1;
        }
    }
}
