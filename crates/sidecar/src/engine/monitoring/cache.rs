//! Core orchestration loop that monitors the state of the engine and the
//! client.
//!
//! The orchestration loop is responsible for:
//!
//! - Tracing the state of the engine at each block
//! - Tracing the state of the client at each block
//! - Comparing the two traces
//! - Reporting any discrepancies

use crate::critical;
use alloy::{
    eips::BlockNumberOrTag,
    primitives::TxHash,
    providers::WsConnect,
    rpc::types::Header,
};
use alloy_provider::{
    Provider,
    ProviderBuilder,
    RootProvider,
    ext::DebugApi,
};
use alloy_rpc_types_trace::geth::{
    GethDebugBuiltInTracerType,
    GethDebugTracerConfig,
    GethDebugTracerType,
    GethDebugTracingOptions,
    GethTrace,
    PreStateConfig,
    PreStateFrame,
    TraceResult,
};
use anyhow::{
    Result,
    anyhow,
};
use assertion_executor::primitives::{
    Account,
    Address,
    B256,
    Bytecode,
    EvmState,
    EvmStorage,
    U256,
};
use futures::StreamExt;
use moka::sync::Cache;
use std::{
    collections::BTreeMap,
    sync::Arc,
    time::Duration,
};
use tokio::time;
use tracing::{
    debug,
    error,
    info,
    warn,
};

use crate::engine::ProcessedBlocksCache;

const SUBSCRIPTION_RETRY_DELAY_SECS: u64 = 5;

/// Coordinates block ingestion, tracing, and state comparison between the engine and the client.
pub(in crate::engine) struct CacheChecker {
    provider: Arc<RootProvider>,
    processed_transactions: ProcessedBlocksCache,
}

impl CacheChecker {
    /// Build a checker that listens for new heads and compares the transaction state diff with the
    /// ones generated by the engine
    pub async fn try_new(
        provider_ws_url: &str,
        processed_transactions: ProcessedBlocksCache,
    ) -> Result<Arc<Self>> {
        let ws = WsConnect::new(provider_ws_url);
        let provider = Arc::new(ProviderBuilder::new().connect_ws(ws).await?.root().clone());
        Ok(Arc::new(Self {
            provider,
            processed_transactions,
        }))
    }

    /// We keep retrying the subscription because websocket connections can drop in practice.
    pub async fn run(self: Arc<Self>) -> Result<()> {
        let mut next_block = self.provider.get_block_number().await?;
        loop {
            if let Err(err) = self.clone().stream_blocks(&mut next_block).await {
                warn!(error = %err, "block subscription ended, retrying");
                time::sleep(Duration::from_secs(SUBSCRIPTION_RETRY_DELAY_SECS)).await;
            }
        }
    }

    /// Follow the `newHeads` stream and process new blocks in order, tolerating
    /// duplicate/stale headers after reconnects.
    async fn stream_blocks(self: Arc<Self>, next_block: &mut u64) -> Result<()> {
        let subscription = self.provider.subscribe_blocks().await?;
        let mut stream = subscription.into_stream();

        while let Some(header) = stream.next().await {
            let Header { hash: _, inner, .. } = header;
            let block_number = inner.number;

            info!(block_number = block_number, "new block header");

            // We may receive a header we already processed if the stream
            // briefly disconnects; skip without rewinding because we do not
            // currently handle reorgs.
            if block_number + 1 < *next_block {
                debug!(block_number, next_block, "skipping stale header");
                continue;
            }

            // If we are missing a block, trigger an error
            if block_number > *next_block {
                error!("Missing block {block_number} (next block: {next_block})");
                return Err(anyhow!(
                    "Missing block {block_number} (next block: {next_block})"
                ));
            }

            while *next_block <= block_number {
                self.clone().process_block(*next_block).await?;
                *next_block += 1;
            }
        }

        Err(anyhow!("block subscription completed"))
    }

    /// Get all the block transaction state diff and check if the state diff from the client matches
    /// the one generated by the engine
    async fn process_block(self: Arc<Self>, block_number: u64) -> Result<()> {
        info!(block_number, "processing block");

        let tracer_config = GethDebugTracerConfig::from(
            serde_json::to_value(PreStateConfig {
                diff_mode: Some(true),
                disable_code: None,
                disable_storage: None,
            })
            .map_err(|e| anyhow!("failed to serialize tracer config: {e}"))?,
        );

        let tracer_opts = GethDebugTracingOptions {
            tracer: Some(GethDebugTracerType::BuiltInTracer(
                GethDebugBuiltInTracerType::PreStateTracer,
            )),
            tracer_config,
            ..Default::default()
        };

        let traces = match self
            .provider
            .debug_trace_block_by_number(BlockNumberOrTag::Number(block_number), tracer_opts)
            .await
        {
            Ok(traces) => traces,
            Err(err) => {
                error!(error = ?err, block_number, "failed to trace block");
                return Err(anyhow!("failed to trace block {block_number}"));
            }
        };

        // Get block to retrieve transaction hashes
        let block = self
            .provider
            .get_block_by_number(BlockNumberOrTag::Number(block_number))
            .await?
            .ok_or_else(|| anyhow!("block {block_number} not found"))?;

        let tx_hashes: Vec<TxHash> = block.transactions.hashes().collect();

        if traces.len() != tx_hashes.len() {
            warn!(
                block_number,
                traces_len = traces.len(),
                txs_len = tx_hashes.len(),
                "trace count mismatch with transaction count"
            );
        }

        let processed_block = {
            // We need to add a timeout to skip a block check if we don't see it
            // in the results. It could happen that the engine didn't receive a TX (transport error)
            let mut counter = 100;
            let mut processed_block = None;
            while processed_block.is_none() {
                processed_block = self.processed_transactions.get(&block_number);
                if processed_block.is_some() {
                    break;
                }
                tokio::time::sleep(Duration::from_millis(5)).await;
                counter -= 1;
                if counter == 0 {
                    warn!("Block {} not found in processed transactions", block_number);
                    return Ok(());
                }
            }
            processed_block
        };

        let Some(processed_block) = processed_block else {
            warn!("Block {} not found in processed transactions", block_number);
            return Ok(());
        };

        'main: for (trace_result, tx_hash) in traces.into_iter().zip(tx_hashes.iter()) {
            // Extract the trace from TraceResult, skipping failed traces
            let geth_trace = match trace_result {
                TraceResult::Success { result, .. } => result,
                TraceResult::Error { error, tx_hash } => {
                    warn!(tx_hash = ?tx_hash, error = %error, "trace failed for transaction");
                    continue 'main;
                }
            };

            let GethTrace::PreStateTracer(trace) = geth_trace else {
                warn!(tx_hash = %tx_hash, "unexpected trace type, skipping");
                continue 'main;
            };

            let Some(engine_tx_state_diff) = processed_block.get(tx_hash) else {
                warn!(
                    "Transaction {} not found in processed block {}",
                    tx_hash, block_number
                );
                continue 'main;
            };

            let Some(engine_tx_state_diff) = engine_tx_state_diff else {
                critical!("Transaction failed to execute in the engine: {}", tx_hash);
                continue 'main;
            };

            // Compare the two state representations
            if !Self::compare_state_changes(engine_tx_state_diff, &trace) {
                critical!("State mismatch for transaction {}", tx_hash);
                return Ok(());
            }
        }

        Ok(())
    }

    /// Compare `EvmState` (engine) with `PreStateFrame` (Geth debug trace)
    /// Returns true if they match, false otherwise
    pub fn compare_state_changes(engine_state: &EvmState, client_trace: &PreStateFrame) -> bool {
        let post_state = match client_trace {
            PreStateFrame::Diff(diff) => &diff.post,
            PreStateFrame::Default(_) => {
                warn!("received default prestate frame instead of diff mode");
                return false;
            }
        };

        // Get all unique addresses from both states
        let engine_addrs: std::collections::HashSet<_> = engine_state.keys().collect();
        let client_addrs: std::collections::HashSet<_> = post_state.keys().collect();

        // Check if addresses match
        for addr in engine_addrs.union(&client_addrs) {
            let engine_account = engine_state.get(*addr);
            let client_account = post_state.get(*addr);

            match (engine_account, client_account) {
                (Some(engine_acc), Some(client_acc)) => {
                    if !Self::account_matches(engine_acc, client_acc) {
                        return false;
                    }
                }
                (Some(engine_acc), None) => {
                    if !Self::is_account_empty(engine_acc) {
                        return false;
                    }
                }
                (None, Some(client_acc)) => {
                    if !Self::is_client_account_empty(client_acc) {
                        return false;
                    }
                }
                (None, None) => unreachable!(),
            }
        }

        true
    }

    fn account_matches(
        engine_account: &Account,
        client_account: &alloy_rpc_types_trace::geth::AccountState,
    ) -> bool {
        // Compare balance
        if let Some(client_balance) = client_account.balance {
            if engine_account.info.balance != client_balance {
                return false;
            }
        } else if engine_account.info.balance != U256::ZERO {
            return false;
        }

        // Compare nonce
        if let Some(client_nonce) = client_account.nonce {
            if engine_account.info.nonce != client_nonce {
                return false;
            }
        } else if engine_account.info.nonce != 0 {
            return false;
        }

        // Compare code
        match (&engine_account.info.code, &client_account.code) {
            (Some(engine_code), Some(client_code)) => {
                if engine_code.bytes().as_ref() != client_code.as_ref() {
                    return false;
                }
            }
            (None, Some(client_code)) => {
                if !client_code.is_empty() {
                    return false;
                }
            }
            (Some(engine_code), None) => {
                if !engine_code.is_empty() {
                    return false;
                }
            }
            (None, None) => {}
        }

        // Compare storage
        Self::storage_matches(&engine_account.storage, &client_account.storage)
    }

    fn storage_matches(engine_storage: &EvmStorage, client_storage: &BTreeMap<B256, B256>) -> bool {
        if client_storage.is_empty() {
            // Client has no storage, engine should be empty too
            return engine_storage.is_empty()
                || engine_storage
                    .values()
                    .all(|v| v.present_value() == U256::ZERO);
        }

        // Collect all unique keys as U256
        let mut all_keys = std::collections::HashSet::new();

        // Add engine keys
        for key in engine_storage.keys() {
            all_keys.insert(*key);
        }

        // Add client keys
        for key in client_storage.keys() {
            all_keys.insert(U256::from_be_bytes(key.0));
        }

        for key in all_keys {
            let engine_value = engine_storage.get(&key).cloned().unwrap_or_default();

            let key_b256 = B256::from(key.to_be_bytes::<32>());
            let client_value = client_storage
                .get(&key_b256)
                .map_or(U256::ZERO, |val| U256::from_be_bytes(val.0));

            if engine_value.present_value() != client_value {
                return false;
            }
        }

        true
    }

    fn is_account_empty(account: &Account) -> bool {
        account.info.balance == U256::ZERO
            && account.info.nonce == 0
            && account.info.code.is_none()
            && account.storage.is_empty()
    }

    fn is_client_account_empty(account: &alloy_rpc_types_trace::geth::AccountState) -> bool {
        account.balance.unwrap_or(U256::ZERO) == U256::ZERO
            && account.nonce.unwrap_or(0) == 0
            && account.code.as_ref().is_none_or(|c| c.is_empty())
            && account.storage.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use alloy_rpc_types_trace::geth::{
        AccountState,
        DiffMode,
    };
    use assertion_executor::primitives::{
        Account,
        AccountInfo,
        AccountStatus,
        EvmStorageSlot,
    };
    use std::{
        collections::BTreeMap,
        time::Duration,
    };
    use tracing_test::traced_test;

    fn create_test_account(balance: u64, nonce: u64, code: Option<Vec<u8>>) -> Account {
        Account {
            info: AccountInfo {
                balance: U256::from(balance),
                nonce,
                code_hash: B256::ZERO,
                code: code.map(|c| Bytecode::new_raw(c.into())),
            },
            transaction_id: 0,
            storage: assertion_executor::primitives::EvmStorage::default(),
            status: AccountStatus::default(),
        }
    }

    fn create_client_account(balance: u64, nonce: u64, code: Option<Vec<u8>>) -> AccountState {
        AccountState {
            balance: Some(U256::from(balance)),
            nonce: Some(nonce),
            code: code.map(Into::into),
            storage: BTreeMap::new(),
        }
    }

    fn create_storage_slot(value: u64) -> EvmStorageSlot {
        EvmStorageSlot::new(U256::from(value), 0)
    }

    fn wrap_in_diff_frame(post: BTreeMap<Address, AccountState>) -> PreStateFrame {
        PreStateFrame::Diff(DiffMode {
            pre: BTreeMap::new(),
            post,
        })
    }

    #[test]
    fn test_identical_states_match() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, None);
        engine_state.insert(addr, account);

        let mut post_state = BTreeMap::new();
        post_state.insert(addr, create_client_account(1000, 5, None));

        let client_trace = wrap_in_diff_frame(post_state);

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[test]
    fn test_balance_mismatch() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, None);
        engine_state.insert(addr, account);

        let mut post_state = BTreeMap::new();
        post_state.insert(addr, create_client_account(2000, 5, None)); // Different!

        let client_trace = wrap_in_diff_frame(post_state);

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[test]
    fn test_nonce_mismatch() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, None);
        engine_state.insert(addr, account);

        let mut post_state = BTreeMap::new();
        post_state.insert(addr, create_client_account(1000, 10, None)); // Different!

        let client_trace = wrap_in_diff_frame(post_state);

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[test]
    fn test_code_mismatch() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, Some(vec![0x60, 0x80]));
        engine_state.insert(addr, account);

        let mut post_state = BTreeMap::new();
        post_state.insert(addr, create_client_account(1000, 5, Some(vec![0x60, 0x60]))); // Different!

        let client_trace = wrap_in_diff_frame(post_state);

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[test]
    fn test_storage_match() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let mut account = create_test_account(1000, 5, None);
        let storage_key = U256::from(1);
        account
            .storage
            .insert(storage_key, create_storage_slot(100));
        engine_state.insert(addr, account);

        let mut post_state = BTreeMap::new();
        let mut client_storage = BTreeMap::new();
        let key_b256 = B256::from(storage_key.to_be_bytes::<32>());
        let value_b256 = B256::from(U256::from(100).to_be_bytes::<32>());
        client_storage.insert(key_b256, value_b256);

        post_state.insert(
            addr,
            AccountState {
                balance: Some(U256::from(1000)),
                nonce: Some(5),
                code: None,
                storage: client_storage,
            },
        );

        let client_trace = wrap_in_diff_frame(post_state);

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[test]
    fn test_storage_mismatch() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let mut account = create_test_account(1000, 5, None);
        let storage_key = U256::from(1);
        account
            .storage
            .insert(storage_key, create_storage_slot(100));
        engine_state.insert(addr, account);

        let mut post_state = BTreeMap::new();
        let mut client_storage = BTreeMap::new();
        let key_b256 = B256::from(storage_key.to_be_bytes::<32>());
        let value_b256 = B256::from(U256::from(200).to_be_bytes::<32>()); // Different!
        client_storage.insert(key_b256, value_b256);

        post_state.insert(
            addr,
            AccountState {
                balance: Some(U256::from(1000)),
                nonce: Some(5),
                code: None,
                storage: client_storage,
            },
        );

        let client_trace = wrap_in_diff_frame(post_state);

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[test]
    fn test_empty_account_is_ignored() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        // Empty account
        let account = create_test_account(0, 0, None);
        engine_state.insert(addr, account);

        // Client has no entry for this address
        let client_trace = wrap_in_diff_frame(BTreeMap::new());

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[test]
    fn test_account_only_in_engine() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, None);
        engine_state.insert(addr, account);

        // Client has no entry
        let client_trace = wrap_in_diff_frame(BTreeMap::new());

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[test]
    fn test_account_only_in_client() {
        let engine_state = assertion_executor::primitives::EvmState::default();

        let mut post_state = BTreeMap::new();
        let addr = assertion_executor::primitives::Address::ZERO;
        post_state.insert(addr, create_client_account(1000, 5, None));

        let client_trace = wrap_in_diff_frame(post_state);

        assert!(!CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[test]
    fn test_multiple_accounts() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr1 = assertion_executor::primitives::Address::from([1u8; 20]);
        let addr2 = assertion_executor::primitives::Address::from([2u8; 20]);

        engine_state.insert(addr1, create_test_account(1000, 1, None));
        engine_state.insert(addr2, create_test_account(2000, 2, None));

        let mut post_state = BTreeMap::new();
        post_state.insert(addr1, create_client_account(1000, 1, None));
        post_state.insert(addr2, create_client_account(2000, 2, None));

        let client_trace = wrap_in_diff_frame(post_state);

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[test]
    fn test_zero_storage_values_treated_as_empty() {
        let mut engine_state = assertion_executor::primitives::EvmState::default();
        let addr = assertion_executor::primitives::Address::ZERO;

        let account = create_test_account(1000, 5, None);
        // Don't insert any storage (implicitly zero)
        engine_state.insert(addr, account);

        let mut post_state = BTreeMap::new();
        let mut client_storage = BTreeMap::new();
        let key_b256 = B256::from(U256::from(1).to_be_bytes::<32>());
        client_storage.insert(key_b256, B256::ZERO); // Zero value

        post_state.insert(
            addr,
            AccountState {
                balance: Some(U256::from(1000)),
                nonce: Some(5),
                code: None,
                storage: client_storage,
            },
        );

        let client_trace = wrap_in_diff_frame(post_state);

        assert!(CacheChecker::compare_state_changes(
            &engine_state,
            &client_trace
        ));
    }

    #[traced_test]
    #[crate::utils::engine_test(all)]
    async fn test_cache_checker_state_diff_mismatch(mut instance: crate::utils::LocalInstance) {
        use serde_json::json;

        // Step 1: Send a real transaction and wait for it to be processed by the engine
        let (tx_address, tx_iteration_id) =
            instance.send_create_tx_with_cache_miss().await.unwrap();

        // Wait for the engine to process it
        let _ = instance.is_transaction_successful(&tx_iteration_id).await;

        // Step 2: Mock the debug_traceBlockByNumber RPC response with MISMATCHED state
        let mock_trace_response = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "result": [{
                "result": {
                    "pre": {},
                    "post": {
                        format!("{:#x}", tx_address): {
                            "balance": "0x989680",  // 10000000 in hex - WRONG VALUE
                            "nonce": 42,  // WRONG NONCE
                            "code": "0x6060604052",  // WRONG BYTECODE
                            "storage": {}
                        }
                    }
                }
            }]
        });

        instance
            .eth_rpc_source_http_mock
            .add_response("debug_traceBlockByNumber", mock_trace_response);

        // Step 3: Send a newHeads notification for BLOCK 0 (not block 1!)
        // The transaction was processed in block 0, so we need to trigger block 0
        instance
            .eth_rpc_source_http_mock
            .send_new_head_with_block_number(0);

        // Step 4: Wait for the CacheChecker to detect the mismatch
        let mut attempts = 0;
        let max_attempts = 50;

        while !logs_contain("critical") && attempts < max_attempts {
            tokio::time::sleep(Duration::from_millis(100)).await;
            attempts += 1;
        }
    }
}
