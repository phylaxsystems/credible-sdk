use crate::{
    engine::TransactionResult,
    transactions_state::TransactionsState,
    tx_execution_id::TxExecutionId,
};
use std::{
    collections::VecDeque,
    sync::Arc,
};

/// Wrapper for `TransactionsState` for write-only operations.
/// `TransactionsResults` is a wrapper on top of `TransactionState` exposing only methods to insert
/// a new result generated by the engine.
/// `TransactionsResults` also handles the pruning of the `TransactionsResults`. The pruning follows
/// a FIFO model. The maximum capacity can be configurable.
#[derive(Debug)]
pub struct TransactionsResults {
    transactions_state: Arc<TransactionsState>,
    transactions: VecDeque<TxExecutionId>,
    max_capacity: usize,
}

impl TransactionsResults {
    pub fn new(transactions_state: Arc<TransactionsState>, max_capacity: usize) -> Self {
        assert!(
            max_capacity > 0,
            "The maximum capacity must be greater than 0"
        );
        Self {
            transactions: VecDeque::with_capacity(max_capacity),
            max_capacity,
            transactions_state,
        }
    }

    pub fn add_transaction_result(
        &mut self,
        tx_execution_id: TxExecutionId,
        result: &TransactionResult,
    ) {
        self.transactions_state
            .add_transaction_result(tx_execution_id, result);

        // If at capacity, remove the oldest before adding the new one
        if self.transactions.len() == self.max_capacity
            && let Some(old_tx_execution_id) = self.transactions.pop_front()
        {
            self.transactions_state
                .remove_transaction_result(&old_tx_execution_id);
        }

        self.transactions.push_back(tx_execution_id);
    }

    pub fn remove_transaction_result(&mut self, tx_execution_id: TxExecutionId) {
        self.transactions_state
            .remove_transaction_result(&tx_execution_id);
    }

    #[cfg(test)]
    pub fn get_transaction_result(
        &self,
        tx_execution_id: &TxExecutionId,
    ) -> Option<dashmap::mapref::one::Ref<'_, TxExecutionId, TransactionResult>> {
        self.transactions_state
            .get_transaction_result(tx_execution_id)
    }

    #[cfg(test)]
    pub fn get_all_transaction_result(
        &self,
    ) -> &dashmap::DashMap<TxExecutionId, TransactionResult> {
        self.transactions_state.get_all_transaction_result()
    }
}

#[cfg(test)]
mod tests {
    #![allow(clippy::cast_possible_truncation)]
    use super::*;
    use crate::{
        engine::TransactionResult,
        transactions_state::TransactionsState,
    };
    use assertion_executor::primitives::ExecutionResult;
    use revm::{
        context::result::{
            Output,
            SuccessReason,
        },
        primitives::Bytes,
    };

    // Helper function to create a test TransactionResult
    fn create_test_result_success() -> TransactionResult {
        TransactionResult::ValidationCompleted {
            execution_result: ExecutionResult::Success {
                reason: SuccessReason::Stop,
                gas_used: 21000,
                gas_refunded: 0,
                logs: Vec::new(),
                output: Output::Call(Bytes::new()),
            },
            is_valid: true,
        }
    }

    fn create_test_result_error(msg: &str) -> TransactionResult {
        TransactionResult::ValidationError(msg.to_string())
    }

    fn create_test_result_revert() -> TransactionResult {
        TransactionResult::ValidationCompleted {
            execution_result: ExecutionResult::Revert {
                gas_used: 15000,
                output: Bytes::from("revert reason"),
            },
            is_valid: false,
        }
    }

    // Helper to create a test TxExecutionId
    fn create_test_tx_execution_id(byte: u8) -> TxExecutionId {
        let tx_hash = revm::primitives::alloy_primitives::TxHash::from([byte; 32]);
        TxExecutionId::new(u64::from(byte), 0, tx_hash)
    }

    #[test]
    fn test_new_creates_empty_transactions_results() {
        let transactions_state = TransactionsState::new();
        let max_capacity = 10;

        let results = TransactionsResults::new(transactions_state, max_capacity);

        assert_eq!(results.max_capacity, max_capacity);
        assert_eq!(results.transactions.len(), 0);
        assert_eq!(results.transactions.capacity(), max_capacity);
    }

    #[test]
    fn test_add_transaction_result_stores_in_state_and_queue() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 5);

        let tx_execution_id = create_test_tx_execution_id(1);
        let result = create_test_result_success();

        results.add_transaction_result(tx_execution_id, &result.clone());

        // Check that transaction is in queue
        assert_eq!(results.transactions.len(), 1);
        assert_eq!(results.transactions[0], tx_execution_id);

        // Check that transaction result is stored in state
        let stored_result = results.get_transaction_result(&tx_execution_id);
        assert!(stored_result.is_some());
        assert_eq!(*stored_result.unwrap(), result);
    }

    #[test]
    fn test_add_multiple_transaction_results_within_capacity() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 5);

        let tx_execution_ids = vec![
            create_test_tx_execution_id(1),
            create_test_tx_execution_id(2),
            create_test_tx_execution_id(3),
        ];

        for (i, &tx_execution_id) in tx_execution_ids.iter().enumerate() {
            let result = if i % 2 == 0 {
                create_test_result_success()
            } else {
                create_test_result_error(&format!("error {i}"))
            };
            results.add_transaction_result(tx_execution_id, &result);
        }

        // All transactions should be present
        assert_eq!(results.transactions.len(), 3);
        for &tx_execution_id in &tx_execution_ids {
            assert!(results.get_transaction_result(&tx_execution_id).is_some());
        }

        // Check queue order (FIFO)
        for (i, &expected_id) in tx_execution_ids.iter().enumerate() {
            assert_eq!(results.transactions[i], expected_id);
        }
    }

    #[test]
    fn test_add_transaction_result_at_exact_capacity() {
        let transactions_state = TransactionsState::new();
        let capacity = 3;
        let mut results = TransactionsResults::new(transactions_state.clone(), capacity);

        // Add exactly max_capacity transactions
        for i in 0..capacity {
            let tx_execution_id = create_test_tx_execution_id(i as u8 + 1);
            let result = create_test_result_success();
            results.add_transaction_result(tx_execution_id, &result);
        }

        // Should have exactly capacity transactions
        assert_eq!(results.transactions.len(), capacity);

        // All should be retrievable
        for i in 0..capacity {
            let tx_execution_id = create_test_tx_execution_id(i as u8 + 1);
            assert!(results.get_transaction_result(&tx_execution_id).is_some());
        }
    }

    #[test]
    fn test_add_transaction_result_exceeds_capacity_prunes_fifo() {
        let transactions_state = TransactionsState::new();
        let capacity = 3;
        let mut results = TransactionsResults::new(transactions_state.clone(), capacity);

        // Add more than capacity
        let tx_execution_ids = vec![
            create_test_tx_execution_id(1), // This will be pruned first
            create_test_tx_execution_id(2), // This will be pruned second
            create_test_tx_execution_id(3), // This will remain
            create_test_tx_execution_id(4), // This will remain
            create_test_tx_execution_id(5), // This will remain
        ];

        for &tx_execution_id in &tx_execution_ids {
            let result = create_test_result_success();
            results.add_transaction_result(tx_execution_id, &result);
        }

        // Should still have only capacity transactions
        assert_eq!(results.transactions.len(), capacity);

        // First two should be pruned (FIFO)
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[0])
                .is_none()
        );
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[1])
                .is_none()
        );

        // Last three should remain
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[2])
                .is_some()
        );
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[3])
                .is_some()
        );
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[4])
                .is_some()
        );

        // Check queue contains the right transactions in FIFO order
        assert_eq!(results.transactions[0], tx_execution_ids[2]);
        assert_eq!(results.transactions[1], tx_execution_ids[3]);
        assert_eq!(results.transactions[2], tx_execution_ids[4]);
    }

    #[test]
    fn test_add_transaction_result_with_different_result_types() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 5);

        let tx_id_success = create_test_tx_execution_id(1);
        let tx_id_error = create_test_tx_execution_id(2);
        let tx_id_revert = create_test_tx_execution_id(3);

        let success_result = create_test_result_success();
        let error_result = create_test_result_error("validation failed");
        let revert_result = create_test_result_revert();

        results.add_transaction_result(tx_id_success, &success_result.clone());
        results.add_transaction_result(tx_id_error, &error_result.clone());
        results.add_transaction_result(tx_id_revert, &revert_result.clone());

        // All should be stored correctly
        assert_eq!(
            *results.get_transaction_result(&tx_id_success).unwrap(),
            success_result
        );
        assert_eq!(
            *results.get_transaction_result(&tx_id_error).unwrap(),
            error_result
        );
        assert_eq!(
            *results.get_transaction_result(&tx_id_revert).unwrap(),
            revert_result
        );
    }

    #[test]
    fn test_extensive_pruning_behavior() {
        let transactions_state = TransactionsState::new();
        let capacity = 2;
        let mut results = TransactionsResults::new(transactions_state.clone(), capacity);

        // Add many transactions to test continuous pruning
        let mut tx_execution_ids = Vec::new();
        for i in 1..=10 {
            let tx_execution_id = create_test_tx_execution_id(i);
            tx_execution_ids.push(tx_execution_id);
            let result = create_test_result_error(&format!("error {i}"));
            results.add_transaction_result(tx_execution_id, &result);
        }

        // Should only have the last 2 transactions
        assert_eq!(results.transactions.len(), capacity);

        // Only the last 2 should be retrievable
        for tx_execution_id in tx_execution_ids.iter().take(8) {
            assert!(results.get_transaction_result(tx_execution_id).is_none());
        }
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[8])
                .is_some()
        );
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[9])
                .is_some()
        );

        // Check queue order
        assert_eq!(results.transactions[0], tx_execution_ids[8]);
        assert_eq!(results.transactions[1], tx_execution_ids[9]);
    }

    #[test]
    fn test_capacity_one_behavior() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 1);

        let tx_id1 = create_test_tx_execution_id(1);
        let tx_id2 = create_test_tx_execution_id(2);
        let tx_id3 = create_test_tx_execution_id(3);

        let result1 = create_test_result_success();
        let result2 = create_test_result_error("error");
        let result3 = create_test_result_revert();

        // Add first transaction
        results.add_transaction_result(tx_id1, &result1);
        assert_eq!(results.transactions.len(), 1);
        assert!(results.get_transaction_result(&tx_id1).is_some());

        // Add second transaction - should replace first
        results.add_transaction_result(tx_id2, &result2);
        assert_eq!(results.transactions.len(), 1);
        assert!(results.get_transaction_result(&tx_id1).is_none());
        assert!(results.get_transaction_result(&tx_id2).is_some());

        // Add third transaction - should replace second
        results.add_transaction_result(tx_id3, &result3);
        assert_eq!(results.transactions.len(), 1);
        assert!(results.get_transaction_result(&tx_id1).is_none());
        assert!(results.get_transaction_result(&tx_id2).is_none());
        assert!(results.get_transaction_result(&tx_id3).is_some());

        // Queue should contain only the latest transaction
        assert_eq!(results.transactions[0], tx_id3);
    }

    #[test]
    fn test_get_all_transaction_result_reflects_current_state() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 3);

        // Initially empty
        assert_eq!(results.get_all_transaction_result().len(), 0);

        // Add some transactions
        let tx_execution_ids = [
            create_test_tx_execution_id(1),
            create_test_tx_execution_id(2),
            create_test_tx_execution_id(3),
            create_test_tx_execution_id(4), // This will cause pruning
        ];

        for &tx_execution_id in &tx_execution_ids[..3] {
            let result = create_test_result_success();
            results.add_transaction_result(tx_execution_id, &result);
        }

        assert_eq!(results.get_all_transaction_result().len(), 3);

        // Add one more to trigger pruning
        results.add_transaction_result(tx_execution_ids[3], &create_test_result_success());

        // Should still have 3, but different ones
        assert_eq!(results.get_all_transaction_result().len(), 3);

        // Verify the pruned transaction is not in the map
        assert!(
            !results
                .get_all_transaction_result()
                .contains_key(&tx_execution_ids[0])
        );
        assert!(
            results
                .get_all_transaction_result()
                .contains_key(&tx_execution_ids[3])
        );
    }

    #[test]
    fn test_same_transaction_hash_overwrites() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 5);

        let tx_execution_id = create_test_tx_execution_id(1);
        let result1 = create_test_result_success();
        let result2 = create_test_result_error("different error");

        // Add first result
        results.add_transaction_result(tx_execution_id, &result1);
        assert_eq!(results.transactions.len(), 1);

        // Add second result with same hash
        results.add_transaction_result(tx_execution_id, &result2.clone());

        // Should have 2 entries in queue (duplicate hash)
        assert_eq!(results.transactions.len(), 2);
        assert_eq!(results.transactions[0], tx_execution_id);
        assert_eq!(results.transactions[1], tx_execution_id);

        // But the result should be the latest one
        assert_eq!(
            *results.get_transaction_result(&tx_execution_id).unwrap(),
            result2
        );
    }

    #[test]
    fn test_no_reallocation_when_at_capacity() {
        let transactions_state = TransactionsState::new();
        let capacity = 3;
        let mut results = TransactionsResults::new(transactions_state.clone(), capacity);

        // Fill to capacity
        for i in 0..capacity {
            let tx_execution_id = create_test_tx_execution_id(i as u8 + 1);
            let result = create_test_result_success();
            results.add_transaction_result(tx_execution_id, &result);
        }

        // Get the initial capacity of the VecDeque
        let initial_capacity = results.transactions.capacity();

        // Add many more transactions beyond capacity
        for i in capacity..(capacity + 10) {
            let tx_execution_id = create_test_tx_execution_id(i as u8 + 1);
            let result = create_test_result_success();
            results.add_transaction_result(tx_execution_id, &result);

            // Verify no reallocation occurred
            assert_eq!(
                results.transactions.capacity(),
                initial_capacity,
                "VecDeque capacity should not change - no reallocation should occur"
            );

            // Verify we maintain exactly the capacity
            assert_eq!(
                results.transactions.len(),
                capacity,
                "Should maintain exactly max_capacity transactions"
            );
        }
    }
}
