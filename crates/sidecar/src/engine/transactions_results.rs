use crate::{
    engine::TransactionResult,
    transactions_state::TransactionsState,
};
use revm::primitives::alloy_primitives::TxHash;
use std::{
    collections::VecDeque,
    sync::Arc,
};

/// Wrapper for `TransactionsState` for write-only operations.
/// `TransactionsResults` is a wrapper on top of `TransactionState` exposing only methods to insert
/// a new result generated by the engine.
/// `TransactionsResults` also handles the pruning of the `TransactionsResults`. The pruning follows
/// a FIFO model. The maximum capacity can be configurable.
#[derive(Debug)]
pub struct TransactionsResults {
    transactions_state: Arc<TransactionsState>,
    transactions: VecDeque<TxHash>,
    max_capacity: usize,
}

impl TransactionsResults {
    pub fn new(transactions_state: Arc<TransactionsState>, max_capacity: usize) -> Self {
        assert!(
            max_capacity > 0,
            "The maximum capacity must be greater than 0"
        );
        Self {
            transactions: VecDeque::with_capacity(max_capacity),
            max_capacity,
            transactions_state,
        }
    }

    pub fn add_transaction_result(&mut self, tx_hash: TxHash, result: &TransactionResult) {
        self.transactions_state
            .add_transaction_result(tx_hash, result);

        // If at capacity, remove the oldest before adding the new one
        if self.transactions.len() == self.max_capacity
            && let Some(old_tx_hash) = self.transactions.pop_front()
        {
            self.transactions_state
                .remove_transaction_result(&old_tx_hash);
        }

        self.transactions.push_back(tx_hash);
    }

    pub fn remove_transaction_result(&mut self, tx_hash: TxHash) {
        self.transactions_state.remove_transaction_result(&tx_hash);
    }

    #[cfg(test)]
    pub fn get_transaction_result(
        &self,
        tx_hash: &assertion_executor::primitives::B256,
    ) -> Option<
        dashmap::mapref::one::Ref<'_, assertion_executor::primitives::B256, TransactionResult>,
    > {
        self.transactions_state.get_transaction_result(tx_hash)
    }

    #[cfg(test)]
    pub fn get_all_transaction_result(
        &self,
    ) -> &dashmap::DashMap<assertion_executor::primitives::B256, TransactionResult> {
        self.transactions_state.get_all_transaction_result()
    }
}

#[cfg(test)]
mod tests {
    #![allow(clippy::cast_possible_truncation)]
    use super::*;
    use crate::{
        engine::TransactionResult,
        transactions_state::TransactionsState,
    };
    use assertion_executor::primitives::ExecutionResult;
    use revm::{
        context::result::{
            Output,
            SuccessReason,
        },
        primitives::Bytes,
    };

    // Helper function to create a test TransactionResult
    fn create_test_result_success() -> TransactionResult {
        TransactionResult::ValidationCompleted {
            execution_result: ExecutionResult::Success {
                reason: SuccessReason::Stop,
                gas_used: 21000,
                gas_refunded: 0,
                logs: Vec::new(),
                output: Output::Call(Bytes::new()),
            },
            is_valid: true,
        }
    }

    fn create_test_result_error(msg: &str) -> TransactionResult {
        TransactionResult::ValidationError(msg.to_string())
    }

    fn create_test_result_revert() -> TransactionResult {
        TransactionResult::ValidationCompleted {
            execution_result: ExecutionResult::Revert {
                gas_used: 15000,
                output: Bytes::from("revert reason"),
            },
            is_valid: false,
        }
    }

    // Helper to create a test TxHash
    fn create_test_tx_hash(byte: u8) -> TxHash {
        TxHash::from([byte; 32])
    }

    #[test]
    fn test_new_creates_empty_transactions_results() {
        let transactions_state = TransactionsState::new();
        let max_capacity = 10;

        let results = TransactionsResults::new(transactions_state, max_capacity);

        assert_eq!(results.max_capacity, max_capacity);
        assert_eq!(results.transactions.len(), 0);
        assert_eq!(results.transactions.capacity(), max_capacity);
    }

    #[test]
    fn test_add_transaction_result_stores_in_state_and_queue() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 5);

        let tx_hash = create_test_tx_hash(1);
        let result = create_test_result_success();

        results.add_transaction_result(tx_hash, &result.clone());

        // Check that transaction is in queue
        assert_eq!(results.transactions.len(), 1);
        assert_eq!(results.transactions[0], tx_hash);

        // Check that transaction result is stored in state
        let stored_result = results.get_transaction_result(&tx_hash);
        assert!(stored_result.is_some());
        assert_eq!(*stored_result.unwrap(), result);
    }

    #[test]
    fn test_add_multiple_transaction_results_within_capacity() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 5);

        let tx_hashes = vec![
            create_test_tx_hash(1),
            create_test_tx_hash(2),
            create_test_tx_hash(3),
        ];

        for (i, &tx_hash) in tx_hashes.iter().enumerate() {
            let result = if i % 2 == 0 {
                create_test_result_success()
            } else {
                create_test_result_error(&format!("error {i}"))
            };
            results.add_transaction_result(tx_hash, &result);
        }

        // All transactions should be present
        assert_eq!(results.transactions.len(), 3);
        for &tx_hash in &tx_hashes {
            assert!(results.get_transaction_result(&tx_hash).is_some());
        }

        // Check queue order (FIFO)
        for (i, &expected_hash) in tx_hashes.iter().enumerate() {
            assert_eq!(results.transactions[i], expected_hash);
        }
    }

    #[test]
    fn test_add_transaction_result_at_exact_capacity() {
        let transactions_state = TransactionsState::new();
        let capacity = 3;
        let mut results = TransactionsResults::new(transactions_state.clone(), capacity);

        // Add exactly max_capacity transactions
        for i in 0..capacity {
            let tx_hash = create_test_tx_hash(i as u8 + 1);
            let result = create_test_result_success();
            results.add_transaction_result(tx_hash, &result);
        }

        // Should have exactly capacity transactions
        assert_eq!(results.transactions.len(), capacity);

        // All should be retrievable
        for i in 0..capacity {
            let tx_hash = create_test_tx_hash(i as u8 + 1);
            assert!(results.get_transaction_result(&tx_hash).is_some());
        }
    }

    #[test]
    fn test_add_transaction_result_exceeds_capacity_prunes_fifo() {
        let transactions_state = TransactionsState::new();
        let capacity = 3;
        let mut results = TransactionsResults::new(transactions_state.clone(), capacity);

        // Add more than capacity
        let tx_hashes = vec![
            create_test_tx_hash(1), // This will be pruned first
            create_test_tx_hash(2), // This will be pruned second
            create_test_tx_hash(3), // This will remain
            create_test_tx_hash(4), // This will remain
            create_test_tx_hash(5), // This will remain
        ];

        for &tx_hash in &tx_hashes {
            let result = create_test_result_success();
            results.add_transaction_result(tx_hash, &result);
        }

        // Should still have only capacity transactions
        assert_eq!(results.transactions.len(), capacity);

        // First two should be pruned (FIFO)
        assert!(results.get_transaction_result(&tx_hashes[0]).is_none());
        assert!(results.get_transaction_result(&tx_hashes[1]).is_none());

        // Last three should remain
        assert!(results.get_transaction_result(&tx_hashes[2]).is_some());
        assert!(results.get_transaction_result(&tx_hashes[3]).is_some());
        assert!(results.get_transaction_result(&tx_hashes[4]).is_some());

        // Check queue contains the right transactions in FIFO order
        assert_eq!(results.transactions[0], tx_hashes[2]);
        assert_eq!(results.transactions[1], tx_hashes[3]);
        assert_eq!(results.transactions[2], tx_hashes[4]);
    }

    #[test]
    fn test_add_transaction_result_with_different_result_types() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 5);

        let tx_hash_success = create_test_tx_hash(1);
        let tx_hash_error = create_test_tx_hash(2);
        let tx_hash_revert = create_test_tx_hash(3);

        let success_result = create_test_result_success();
        let error_result = create_test_result_error("validation failed");
        let revert_result = create_test_result_revert();

        results.add_transaction_result(tx_hash_success, &success_result.clone());
        results.add_transaction_result(tx_hash_error, &error_result.clone());
        results.add_transaction_result(tx_hash_revert, &revert_result.clone());

        // All should be stored correctly
        assert_eq!(
            *results.get_transaction_result(&tx_hash_success).unwrap(),
            success_result
        );
        assert_eq!(
            *results.get_transaction_result(&tx_hash_error).unwrap(),
            error_result
        );
        assert_eq!(
            *results.get_transaction_result(&tx_hash_revert).unwrap(),
            revert_result
        );
    }

    #[test]
    fn test_extensive_pruning_behavior() {
        let transactions_state = TransactionsState::new();
        let capacity = 2;
        let mut results = TransactionsResults::new(transactions_state.clone(), capacity);

        // Add many transactions to test continuous pruning
        let mut tx_hashes = Vec::new();
        for i in 1..=10 {
            let tx_hash = create_test_tx_hash(i);
            tx_hashes.push(tx_hash);
            let result = create_test_result_error(&format!("error {i}"));
            results.add_transaction_result(tx_hash, &result);
        }

        // Should only have the last 2 transactions
        assert_eq!(results.transactions.len(), capacity);

        // Only the last 2 should be retrievable
        for tx_hash in tx_hashes.iter().take(8) {
            assert!(results.get_transaction_result(tx_hash).is_none());
        }
        assert!(results.get_transaction_result(&tx_hashes[8]).is_some());
        assert!(results.get_transaction_result(&tx_hashes[9]).is_some());

        // Check queue order
        assert_eq!(results.transactions[0], tx_hashes[8]);
        assert_eq!(results.transactions[1], tx_hashes[9]);
    }

    #[test]
    fn test_capacity_one_behavior() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 1);

        let tx_hash1 = create_test_tx_hash(1);
        let tx_hash2 = create_test_tx_hash(2);
        let tx_hash3 = create_test_tx_hash(3);

        let result1 = create_test_result_success();
        let result2 = create_test_result_error("error");
        let result3 = create_test_result_revert();

        // Add first transaction
        results.add_transaction_result(tx_hash1, &result1);
        assert_eq!(results.transactions.len(), 1);
        assert!(results.get_transaction_result(&tx_hash1).is_some());

        // Add second transaction - should replace first
        results.add_transaction_result(tx_hash2, &result2);
        assert_eq!(results.transactions.len(), 1);
        assert!(results.get_transaction_result(&tx_hash1).is_none());
        assert!(results.get_transaction_result(&tx_hash2).is_some());

        // Add third transaction - should replace second
        results.add_transaction_result(tx_hash3, &result3);
        assert_eq!(results.transactions.len(), 1);
        assert!(results.get_transaction_result(&tx_hash1).is_none());
        assert!(results.get_transaction_result(&tx_hash2).is_none());
        assert!(results.get_transaction_result(&tx_hash3).is_some());

        // Queue should contain only the latest transaction
        assert_eq!(results.transactions[0], tx_hash3);
    }

    #[test]
    fn test_get_all_transaction_result_reflects_current_state() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 3);

        // Initially empty
        assert_eq!(results.get_all_transaction_result().len(), 0);

        // Add some transactions
        let tx_hashes = [
            create_test_tx_hash(1),
            create_test_tx_hash(2),
            create_test_tx_hash(3),
            create_test_tx_hash(4), // This will cause pruning
        ];

        for &tx_hash in &tx_hashes[..3] {
            let result = create_test_result_success();
            results.add_transaction_result(tx_hash, &result);
        }

        assert_eq!(results.get_all_transaction_result().len(), 3);

        // Add one more to trigger pruning
        results.add_transaction_result(tx_hashes[3], &create_test_result_success());

        // Should still have 3, but different ones
        assert_eq!(results.get_all_transaction_result().len(), 3);

        // Verify the pruned transaction is not in the map
        assert!(
            !results
                .get_all_transaction_result()
                .contains_key(&tx_hashes[0])
        );
        assert!(
            results
                .get_all_transaction_result()
                .contains_key(&tx_hashes[3])
        );
    }

    #[test]
    fn test_same_transaction_hash_overwrites() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state.clone(), 5);

        let tx_hash = create_test_tx_hash(1);
        let result1 = create_test_result_success();
        let result2 = create_test_result_error("different error");

        // Add first result
        results.add_transaction_result(tx_hash, &result1);
        assert_eq!(results.transactions.len(), 1);

        // Add second result with same hash
        results.add_transaction_result(tx_hash, &result2.clone());

        // Should have 2 entries in queue (duplicate hash)
        assert_eq!(results.transactions.len(), 2);
        assert_eq!(results.transactions[0], tx_hash);
        assert_eq!(results.transactions[1], tx_hash);

        // But the result should be the latest one
        assert_eq!(*results.get_transaction_result(&tx_hash).unwrap(), result2);
    }

    #[test]
    fn test_no_reallocation_when_at_capacity() {
        let transactions_state = TransactionsState::new();
        let capacity = 3;
        let mut results = TransactionsResults::new(transactions_state.clone(), capacity);

        // Fill to capacity
        for i in 0..capacity {
            let tx_hash = create_test_tx_hash(i as u8 + 1);
            let result = create_test_result_success();
            results.add_transaction_result(tx_hash, &result);
        }

        // Get the initial capacity of the VecDeque
        let initial_capacity = results.transactions.capacity();

        // Add many more transactions beyond capacity
        for i in capacity..(capacity + 10) {
            let tx_hash = create_test_tx_hash(i as u8 + 1);
            let result = create_test_result_success();
            results.add_transaction_result(tx_hash, &result);

            // Verify no reallocation occurred
            assert_eq!(
                results.transactions.capacity(),
                initial_capacity,
                "VecDeque capacity should not change - no reallocation should occur"
            );

            // Verify we maintain exactly the capacity
            assert_eq!(
                results.transactions.len(),
                capacity,
                "Should maintain exactly max_capacity transactions"
            );
        }
    }
}
