use crate::{
    engine::TransactionResult,
    execution_ids::TxExecutionId,
    metrics::EngineTransactionsResultMetrics,
    transactions_state::TransactionsState,
};
use hashlink::LinkedHashMap;
use std::sync::Arc;

/// Wrapper for `TransactionsState` for write-only operations.
/// `TransactionsResults` is a wrapper on top of `TransactionState` exposing only methods to insert
/// a new result generated by the engine.
/// `TransactionsResults` also handles the pruning of the `TransactionsResults`. The pruning follows
/// a LRU model. The maximum capacity can be configurable.
#[derive(Debug)]
pub struct TransactionsResults {
    transactions_state: Arc<TransactionsState>,
    /// Ordered map: maintains insertion order with O(1) operations.
    /// Value is () since we only need the key ordering.
    transactions: LinkedHashMap<TxExecutionId, ()>,
    max_capacity: usize,
    metrics: EngineTransactionsResultMetrics,
}

impl TransactionsResults {
    /// Creates a new `TransactionsResults` with the given capacity.
    ///
    /// # Panics
    /// Panics if `max_capacity` is 0.
    pub fn new(transactions_state: Arc<TransactionsState>, max_capacity: usize) -> Self {
        assert!(
            max_capacity > 0,
            "The maximum capacity must be greater than 0"
        );
        Self {
            transactions: LinkedHashMap::with_capacity(max_capacity),
            max_capacity,
            transactions_state,
            metrics: EngineTransactionsResultMetrics::default(),
        }
    }

    /// If the transaction already exists, it's moved to the back (most recent)
    /// and its result is updated. If at capacity, the oldest transaction is pruned.
    #[inline]
    pub fn add_transaction_result(
        &mut self,
        tx_execution_id: TxExecutionId,
        result: &TransactionResult,
    ) {
        // Check if this is an update (tx already exists)
        if self.transactions.contains_key(&tx_execution_id) {
            // Move to back by removing and re-inserting
            self.transactions.remove(&tx_execution_id);
            self.transactions.insert(tx_execution_id, ());
            // Update the result in state
            self.transactions_state
                .add_transaction_result(tx_execution_id, result);
            return;
        }

        // New transaction
        let transactions_len = self.transactions.len();
        let (accepted_txs_len, transaction_results_pending_requests_len, transaction_results_len) =
            self.transactions_state.get_all_lengths();
        self.metrics.set_engine_transaction_length(transactions_len);
        self.metrics
            .set_engine_transactions_state_accepted_txs_length(accepted_txs_len);
        self.metrics
            .set_engine_transactions_state_transaction_results_pending_requests_length(
                transaction_results_pending_requests_len,
            );
        self.metrics
            .set_engine_transactions_state_transaction_results_length(transaction_results_len);
        if transactions_len >= self.max_capacity {
            // Remove oldest (front)
            if let Some((old_tx_id, ())) = self.transactions.pop_front() {
                self.transactions_state
                    .remove_transaction_result(&old_tx_id);
            }
        }

        // Insert a new transaction
        self.transactions.insert(tx_execution_id, ());
        self.transactions_state
            .add_transaction_result(tx_execution_id, result);
    }

    /// Removes from both the queue and the state to keep them in sync.
    #[inline]
    pub fn remove_transaction_result(&mut self, tx_execution_id: TxExecutionId) {
        self.transactions.remove(&tx_execution_id);
        self.transactions_state
            .remove_transaction_result(&tx_execution_id);
    }

    #[cfg(test)]
    pub fn len(&self) -> usize {
        self.transactions.len()
    }

    #[cfg(test)]
    pub fn is_empty(&self) -> bool {
        self.transactions.is_empty()
    }

    /// Gets the transaction result for the given `TxExecutionId` if it exists.
    pub fn get_transaction_result(
        &self,
        tx_execution_id: &TxExecutionId,
    ) -> Option<dashmap::mapref::one::Ref<'_, TxExecutionId, TransactionResult>> {
        self.transactions_state
            .get_transaction_result(tx_execution_id)
    }

    #[cfg(test)]
    pub fn get_all_transaction_result(
        &self,
    ) -> &dashmap::DashMap<TxExecutionId, TransactionResult> {
        self.transactions_state.get_all_transaction_result()
    }

    #[cfg(test)]
    pub fn get_queue_order(&self) -> Vec<TxExecutionId> {
        self.transactions.keys().copied().collect()
    }
}

#[cfg(test)]
mod tests {
    #![allow(clippy::cast_possible_truncation)]
    #![allow(clippy::needless_range_loop)]

    use super::*;
    use alloy::primitives::U256;
    use assertion_executor::primitives::ExecutionResult;
    use revm::{
        context::result::{
            Output,
            SuccessReason,
        },
        primitives::Bytes,
    };

    fn create_test_result_success() -> TransactionResult {
        TransactionResult::ValidationCompleted {
            execution_result: ExecutionResult::Success {
                reason: SuccessReason::Stop,
                gas_used: 21000,
                gas_refunded: 0,
                logs: Vec::new(),
                output: Output::Call(Bytes::new()),
            },
            is_valid: true,
        }
    }

    fn create_test_result_error(msg: &str) -> TransactionResult {
        TransactionResult::ValidationError(msg.to_string())
    }

    fn create_test_result_revert() -> TransactionResult {
        TransactionResult::ValidationCompleted {
            execution_result: ExecutionResult::Revert {
                gas_used: 15000,
                output: Bytes::from("revert reason"),
            },
            is_valid: false,
        }
    }

    fn create_test_tx_execution_id(byte: u8) -> TxExecutionId {
        let tx_hash = revm::primitives::alloy_primitives::TxHash::from([byte; 32]);
        TxExecutionId::new(U256::from(byte), 0, tx_hash, 0)
    }

    #[test]
    fn test_new_creates_empty_transactions_results() {
        let transactions_state = TransactionsState::new();
        let max_capacity = 10;

        let results = TransactionsResults::new(transactions_state, max_capacity);

        assert_eq!(results.max_capacity, max_capacity);
        assert_eq!(results.len(), 0);
    }

    #[test]
    fn test_add_transaction_result_stores_in_state_and_queue() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state, 5);

        let tx_execution_id = create_test_tx_execution_id(1);
        let result = create_test_result_success();

        results.add_transaction_result(tx_execution_id, &result);

        assert_eq!(results.len(), 1);
        let stored_result = results.get_transaction_result(&tx_execution_id);
        assert!(stored_result.is_some());
        assert_eq!(*stored_result.unwrap(), result);
    }

    #[test]
    fn test_add_multiple_transaction_results_within_capacity() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state, 5);

        let tx_execution_ids = vec![
            create_test_tx_execution_id(1),
            create_test_tx_execution_id(2),
            create_test_tx_execution_id(3),
        ];

        for (i, &tx_execution_id) in tx_execution_ids.iter().enumerate() {
            let result = if i % 2 == 0 {
                create_test_result_success()
            } else {
                create_test_result_error(&format!("error {i}"))
            };
            results.add_transaction_result(tx_execution_id, &result);
        }

        assert_eq!(results.len(), 3);
        for &tx_execution_id in &tx_execution_ids {
            assert!(results.get_transaction_result(&tx_execution_id).is_some());
        }

        let queue_order = results.get_queue_order();
        assert_eq!(queue_order, tx_execution_ids);
    }

    #[test]
    fn test_add_transaction_result_at_exact_capacity() {
        let transactions_state = TransactionsState::new();
        let capacity = 3;
        let mut results = TransactionsResults::new(transactions_state, capacity);

        for i in 0..capacity {
            let tx_execution_id = create_test_tx_execution_id(u8::try_from(i).unwrap() + 1);
            let result = create_test_result_success();
            results.add_transaction_result(tx_execution_id, &result);
        }

        assert_eq!(results.len(), capacity);

        for i in 0..capacity {
            let tx_execution_id = create_test_tx_execution_id(u8::try_from(i).unwrap() + 1);
            assert!(results.get_transaction_result(&tx_execution_id).is_some());
        }
    }

    #[test]
    fn test_add_transaction_result_exceeds_capacity_prunes_fifo() {
        let transactions_state = TransactionsState::new();
        let capacity = 3;
        let mut results = TransactionsResults::new(transactions_state, capacity);

        let tx_execution_ids = vec![
            create_test_tx_execution_id(1),
            create_test_tx_execution_id(2),
            create_test_tx_execution_id(3),
            create_test_tx_execution_id(4),
            create_test_tx_execution_id(5),
        ];

        for &tx_execution_id in &tx_execution_ids {
            let result = create_test_result_success();
            results.add_transaction_result(tx_execution_id, &result);
        }

        assert_eq!(results.len(), capacity);

        // First two should be pruned (FIFO)
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[0])
                .is_none()
        );
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[1])
                .is_none()
        );

        // Last three should remain
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[2])
                .is_some()
        );
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[3])
                .is_some()
        );
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[4])
                .is_some()
        );

        let queue_order = results.get_queue_order();
        assert_eq!(queue_order[0], tx_execution_ids[2]);
        assert_eq!(queue_order[1], tx_execution_ids[3]);
        assert_eq!(queue_order[2], tx_execution_ids[4]);
    }

    #[test]
    fn test_add_transaction_result_with_different_result_types() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state, 5);

        let tx_id_success = create_test_tx_execution_id(1);
        let tx_id_error = create_test_tx_execution_id(2);
        let tx_id_revert = create_test_tx_execution_id(3);

        let success_result = create_test_result_success();
        let error_result = create_test_result_error("validation failed");
        let revert_result = create_test_result_revert();

        results.add_transaction_result(tx_id_success, &success_result);
        results.add_transaction_result(tx_id_error, &error_result);
        results.add_transaction_result(tx_id_revert, &revert_result);

        assert_eq!(
            *results.get_transaction_result(&tx_id_success).unwrap(),
            success_result
        );
        assert_eq!(
            *results.get_transaction_result(&tx_id_error).unwrap(),
            error_result
        );
        assert_eq!(
            *results.get_transaction_result(&tx_id_revert).unwrap(),
            revert_result
        );
    }

    #[test]
    fn test_extensive_pruning_behavior() {
        let transactions_state = TransactionsState::new();
        let capacity = 2;
        let mut results = TransactionsResults::new(transactions_state, capacity);

        let mut tx_execution_ids = Vec::new();
        for i in 1..=10 {
            let tx_execution_id = create_test_tx_execution_id(i);
            tx_execution_ids.push(tx_execution_id);
            let result = create_test_result_error(&format!("error {i}"));
            results.add_transaction_result(tx_execution_id, &result);
        }

        assert_eq!(results.len(), capacity);

        for tx_execution_id in tx_execution_ids.iter().take(8) {
            assert!(results.get_transaction_result(tx_execution_id).is_none());
        }
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[8])
                .is_some()
        );
        assert!(
            results
                .get_transaction_result(&tx_execution_ids[9])
                .is_some()
        );

        let queue_order = results.get_queue_order();
        assert_eq!(queue_order[0], tx_execution_ids[8]);
        assert_eq!(queue_order[1], tx_execution_ids[9]);
    }

    #[test]
    fn test_capacity_one_behavior() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state, 1);

        let tx_id1 = create_test_tx_execution_id(1);
        let tx_id2 = create_test_tx_execution_id(2);
        let tx_id3 = create_test_tx_execution_id(3);

        let result1 = create_test_result_success();
        let result2 = create_test_result_error("error");
        let result3 = create_test_result_revert();

        results.add_transaction_result(tx_id1, &result1);
        assert_eq!(results.len(), 1);
        assert!(results.get_transaction_result(&tx_id1).is_some());

        results.add_transaction_result(tx_id2, &result2);
        assert_eq!(results.len(), 1);
        assert!(results.get_transaction_result(&tx_id1).is_none());
        assert!(results.get_transaction_result(&tx_id2).is_some());

        results.add_transaction_result(tx_id3, &result3);
        assert_eq!(results.len(), 1);
        assert!(results.get_transaction_result(&tx_id1).is_none());
        assert!(results.get_transaction_result(&tx_id2).is_none());
        assert!(results.get_transaction_result(&tx_id3).is_some());

        let queue_order = results.get_queue_order();
        assert_eq!(queue_order[0], tx_id3);
    }

    #[test]
    fn test_get_all_transaction_result_reflects_current_state() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state, 3);

        assert_eq!(results.get_all_transaction_result().len(), 0);

        let tx_execution_ids = [
            create_test_tx_execution_id(1),
            create_test_tx_execution_id(2),
            create_test_tx_execution_id(3),
            create_test_tx_execution_id(4),
        ];

        for &tx_execution_id in &tx_execution_ids[..3] {
            let result = create_test_result_success();
            results.add_transaction_result(tx_execution_id, &result);
        }

        assert_eq!(results.get_all_transaction_result().len(), 3);

        results.add_transaction_result(tx_execution_ids[3], &create_test_result_success());

        assert_eq!(results.get_all_transaction_result().len(), 3);
        assert!(
            !results
                .get_all_transaction_result()
                .contains_key(&tx_execution_ids[0])
        );
        assert!(
            results
                .get_all_transaction_result()
                .contains_key(&tx_execution_ids[3])
        );
    }

    #[test]
    fn test_same_transaction_updates_instead_of_duplicating() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state, 5);

        let tx_execution_id = create_test_tx_execution_id(1);
        let result1 = create_test_result_success();
        let result2 = create_test_result_error("updated error");

        results.add_transaction_result(tx_execution_id, &result1);
        assert_eq!(results.len(), 1);

        // Add same tx with different result - should UPDATE, not duplicate
        results.add_transaction_result(tx_execution_id, &result2);

        // Should still have only 1 entry
        assert_eq!(results.len(), 1);

        // Result should be the updated one
        assert_eq!(
            *results.get_transaction_result(&tx_execution_id).unwrap(),
            result2
        );
    }

    #[test]
    fn test_update_moves_tx_to_end_of_queue() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state, 5);

        let tx_id1 = create_test_tx_execution_id(1);
        let tx_id2 = create_test_tx_execution_id(2);
        let tx_id3 = create_test_tx_execution_id(3);

        results.add_transaction_result(tx_id1, &create_test_result_success());
        results.add_transaction_result(tx_id2, &create_test_result_success());
        results.add_transaction_result(tx_id3, &create_test_result_success());

        let queue_order = results.get_queue_order();
        assert_eq!(queue_order, vec![tx_id1, tx_id2, tx_id3]);

        // Update tx_id1 - should move it to the end
        results.add_transaction_result(tx_id1, &create_test_result_error("updated"));

        let queue_order = results.get_queue_order();
        assert_eq!(queue_order, vec![tx_id2, tx_id3, tx_id1]);
    }

    #[test]
    fn test_update_does_not_trigger_pruning() {
        let transactions_state = TransactionsState::new();
        let capacity = 3;
        let mut results = TransactionsResults::new(transactions_state, capacity);

        let tx_id1 = create_test_tx_execution_id(1);
        let tx_id2 = create_test_tx_execution_id(2);
        let tx_id3 = create_test_tx_execution_id(3);

        results.add_transaction_result(tx_id1, &create_test_result_success());
        results.add_transaction_result(tx_id2, &create_test_result_success());
        results.add_transaction_result(tx_id3, &create_test_result_success());

        assert_eq!(results.len(), capacity);

        // Update tx_id1 - should NOT trigger pruning since it's an update
        results.add_transaction_result(tx_id1, &create_test_result_error("updated"));

        // All three should still be present
        assert_eq!(results.len(), capacity);
        assert!(results.get_transaction_result(&tx_id1).is_some());
        assert!(results.get_transaction_result(&tx_id2).is_some());
        assert!(results.get_transaction_result(&tx_id3).is_some());
    }

    #[test]
    fn test_remove_transaction_result_updates_both_state_and_queue() {
        let transactions_state = TransactionsState::new();
        let mut results = TransactionsResults::new(transactions_state, 5);

        let tx_id1 = create_test_tx_execution_id(1);
        let tx_id2 = create_test_tx_execution_id(2);
        let tx_id3 = create_test_tx_execution_id(3);

        results.add_transaction_result(tx_id1, &create_test_result_success());
        results.add_transaction_result(tx_id2, &create_test_result_success());
        results.add_transaction_result(tx_id3, &create_test_result_success());

        assert_eq!(results.len(), 3);

        // Remove the middle transaction
        results.remove_transaction_result(tx_id2);

        // Queue should have 2 entries now
        assert_eq!(results.len(), 2);

        // State should not have tx_id2
        assert!(results.get_transaction_result(&tx_id2).is_none());

        // Queue should have the correct order
        let queue_order = results.get_queue_order();
        assert_eq!(queue_order, vec![tx_id1, tx_id3]);
    }

    #[test]
    fn test_remove_then_add_new_respects_capacity() {
        let transactions_state = TransactionsState::new();
        let capacity = 3;
        let mut results = TransactionsResults::new(transactions_state, capacity);

        let tx_id1 = create_test_tx_execution_id(1);
        let tx_id2 = create_test_tx_execution_id(2);
        let tx_id3 = create_test_tx_execution_id(3);
        let tx_id4 = create_test_tx_execution_id(4);

        // Fill to capacity
        results.add_transaction_result(tx_id1, &create_test_result_success());
        results.add_transaction_result(tx_id2, &create_test_result_success());
        results.add_transaction_result(tx_id3, &create_test_result_success());

        // Remove one
        results.remove_transaction_result(tx_id2);
        assert_eq!(results.len(), 2);

        // Add a new one - should NOT trigger pruning since we have space
        results.add_transaction_result(tx_id4, &create_test_result_success());

        assert_eq!(results.len(), 3);
        assert!(results.get_transaction_result(&tx_id1).is_some());
        assert!(results.get_transaction_result(&tx_id3).is_some());
        assert!(results.get_transaction_result(&tx_id4).is_some());
    }

    #[test]
    fn test_queue_and_state_remain_in_sync_under_mixed_operations() {
        let transactions_state = TransactionsState::new();
        let capacity = 5;
        let mut results = TransactionsResults::new(transactions_state, capacity);

        let ops = vec![
            ("add", 1),
            ("add", 2),
            ("add", 3),
            ("remove", 2),
            ("add", 4),
            ("add", 1), // Update existing
            ("add", 5),
            ("add", 6),
            ("remove", 3),
            ("add", 7),
            ("add", 8), // Should trigger pruning
        ];

        for (op, id) in ops {
            let tx_id = create_test_tx_execution_id(id);
            match op {
                "add" => results.add_transaction_result(tx_id, &create_test_result_success()),
                "remove" => results.remove_transaction_result(tx_id),
                _ => panic!("unknown op"),
            }

            // Verify invariant: queue length == state length
            let queue_len = results.len();
            let state_len = results.get_all_transaction_result().len();
            assert_eq!(
                queue_len, state_len,
                "Queue and state out of sync after op {op} on id {id}"
            );

            // Verify invariant: all queue entries exist in state
            for tx_id in results.get_queue_order() {
                assert!(
                    results.get_transaction_result(&tx_id).is_some(),
                    "Queue contains {tx_id:?} but state does not"
                );
            }
        }
    }

    #[test]
    fn test_o1_performance_at_scale() {
        let transactions_state = TransactionsState::new();
        let capacity = 10_000;
        let mut results = TransactionsResults::new(transactions_state, capacity);

        // Fill to capacity
        for i in 0..capacity {
            let tx_id = TxExecutionId::new(
                U256::from(i),
                0,
                revm::primitives::alloy_primitives::TxHash::from([((i % 256) as u8); 32]),
                0,
            );
            results.add_transaction_result(tx_id, &create_test_result_success());
        }

        let start = std::time::Instant::now();

        // Add 1000 more (triggers 1000 prunings from front)
        for i in capacity..(capacity + 1000) {
            let tx_id = TxExecutionId::new(
                U256::from(i),
                0,
                revm::primitives::alloy_primitives::TxHash::from([((i % 256) as u8); 32]),
                0,
            );
            results.add_transaction_result(tx_id, &create_test_result_success());
        }

        let elapsed = start.elapsed();

        // O(1) operations should complete very fast
        assert!(
            elapsed.as_millis() < 100,
            "Operations took too long: {:?}ms - indicates non-O(1) behavior",
            elapsed.as_millis()
        );

        assert_eq!(results.len(), capacity);
    }

    #[test]
    fn test_o1_arbitrary_removal() {
        let transactions_state = TransactionsState::new();
        let capacity = 10_000;
        let mut results = TransactionsResults::new(transactions_state, capacity);

        // Fill to capacity
        let mut tx_ids = Vec::with_capacity(capacity);
        for i in 0..capacity {
            let tx_id = TxExecutionId::new(
                U256::from(i),
                0,
                revm::primitives::alloy_primitives::TxHash::from([((i % 256) as u8); 32]),
                0,
            );
            tx_ids.push(tx_id);
            results.add_transaction_result(tx_id, &create_test_result_success());
        }

        let start = std::time::Instant::now();

        // Remove 1000 items from the middle (indices 4500-5500)
        for i in 4500..5500 {
            results.remove_transaction_result(tx_ids[i]);
        }

        let elapsed = start.elapsed();

        // O(1) removals should be very fast
        assert!(
            elapsed.as_millis() < 50,
            "Arbitrary removals took too long: {:?}ms - indicates non-O(1) behavior",
            elapsed.as_millis()
        );

        assert_eq!(results.len(), capacity - 1000);
    }
}
