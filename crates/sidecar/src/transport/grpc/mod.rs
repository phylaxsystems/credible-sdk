//! # `gRPC` transport
//!
//! The following is a transport implementation for gRPC/Protobuf for the sidecar.
//!
//! We use `prost` to generate protobuf rust code from a protobuf definition, and create a
//! `tonic` service from it.
//!
//! We implement the `Transport` trait here that binds the `tonic` service,
//! with the above mentioned generated definitions, inside of `run()`
//! and run the grpc server on the same address we would any other transport.
//!
//! ## Metrics
//! The grpc transport exposes the following metrics:
//! - `sidecar_rpc_duration_SendEvents`
//! - `sidecar_rpc_duration_SendTransactions`
//! - `sidecar_rpc_duration_Reorg`
//! - `sidecar_rpc_duration_GetTransactions`
//! - `sidecar_rpc_duration_GetTransaction`
//!
//! ## Type definitions
//! Protobuf typing can be found below:
//!
//! ```protobuf
#![doc = include_str!("./sidecar.proto")]
//! ```

#![allow(clippy::large_enum_variant)]
use crate::{
    engine::queue::TransactionQueueSender,
    transactions_state::TransactionsState,
    transport::{
        Transport,
        transactions_results::QueryTransactionsResults,
    },
    utils::ErrorRecoverability,
};
use std::{
    net::SocketAddr,
    sync::{
        Arc,
        atomic::AtomicBool,
    },
    time::Duration,
};
use tokio_util::sync::CancellationToken;
use tracing::{
    debug,
    error,
    info,
    instrument,
};

pub mod config;
mod server;

pub const TCP_KEEPALIVE: Duration = Duration::from_secs(60);
pub const HTTP2_KEEPALIVE_INTERVAL: Duration = Duration::from_secs(30);
pub const HTTP2_KEEPALIVE_TIMEOUT: Duration = Duration::from_secs(90);
pub const MAX_CONCURRENT_CONNECTIONS: u32 = 1000;
pub const INITIAL_STREAM_WINDOW: u32 = 1024 * 1024; // 1MB
pub const INITIAL_CONNECTION_WINDOW: u32 = 10 * 1024 * 1024; // 10MB
pub const MAX_FRAME_SIZE: u32 = 16384;

// Generated by build.rs from sidecar.proto
// The generated code path is implicit via tonic::include_proto. We wrap it into a module here
// to keep the public surface small and avoid exposing prost types outside this module.
#[allow(dead_code)]
mod pb_inner {
    tonic::include_proto!("sidecar.transport.v1");
}

#[cfg(test)]
pub mod pb {
    pub use super::pb_inner::*;
}

#[cfg(not(test))]
pub(crate) mod pb {
    pub(crate) use super::pb_inner::*;
}

#[derive(thiserror::Error, Debug)]
pub enum GrpcTransportError {
    #[error("Server error: {0}")]
    ServerError(String),
    #[error("Failed to bind the address: {0}")]
    BindAddress(String),
    #[error("Client error: {0}")]
    ClientError(String),
}

impl From<&GrpcTransportError> for ErrorRecoverability {
    fn from(e: &GrpcTransportError) -> Self {
        match e {
            GrpcTransportError::ServerError(_) | GrpcTransportError::BindAddress(_) => {
                Self::Unrecoverable
            }
            GrpcTransportError::ClientError(_) => Self::Recoverable,
        }
    }
}

/// Skeleton implementation of a gRPC `Transport`.
#[derive(Debug)]
pub struct GrpcTransport {
    /// Core engine queue sender.
    tx_sender: TransactionQueueSender,
    /// Server bind address
    bind_addr: SocketAddr,
    /// Shutdown cancellation token
    shutdown_token: CancellationToken,
    /// Shared transaction results state
    transactions_results: QueryTransactionsResults,
}

impl Transport for GrpcTransport {
    type Error = GrpcTransportError;
    type Config = config::GrpcTransportConfig;

    #[instrument(name = "grpc_transport::new", skip_all, level = "debug")]
    fn new(
        config: Self::Config,
        tx_sender: TransactionQueueSender,
        state_results: Arc<TransactionsState>,
    ) -> Result<Self, Self::Error> {
        debug!(bind_addr = %config.bind_addr, "Creating gRPC transport");
        Ok(Self {
            tx_sender,
            bind_addr: config.bind_addr,
            shutdown_token: CancellationToken::new(),
            transactions_results: QueryTransactionsResults::new(state_results),
        })
    }

    #[instrument(
        name = "grpc_transport::run",
        skip(self),
        fields(bind_addr = %self.bind_addr),
        level = "info"
    )]
    async fn run(&self) -> Result<(), Self::Error> {
        use tonic::transport::Server;

        let service =
            server::GrpcService::new(self.tx_sender.clone(), self.transactions_results.clone());

        info!(bind_addr = %self.bind_addr, "gRPC transport server starting");

        let shutdown = self.shutdown_token.clone();
        Server::builder()
            .tcp_nodelay(true)
            .tcp_keepalive(Some(TCP_KEEPALIVE))
            .http2_keepalive_interval(Some(HTTP2_KEEPALIVE_INTERVAL))
            .http2_keepalive_timeout(Some(HTTP2_KEEPALIVE_TIMEOUT))
            .http2_adaptive_window(Some(true))
            .max_concurrent_streams(Some(1000))
            .initial_stream_window_size(Some(INITIAL_STREAM_WINDOW))
            .initial_connection_window_size(Some(INITIAL_CONNECTION_WINDOW))
            .max_frame_size(Some(MAX_FRAME_SIZE))
            .add_service(pb::sidecar_transport_server::SidecarTransportServer::new(
                service,
            ))
            .serve_with_shutdown(self.bind_addr, async move { shutdown.cancelled().await })
            .await
            .map_err(|e| {
                error!(error = ?e, "gRPC server failed");
                GrpcTransportError::ServerError(e.to_string())
            })?;

        Ok(())
    }

    #[instrument(name = "grpc_transport::stop", skip(self), level = "info")]
    fn stop(&mut self) {
        info!("Stopping gRPC transport");
        self.shutdown_token.cancel();
    }
}

#[cfg(test)]
mod tests {
    use super::pb::{
        GetTransactionRequest,
        get_transaction_response::Outcome as GetTransactionOutcome,
        sidecar_transport_client::SidecarTransportClient,
    };
    use crate::transport::grpc::pb::TxExecutionId;
    use alloy::primitives::B256;
    use assertion_executor::primitives::{
        Bytes,
        U256,
    };
    use std::time::Duration;

    #[crate::utils::engine_test(grpc)]
    async fn test_get_transaction_returns_successful_result(
        mut instance: crate::utils::LocalInstance,
    ) {
        let tx_execution_id = instance
            .send_successful_create_tx(U256::from(0u64), Bytes::new())
            .await
            .expect("failed to send transaction");

        assert!(
            instance
                .is_transaction_successful(&tx_execution_id)
                .await
                .expect("transaction query failed"),
            "transaction expected to succeed"
        );

        let address = instance
            .local_address
            .expect("grpc transport should expose an address");

        let mut client = SidecarTransportClient::connect(format!("http://{address}"))
            .await
            .expect("failed to connect grpc client");

        let response = client
            .get_transaction(GetTransactionRequest {
                tx_execution_id: Some(TxExecutionId {
                    block_number: tx_execution_id.block_number,
                    iteration_id: tx_execution_id.iteration_id,
                    tx_hash: tx_execution_id.tx_hash.to_string(),
                    index: tx_execution_id.index,
                }),
            })
            .await
            .expect("get_transaction RPC failed")
            .into_inner();

        match response.outcome {
            Some(GetTransactionOutcome::Result(result)) => {
                let parsed_hash = result
                    .tx_execution_id
                    .unwrap()
                    .tx_hash
                    .parse::<B256>()
                    .expect("invalid hash encoding");
                assert_eq!(
                    parsed_hash, tx_execution_id.tx_hash,
                    "queried hash should match"
                );
                assert_eq!(result.status, "success");
                assert!(result.gas_used > 0, "gas_used expected to be populated");
                assert!(
                    result.error.is_empty(),
                    "error should be empty for successful transactions"
                );
            }
            other => panic!("unexpected outcome: {other:?}"),
        }
    }

    #[crate::utils::engine_test(grpc)]
    async fn test_get_transaction_reports_not_found(mut instance: crate::utils::LocalInstance) {
        instance
            .new_block()
            .await
            .expect("failed to announce new block");
        instance
            .wait_for_processing(Duration::from_millis(10))
            .await;

        let missing_hash = B256::repeat_byte(0x24);
        let address = instance
            .local_address
            .expect("grpc transport should expose an address");

        let mut client = SidecarTransportClient::connect(format!("http://{address}"))
            .await
            .expect("failed to connect grpc client");

        let response = client
            .get_transaction(GetTransactionRequest {
                tx_execution_id: Some(TxExecutionId {
                    block_number: 0,
                    iteration_id: 1,
                    tx_hash: missing_hash.to_string(),
                    index: 0,
                }),
            })
            .await
            .expect("get_transaction RPC failed")
            .into_inner();

        match response.outcome {
            Some(GetTransactionOutcome::NotFound(hash)) => {
                assert_eq!(hash, missing_hash.to_string());
            }
            other => panic!("unexpected outcome: {other:?}"),
        }
    }
}
