//! # `gRPC` transport
//!
//! The following is a transport implementation for gRPC/Protobuf for the sidecar.
//!
//! We use `prost` to generate protobuf rust code from a protobuf definition, and create a
//! `tonic` service from it.
//!
//! We implement the `Transport` trait here that binds the `tonic` service,
//! with the above mentioned generated definitions, inside of `run()`
//! and run the grpc server on the same address we would any other transport.
//!
//! ## Type definitions
//! Protobuf typing can be found below:
//!
//! ```protobuf
#![doc = include_str!("./sidecar.proto")]
//! ```

use crate::{
    engine::queue::TransactionQueueSender,
    transactions_state::TransactionsState,
    transport::{
        Transport,
        http::transactions_results::QueryTransactionsResults,
    },
    utils::ErrorRecoverability,
};
use std::{
    net::SocketAddr,
    sync::{
        Arc,
        atomic::AtomicBool,
    },
};
use tokio_util::sync::CancellationToken;
use tracing::{
    debug,
    error,
    info,
    instrument,
};

pub mod config;
mod server;

// Generated by build.rs from sidecar.proto
// The generated code path is implicit via tonic::include_proto. We wrap it into a module here
// to keep the public surface small and avoid exposing prost types outside this module.
#[allow(dead_code)]
mod pb_inner {
    tonic::include_proto!("sidecar.transport.v1");
}

#[cfg(test)]
pub mod pb {
    pub use super::pb_inner::*;
}

#[cfg(not(test))]
pub(crate) mod pb {
    pub(crate) use super::pb_inner::*;
}

#[derive(thiserror::Error, Debug)]
pub enum GrpcTransportError {
    #[error("Server error: {0}")]
    ServerError(String),
    #[error("Failed to bind the address: {0}")]
    BindAddress(String),
    #[error("Client error: {0}")]
    ClientError(String),
}

impl From<&GrpcTransportError> for ErrorRecoverability {
    fn from(e: &GrpcTransportError) -> Self {
        match e {
            GrpcTransportError::ServerError(_) | GrpcTransportError::BindAddress(_) => {
                Self::Unrecoverable
            }
            GrpcTransportError::ClientError(_) => Self::Recoverable,
        }
    }
}

/// Skeleton implementation of a gRPC `Transport`.
#[derive(Debug)]
pub struct GrpcTransport {
    /// Core engine queue sender.
    tx_sender: TransactionQueueSender,
    /// Server bind address
    bind_addr: SocketAddr,
    /// Shutdown cancellation token
    shutdown_token: CancellationToken,
    /// Signal if the transport has seen a blockenv
    has_blockenv: Arc<AtomicBool>,
    /// Shared transaction results state
    transactions_results: QueryTransactionsResults,
}

impl Transport for GrpcTransport {
    type Error = GrpcTransportError;
    type Config = config::GrpcTransportConfig;

    #[instrument(name = "grpc_transport::new", skip_all, level = "debug")]
    fn new(
        config: Self::Config,
        tx_sender: TransactionQueueSender,
        state_results: Arc<TransactionsState>,
    ) -> Result<Self, Self::Error> {
        debug!(bind_addr = %config.bind_addr, "Creating gRPC transport");
        Ok(Self {
            tx_sender,
            bind_addr: config.bind_addr,
            shutdown_token: CancellationToken::new(),
            has_blockenv: Arc::new(AtomicBool::new(false)),
            transactions_results: QueryTransactionsResults::new(state_results),
        })
    }

    #[instrument(
        name = "grpc_transport::run",
        skip(self),
        fields(bind_addr = %self.bind_addr),
        level = "info"
    )]
    async fn run(&self) -> Result<(), Self::Error> {
        use tokio_stream::wrappers::TcpListenerStream;
        use tonic::transport::Server;

        let listener = tokio::net::TcpListener::bind(self.bind_addr)
            .await
            .map_err(|e| {
                error!(bind_addr = %self.bind_addr, error = %e, "Failed to bind gRPC listener");
                GrpcTransportError::BindAddress(self.bind_addr.to_string())
            })?;

        let incoming = TcpListenerStream::new(listener);

        let service = server::GrpcService::new(
            self.has_blockenv.clone(),
            self.tx_sender.clone(),
            self.transactions_results.clone(),
        );

        info!(bind_addr = %self.bind_addr, "gRPC transport server starting");

        let shutdown = self.shutdown_token.clone();
        Server::builder()
            .add_service(pb::sidecar_transport_server::SidecarTransportServer::new(
                service,
            ))
            .serve_with_incoming_shutdown(incoming, async move { shutdown.cancelled().await })
            .await
            .map_err(|e| {
                error!(error = %e, "gRPC server failed");
                GrpcTransportError::ServerError(e.to_string())
            })?;

        Ok(())
    }

    #[instrument(name = "grpc_transport::stop", skip(self), level = "info")]
    fn stop(&mut self) {
        info!("Stopping gRPC transport");
        self.shutdown_token.cancel();
    }
}
