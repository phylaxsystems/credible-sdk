use crate::{
    engine::queue::TxQueueContents,
    execution_ids::TxExecutionId,
    transactions_state::{
        RequestTransactionResult,
        TransactionsState,
    },
};
use std::{
    sync::Arc,
    time::Duration,
};

/// Wrapper for `TransactionsState` for read-only transactions results.
/// `QueryTransactionsResults` is a wrapper on top of `TransactionState` exposing only methods to read
/// and requests results generated by the engine.
#[derive(Clone, Debug)]
pub struct QueryTransactionsResults {
    transactions_state: Arc<TransactionsState>,
}

pub const TX_NOT_FOUND_GRACE_PERIOD_MS: u64 = 250;

impl QueryTransactionsResults {
    pub fn new(transactions_state: Arc<TransactionsState>) -> Self {
        Self { transactions_state }
    }

    pub fn add_accepted_tx(&self, tx_queue_contents: &TxQueueContents) {
        self.transactions_state.add_accepted_tx(tx_queue_contents);
    }

    pub fn is_tx_received(&self, tx_execution_id: &TxExecutionId) -> bool {
        self.transactions_state.is_tx_received(tx_execution_id)
    }

    pub fn request_transaction_result(
        &self,
        tx_execution_id: &TxExecutionId,
    ) -> RequestTransactionResult {
        self.transactions_state
            .request_transaction_result(tx_execution_id)
    }

    pub async fn wait_for_transaction_seen(&self, tx_execution_id: &TxExecutionId) -> bool {
        self.wait_for_transaction_seen_with_config(
            tx_execution_id,
            Duration::from_millis(TX_NOT_FOUND_GRACE_PERIOD_MS),
        )
        .await
    }

    pub async fn wait_for_transaction_seen_with_config(
        &self,
        tx_execution_id: &TxExecutionId,
        timeout_duration: Duration,
    ) -> bool {
        if self.is_tx_received(tx_execution_id) {
            return true;
        }

        tokio::time::timeout(timeout_duration, async {
            loop {
                if self.is_tx_received(tx_execution_id) {
                    break;
                }
                tokio::time::sleep(Duration::from_micros(500)).await;
            }
        })
        .await
        .is_ok()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        engine::{
            TransactionResult,
            queue::{
                QueueTransaction,
                TxQueueContents,
            },
        },
        execution_ids::TxExecutionId,
    };
    use alloy::primitives::B256;
    use revm::context::TxEnv;
    use std::time::Duration;
    use tracing::Span;

    fn create_tx_execution_id(byte: u8) -> TxExecutionId {
        TxExecutionId::new(1, 0, B256::repeat_byte(byte))
    }

    fn sample_result() -> TransactionResult {
        TransactionResult::ValidationError("test error".into())
    }

    fn create_queue_transaction(tx_execution_id: TxExecutionId) -> TxQueueContents {
        TxQueueContents::Tx(
            QueueTransaction {
                tx_execution_id,
                tx_env: TxEnv::default(),
            },
            Span::current(),
        )
    }

    #[tokio::test]
    async fn wait_for_transaction_seen_returns_immediately_when_present() {
        let state = TransactionsState::new();
        let query = QueryTransactionsResults::new(state.clone());
        let tx_execution_id = create_tx_execution_id(0x11);
        let result = sample_result();
        state.add_transaction_result(tx_execution_id, &result);

        assert!(query.wait_for_transaction_seen(&tx_execution_id).await);
    }

    #[tokio::test]
    async fn wait_for_transaction_seen_waits_until_result_available() {
        let state = TransactionsState::new();
        let query = QueryTransactionsResults::new(state.clone());
        let tx_execution_id = create_tx_execution_id(0x22);
        let timeout = Duration::from_millis(50);

        let waiter = {
            let query = query.clone();
            tokio::spawn(async move {
                query
                    .wait_for_transaction_seen_with_config(&tx_execution_id, timeout)
                    .await
            })
        };

        tokio::time::sleep(Duration::from_millis(10)).await;

        let result = sample_result();
        state.add_transaction_result(tx_execution_id, &result);

        assert!(waiter.await.expect("wait task panicked"));
    }

    #[tokio::test]
    async fn wait_for_transaction_seen_tx_available() {
        let state = TransactionsState::new();
        let query = QueryTransactionsResults::new(state.clone());

        // Case 1: transaction result already stored.
        let processed_tx = create_tx_execution_id(0x33);
        let result = sample_result();
        state.add_transaction_result(processed_tx, &result);
        assert!(query.wait_for_transaction_seen(&processed_tx).await);

        // Case 2: transaction listed as accepted but result not in the map yet.
        let accepted_tx = create_tx_execution_id(0x34);
        let queue_tx = create_queue_transaction(accepted_tx);
        query.add_accepted_tx(&queue_tx);
        assert!(query.wait_for_transaction_seen(&accepted_tx).await);
    }

    #[tokio::test]
    async fn wait_for_transaction_seen_times_out_if_missing() {
        let state = TransactionsState::new();
        let query = QueryTransactionsResults::new(state.clone());
        let tx_execution_id = create_tx_execution_id(0x33);

        let result = query
            .wait_for_transaction_seen_with_config(&tx_execution_id, Duration::from_millis(30))
            .await;

        assert!(!result, "wait should time out when tx never arrives");
    }
}
