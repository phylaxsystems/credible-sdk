use dashmap::DashMap;
use std::sync::Mutex;
use thiserror::Error;
use tokio::{
    sync::broadcast,
    task::JoinHandle,
};

use crate::{
    engine::queue::TxQueueContents,
    execution_ids::TxExecutionId,
    transactions_state::{
        RequestTransactionResult,
        TransactionsState,
    },
};
use std::sync::Arc;

/// How much we wait for txs to be received
pub const TRANSACTION_RECEIVE_WAIT: u64 = 250;

#[derive(Debug)]
/// Represents the state of a transaction, we either have received a transaction
/// in which case we return `Yes` or we havent yet, in which case we
pub(crate) enum AcceptedState {
    Yes,
    NotYet(broadcast::Receiver<bool>),
}

/// Wrapper for `TransactionsState` for read-only transactions results.
/// `QueryTransactionsResults` is a wrapper on top of `TransactionState` exposing only methods to read
/// and requests results generated by the engine.
///
/// If a result is not immediatelly available, it will respond with a channel that can be awaited on
/// and will be completed once the tx is in `self.transactions_state`.
#[derive(Clone, Debug)]
pub struct QueryTransactionsResults {
    transactions_state: Arc<TransactionsState>,
    pending_receives: Arc<DashMap<TxExecutionId, broadcast::Sender<bool>>>,
    bg_task_handles: Arc<Mutex<Vec<JoinHandle<()>>>>,
}

pub type QueryTransactionsResultsResult<T = ()> = Result<T, QueryTransactionsResultsError>;

#[derive(Debug, Error)]
pub enum QueryTransactionsResultsError {
    #[error("failed to notify waiters for transaction {tx_execution_id}")]
    NotifyFailed {
        tx_execution_id: TxExecutionId,
        #[source]
        source: broadcast::error::SendError<bool>,
    },
}

impl QueryTransactionsResults {
    pub fn new(transactions_state: Arc<TransactionsState>) -> Self {
        Self {
            transactions_state,
            pending_receives: Arc::new(DashMap::new()),
            bg_task_handles: Arc::new(Vec::new().into()),
        }
    }

    /// Adds accepted tx to `transactions_state` and sends a message to all
    /// waiting channels that the transaction was accepted.
    pub fn add_accepted_tx(
        &self,
        tx_queue_contents: &TxQueueContents,
    ) -> QueryTransactionsResultsResult {
        // Add to `transactions_state` first
        self.transactions_state.add_accepted_tx(tx_queue_contents);

        // Next, we send that we have received it to all receivers
        // We dont have to worry about cleanup because the bg task
        // we created should do it for us!
        let tx = match tx_queue_contents {
            TxQueueContents::Tx(tx, _) => tx,
            _ => return Ok(()),
        };
        if let Some(sender) = self.pending_receives.get(&tx.tx_execution_id) {
            sender.send(true).map(|_| ()).map_err(|source| {
                QueryTransactionsResultsError::NotifyFailed {
                    tx_execution_id: tx.tx_execution_id,
                    source,
                }
            })?;
        }

        Ok(())
    }

    /// Spawns a helper task cleans up pending requests with no receivers.
    fn spawn_cleanup_task(&self, tx_execution_id: &TxExecutionId, sender: broadcast::Sender<bool>) {
        // We dont need to spawn a new bg task because one exists already
        if self.pending_receives.contains_key(tx_execution_id) {
            return;
        }

        let pending_clone = self.pending_receives.clone();
        let execution_id_clone = tx_execution_id.clone();
        let task = tokio::task::spawn(async move {
            // this completes when there are no senders left
            sender.closed().await;
            // clean up the channel
            pending_clone.remove(&execution_id_clone);
        });

        // Add task to joinhandles so we can kill on drop
        let mut lock = self.bg_task_handles.lock().map_err(|_| {}).unwrap();
        lock.push(task);
    }

    /// Checks to see if transaction has been received in the transport.
    /// Returns `AcceptedState::Yes` if it was, and if not, it will return
    /// a `AcceptedState::NotYet` with broadcast receiver.
    ///
    /// This will return `true` once we see it.
    pub fn is_tx_received(&self, tx_execution_id: &TxExecutionId) -> AcceptedState {
        if self.transactions_state.is_tx_received(tx_execution_id) {
            return AcceptedState::Yes;
        }

        // Check if we already have a channel which we can return
        if let Some(channel) = self.pending_receives.get(tx_execution_id) {
            let receiver = channel.subscribe();
            return AcceptedState::NotYet(receiver);
        }

        // If we dont, we have to create a new channel and insert it
        let (tx, rx) = broadcast::channel(1);
        // spawn cleanup task
        self.spawn_cleanup_task(tx_execution_id, tx.clone());

        // Insert into pending_receives
        self.pending_receives.insert(*tx_execution_id, tx);

        return AcceptedState::NotYet(rx);
    }

    pub fn request_transaction_result(
        &self,
        tx_execution_id: &TxExecutionId,
    ) -> RequestTransactionResult {
        self.transactions_state
            .request_transaction_result(tx_execution_id)
    }

    /// Checks to see if transaction has been received in the transport.
    /// This will not go through a channel and will respond about the immediate state.
    pub fn is_tx_received_now(&self, tx_execution_id: &TxExecutionId) -> bool {
        if self.transactions_state.is_tx_received(tx_execution_id) {
            return true;
        }

        false
    }
}

impl Drop for QueryTransactionsResults {
    fn drop(&mut self) {
        // Making sure that this is the final `QueryTransactionsResults`
        // when we drop.
        //
        // We dont want to drop channels for clones of `QueryTransactionsResults`
        if Arc::strong_count(&self.bg_task_handles) == 1 {
            if let Ok(mut handles) = self.bg_task_handles.lock() {
                let tasks: Vec<_> = handles.drain(..).collect();
                drop(handles);
                for handle in tasks {
                    handle.abort();
                }
            }
        }

        if Arc::strong_count(&self.pending_receives) == 1 {
            self.pending_receives.clear();
        }
    }
}
