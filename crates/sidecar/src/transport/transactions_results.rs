use dashmap::DashMap;
use futures::future;
use metrics::histogram;
use std::{
    fmt::Debug,
    sync::Mutex,
    time::Duration,
};
use thiserror::Error;
use tokio::{
    sync::broadcast,
    task::JoinHandle,
    time::Instant,
};

use crate::{
    engine::queue::TxQueueContents,
    execution_ids::TxExecutionId,
    transactions_state::{
        RequestTransactionResult,
        TransactionsState,
    },
};
use std::sync::Arc;
use tracing::debug;

/// How much we wait for txs to be received
pub const TRANSACTION_RECEIVE_WAIT: u64 = 250;

#[derive(Debug)]
/// Represents the state of a transaction, we either have received a transaction
/// in which case we return `Yes` or we havent yet, in which case we
pub enum AcceptedState {
    Yes,
    NotYet(broadcast::Receiver<bool>),
}

/// Wrapper for `TransactionsState` for read-only transactions results.
/// `QueryTransactionsResults` is a wrapper on top of `TransactionState` exposing only methods to read
/// and requests results generated by the engine.
///
/// If a result is not immediatelly available, it will respond with a channel that can be awaited on
/// and will be completed once the tx is in `self.transactions_state`.
#[derive(Clone, Debug)]
pub struct QueryTransactionsResults {
    transactions_state: Arc<TransactionsState>,
    pending_receives: Arc<DashMap<TxExecutionId, broadcast::Sender<bool>>>,
    bg_task_handle: Arc<Mutex<Option<JoinHandle<()>>>>,
}

pub type QueryTransactionsResultsResult<T = ()> = Result<T, QueryTransactionsResultsError>;

#[derive(Debug, Error)]
pub enum QueryTransactionsResultsError {
    #[error("failed to notify waiters for transaction {tx_execution_id}")]
    NotifyFailed {
        tx_execution_id: TxExecutionId,
        #[source]
        source: broadcast::error::SendError<bool>,
    },
}

impl QueryTransactionsResults {
    pub fn new(transactions_state: Arc<TransactionsState>) -> Self {
        let this = Self {
            transactions_state,
            pending_receives: Arc::new(DashMap::new()),
            bg_task_handle: Arc::new(Mutex::new(None)),
        };

        this.spawn_cleanup_task();

        this
    }

    /// Adds accepted tx to `transactions_state` and sends a message to all
    /// waiting channels that the transaction was accepted.
    pub fn add_accepted_tx(
        &self,
        tx_queue_contents: &TxQueueContents,
    ) -> QueryTransactionsResultsResult {
        // Add to `transactions_state` first
        self.transactions_state.add_accepted_tx(tx_queue_contents);

        // Next, we send that we have received it to all receivers
        // We dont have to worry about cleanup because the bg task
        // we created should do it for us!
        let TxQueueContents::Tx(tx, _) = tx_queue_contents else {
            return Ok(());
        };

        if let Some(sender) = self.pending_receives.get(&tx.tx_execution_id) {
            debug!(
                target = "transport::grpc",
                method = "AddAcceptedTx",
                tx_execution_id = ?tx.tx_execution_id
            );
            sender.send(true).map(|_| ()).map_err(|source| {
                QueryTransactionsResultsError::NotifyFailed {
                    tx_execution_id: tx.tx_execution_id,
                    source,
                }
            })?;
        }

        Ok(())
    }

    /// Spawns the cleanup task that removes pending receives with no subscribers.
    fn spawn_cleanup_task(&self) {
        // Only one background task per QueryTransactionsResults instance.
        let mut handle_lock = self.bg_task_handle.lock().map_err(|_| {}).unwrap();
        if handle_lock.is_some() {
            return;
        }

        let pending_clone = self.pending_receives.clone();
        let task = tokio::task::spawn(async move {
            let mut cleanup_interval =
                tokio::time::interval(Duration::from_millis(TRANSACTION_RECEIVE_WAIT));
            loop {
                cleanup_interval.tick().await;

                let stale_entries: Vec<_> = pending_clone
                    .iter()
                    .filter(|entry| entry.value().receiver_count() == 0)
                    .map(|entry| *entry.key())
                    .collect();

                for tx_execution_id in stale_entries {
                    pending_clone.remove(&tx_execution_id);
                }
            }
        });

        *handle_lock = Some(task);
    }

    /// Checks to see if transaction has been received in the transport.
    /// Returns `AcceptedState::Yes` if it was, and if not, it will return
    /// a `AcceptedState::NotYet` with broadcast receiver.
    ///
    /// This will return `true` once we see it.
    pub fn is_tx_received(&self, tx_execution_id: &TxExecutionId) -> AcceptedState {
        let entry = self
            .pending_receives
            .entry(*tx_execution_id)
            .or_insert_with(|| {
                let (tx, _) = broadcast::channel(1);
                tx
            });

        let receiver = entry.value().subscribe();

        if self.transactions_state.is_tx_received(tx_execution_id) {
            return AcceptedState::Yes;
        }

        AcceptedState::NotYet(receiver)
    }

    pub fn request_transaction_result(
        &self,
        tx_execution_id: &TxExecutionId,
    ) -> RequestTransactionResult {
        self.transactions_state
            .request_transaction_result(tx_execution_id)
    }

    /// Checks to see if transaction has been received in the transport.
    /// This will not go through a channel and will respond about the immediate state.
    pub fn is_tx_received_now(&self, tx_execution_id: &TxExecutionId) -> bool {
        if self.transactions_state.is_tx_received(tx_execution_id) {
            return true;
        }

        false
    }
}

type PendingTxWaitOutcome =
    Result<Result<bool, broadcast::error::RecvError>, tokio::time::error::Elapsed>;

/// Waits for a batch of pending receivers to signal their transactions were received.
pub async fn wait_for_pending_transactions<I, K>(pending: I) -> Vec<(K, PendingTxWaitOutcome)>
where
    I: IntoIterator<Item = (K, broadcast::Receiver<bool>)>,
    K: Send + Debug,
{
    let wait_futures = pending.into_iter().map(|(key, mut rx)| {
        async move {
            debug!(
                target = "transport::grpc",
                method = "GetTransaction",
                key = ?key,
                "Waiting for the transaction to be received"
            );
            let wait_started_at = Instant::now();
            let wait_result =
                tokio::time::timeout(Duration::from_millis(TRANSACTION_RECEIVE_WAIT), rx.recv())
                    .await;
            histogram!("sidecar_get_transaction_wait_duration").record(wait_started_at.elapsed());

            debug!(
                target = "transport::grpc",
                method = "GetTransaction",
                key = ?key,
                "Transaction received"
            );

            (key, wait_result)
        }
    });

    future::join_all(wait_futures).await
}

impl Drop for QueryTransactionsResults {
    fn drop(&mut self) {
        // Making sure that this is the final `QueryTransactionsResults`
        // when we drop.
        //
        // We dont want to drop channels for clones of `QueryTransactionsResults`
        if Arc::strong_count(&self.bg_task_handle) == 1
            && let Ok(mut handle_lock) = self.bg_task_handle.lock()
            && let Some(handle) = handle_lock.take()
        {
            handle.abort();
        }

        if Arc::strong_count(&self.pending_receives) == 1 {
            self.pending_receives.clear();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use revm::primitives::alloy_primitives::B256;

    #[tokio::test]
    async fn pending_receive_is_evicted_when_no_receivers_left() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = TxExecutionId::new(1, 0, B256::from([3u8; 32]), 0);

        let receiver = match query_results.is_tx_received(&tx_execution_id) {
            AcceptedState::NotYet(rx) => rx,
            AcceptedState::Yes => panic!("transaction should not be marked received"),
        };

        assert!(
            query_results
                .pending_receives
                .contains_key(&tx_execution_id),
            "pending receives should contain entry immediately after subscribe"
        );

        drop(receiver);

        tokio::time::timeout(Duration::from_secs(2), async {
            loop {
                if !query_results
                    .pending_receives
                    .contains_key(&tx_execution_id)
                {
                    break;
                }
                tokio::time::sleep(Duration::from_millis(25)).await;
            }
        })
        .await
        .expect("pending receive entry should be removed once last receiver drops");
    }
}
