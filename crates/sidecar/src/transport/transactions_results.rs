use dashmap::DashMap;
use futures::future;
use metrics::histogram;
use std::{
    fmt::Debug,
    sync::Mutex,
    time::Duration,
};
use thiserror::Error;
use tokio::{
    sync::broadcast,
    task::JoinHandle,
    time::Instant,
};

use crate::{
    engine::queue::TxQueueContents,
    execution_ids::TxExecutionId,
    metrics::TransportTransactionsResultMetrics,
    transactions_state::{
        RequestTransactionResult,
        TransactionsState,
    },
};
use std::sync::Arc;
use tracing::debug;

/// How much we wait for txs to be received
pub const TRANSACTION_RECEIVE_WAIT: u64 = 250;

#[derive(Debug)]
/// Represents the state of a transaction, we either have received a transaction
/// in which case we return `Yes` or we haven't yet, in which case we return
/// a receiver to wait on.
pub enum AcceptedState {
    Yes,
    NotYet(broadcast::Receiver<bool>),
}

/// Wrapper for `TransactionsState` for read-only transactions results.
/// `QueryTransactionsResults` is a wrapper on top of `TransactionState` exposing only methods to read
/// and requests results generated by the engine.
///
/// If a result is not immediately available, it will respond with a channel that can be awaited on
/// and will be completed once the tx is in `self.transactions_state`.
#[derive(Clone, Debug)]
pub struct QueryTransactionsResults {
    transactions_state: Arc<TransactionsState>,
    pending_receives: Arc<DashMap<TxExecutionId, broadcast::Sender<bool>>>,
    bg_task_handle: Arc<Mutex<Option<JoinHandle<()>>>>,
    metrics: TransportTransactionsResultMetrics,
}

pub type QueryTransactionsResultsResult<T = ()> = Result<T, QueryTransactionsResultsError>;

#[derive(Debug, Error)]
pub enum QueryTransactionsResultsError {
    #[error("failed to notify waiters for transaction {tx_execution_id}")]
    NotifyFailed {
        tx_execution_id: TxExecutionId,
        #[source]
        source: broadcast::error::SendError<bool>,
    },
}

impl QueryTransactionsResults {
    pub fn new(transactions_state: Arc<TransactionsState>) -> Self {
        let this = Self {
            transactions_state,
            pending_receives: Arc::new(DashMap::new()),
            bg_task_handle: Arc::new(Mutex::new(None)),
            metrics: TransportTransactionsResultMetrics::default(),
        };

        this.spawn_cleanup_task();

        this
    }

    /// Adds accepted tx to `transactions_state` and sends a message to all
    /// waiting channels that the transaction was accepted.
    pub fn add_accepted_tx(
        &self,
        tx_queue_contents: &TxQueueContents,
    ) -> QueryTransactionsResultsResult {
        self.metrics
            .set_transport_pending_receives_length(self.pending_receives.len());

        let TxQueueContents::Tx(tx, _) = tx_queue_contents else {
            self.transactions_state.add_accepted_tx(tx_queue_contents);
            return Ok(());
        };

        // Get or create the sender before updating the state.
        // This ensures the channel infrastructure exists for concurrent subscribers.
        let sender = self
            .pending_receives
            .entry(tx.tx_execution_id)
            .or_insert_with(|| {
                let (tx, _) = broadcast::channel(1);
                tx
            });

        // Now update the state
        self.transactions_state.add_accepted_tx(tx_queue_contents);

        debug!(
            target = "transport::grpc",
            method = "AddAcceptedTx",
            tx_execution_id = ?tx.tx_execution_id
        );

        let _ = sender.send(true);

        Ok(())
    }

    /// Spawns the cleanup task that removes pending receives with no subscribers.
    fn spawn_cleanup_task(&self) {
        // Only one background task per QueryTransactionsResults instance.
        let mut handle_lock = self.bg_task_handle.lock().map_err(|_| {}).unwrap();
        if handle_lock.is_some() {
            return;
        }

        let pending_clone = self.pending_receives.clone();
        let task = tokio::task::spawn(async move {
            // Use slightly longer interval to reduce contention
            let mut cleanup_interval =
                tokio::time::interval(Duration::from_millis(TRANSACTION_RECEIVE_WAIT));
            loop {
                cleanup_interval.tick().await;

                // With retain(), the check and remove happen atomically per-entry.
                pending_clone.retain(|_key, sender| {
                    // Keep entries that have active receivers
                    sender.receiver_count() > 0
                });
            }
        });

        *handle_lock = Some(task);
    }

    /// Checks to see if transaction has been received in the transport.
    /// Returns `AcceptedState::Yes` if it was, and if not, it will return
    /// a `AcceptedState::NotYet` with broadcast receiver.
    pub fn is_tx_received(&self, tx_execution_id: &TxExecutionId) -> AcceptedState {
        // Check state FIRST to avoid unnecessary channel creation.
        // This is the fast path for already-received transactions.
        if self.transactions_state.is_tx_received(tx_execution_id) {
            return AcceptedState::Yes;
        }

        // Get or create the sender and subscribe
        let entry = self
            .pending_receives
            .entry(*tx_execution_id)
            .or_insert_with(|| {
                let (tx, _) = broadcast::channel(1);
                tx
            });

        let receiver = entry.value().subscribe();

        if self.transactions_state.is_tx_received(tx_execution_id) {
            return AcceptedState::Yes;
        }

        AcceptedState::NotYet(receiver)
    }

    pub fn request_transaction_result(
        &self,
        tx_execution_id: &TxExecutionId,
    ) -> RequestTransactionResult {
        self.transactions_state
            .request_transaction_result(tx_execution_id)
    }

    /// Checks to see if transaction has been received in the transport.
    /// This will not go through a channel and will respond about the immediate state.
    pub fn is_tx_received_now(&self, tx_execution_id: &TxExecutionId) -> bool {
        self.transactions_state.is_tx_received(tx_execution_id)
    }

    /// Returns the number of pending receive entries (for testing)
    #[cfg(test)]
    pub fn pending_receives_count(&self) -> usize {
        self.pending_receives.len()
    }

    /// Check if a specific tx has a pending receive entry (for testing)
    #[cfg(test)]
    pub fn has_pending_receive(&self, tx_execution_id: &TxExecutionId) -> bool {
        self.pending_receives.contains_key(tx_execution_id)
    }
}

type PendingTxWaitOutcome =
    Result<Result<bool, broadcast::error::RecvError>, tokio::time::error::Elapsed>;

/// Waits for a batch of pending receivers to signal their transactions were received.
pub async fn wait_for_pending_transactions<I, K>(pending: I) -> Vec<(K, PendingTxWaitOutcome)>
where
    I: IntoIterator<Item = (K, broadcast::Receiver<bool>)>,
    K: Send + Debug,
{
    let wait_futures = pending.into_iter().map(|(key, mut rx)| {
        async move {
            debug!(
                target = "transport::grpc",
                method = "GetTransaction",
                key = ?key,
                "Waiting for the transaction to be received"
            );
            let wait_started_at = Instant::now();
            let wait_result =
                tokio::time::timeout(Duration::from_millis(TRANSACTION_RECEIVE_WAIT), rx.recv())
                    .await;
            histogram!("sidecar_get_transaction_wait_duration").record(wait_started_at.elapsed());

            debug!(
                target = "transport::grpc",
                method = "GetTransaction",
                key = ?key,
                "Transaction received"
            );

            (key, wait_result)
        }
    });

    future::join_all(wait_futures).await
}

impl Drop for QueryTransactionsResults {
    fn drop(&mut self) {
        // Making sure that this is the final `QueryTransactionsResults`
        // when we drop.
        //
        // We don't want to drop channels for clones of `QueryTransactionsResults`
        if Arc::strong_count(&self.bg_task_handle) == 1
            && let Ok(mut handle_lock) = self.bg_task_handle.lock()
            && let Some(handle) = handle_lock.take()
        {
            handle.abort();
        }

        if Arc::strong_count(&self.pending_receives) == 1 {
            self.pending_receives.clear();
        }
    }
}

#[cfg(test)]
mod tests {
    #![allow(clippy::cast_possible_truncation)]
    #![allow(clippy::cast_sign_loss)]
    #![allow(clippy::match_same_arms)]
    use super::*;
    use crate::engine::queue::QueueTransaction;
    use alloy::primitives::U256;
    use revm::{
        context::TxEnv,
        primitives::alloy_primitives::B256,
    };
    use std::sync::atomic::{
        AtomicUsize,
        Ordering,
    };

    fn create_test_tx_execution_id(byte: u8) -> TxExecutionId {
        TxExecutionId::new(U256::from(1), 0, B256::from([byte; 32]), 0)
    }

    fn create_test_tx_queue_contents(tx_execution_id: TxExecutionId) -> TxQueueContents {
        TxQueueContents::Tx(
            QueueTransaction {
                tx_execution_id,
                tx_env: TxEnv::default(),
                prev_tx_hash: None,
            },
            tracing::Span::current(),
        )
    }

    #[tokio::test]
    async fn test_is_tx_received_returns_not_yet_for_unknown_tx() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(1);

        match query_results.is_tx_received(&tx_execution_id) {
            AcceptedState::NotYet(_) => {}
            AcceptedState::Yes => panic!("should return NotYet for unknown tx"),
        }
    }

    #[tokio::test]
    async fn test_is_tx_received_returns_yes_after_add() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(1);
        let tx_contents = create_test_tx_queue_contents(tx_execution_id);

        query_results.add_accepted_tx(&tx_contents).unwrap();

        match query_results.is_tx_received(&tx_execution_id) {
            AcceptedState::Yes => {}
            AcceptedState::NotYet(_) => panic!("should return Yes after add"),
        }
    }

    #[tokio::test]
    async fn test_receiver_gets_notification_on_add() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(1);

        // Get receiver first
        let mut receiver = match query_results.is_tx_received(&tx_execution_id) {
            AcceptedState::NotYet(rx) => rx,
            AcceptedState::Yes => panic!("should return NotYet"),
        };

        // Add the transaction
        let tx_contents = create_test_tx_queue_contents(tx_execution_id);
        query_results.add_accepted_tx(&tx_contents).unwrap();

        // Receiver should get notification
        let result = tokio::time::timeout(Duration::from_millis(100), receiver.recv()).await;
        assert!(result.is_ok(), "should receive notification");
        assert!(result.unwrap().unwrap());
    }

    #[tokio::test]
    async fn pending_receive_is_evicted_when_no_receivers_left() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(3);

        let receiver = match query_results.is_tx_received(&tx_execution_id) {
            AcceptedState::NotYet(rx) => rx,
            AcceptedState::Yes => panic!("transaction should not be marked received"),
        };

        assert!(
            query_results.has_pending_receive(&tx_execution_id),
            "pending receives should contain entry immediately after subscribe"
        );

        drop(receiver);

        tokio::time::timeout(Duration::from_secs(2), async {
            loop {
                if !query_results.has_pending_receive(&tx_execution_id) {
                    break;
                }
                tokio::time::sleep(Duration::from_millis(25)).await;
            }
        })
        .await
        .expect("pending receive entry should be removed once last receiver drops");
    }

    #[tokio::test]
    async fn test_cleanup_does_not_race_with_subscribe() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(1);

        let success_count = Arc::new(AtomicUsize::new(0));

        // Run many iterations to increase the chance of hitting a "race condition"
        for _ in 0..100 {
            let qr = query_results.clone();
            let tx_id = tx_execution_id;
            let sc = success_count.clone();

            let handle = tokio::spawn(async move {
                // Subscribe
                let receiver = match qr.is_tx_received(&tx_id) {
                    AcceptedState::NotYet(rx) => rx,
                    AcceptedState::Yes => return,
                };

                // Hold the receiver briefly
                tokio::time::sleep(Duration::from_micros(100)).await;

                // Verify we still have the entry (cleanup shouldn't have removed it)
                if qr.has_pending_receive(&tx_id) {
                    sc.fetch_add(1, Ordering::SeqCst);
                }

                drop(receiver);
            });

            handle.await.unwrap();
        }

        // Most iterations should succeed (entry not prematurely removed)
        assert!(
            success_count.load(Ordering::SeqCst) > 90,
            "Too many entries were prematurely removed by cleanup task"
        );
    }

    #[tokio::test]
    async fn test_double_check_catches_concurrent_add() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(1);
        let tx_contents = create_test_tx_queue_contents(tx_execution_id);

        // Add tx first
        query_results.add_accepted_tx(&tx_contents).unwrap();

        // This should return Yes due to the state check
        match query_results.is_tx_received(&tx_execution_id) {
            AcceptedState::Yes => {}
            AcceptedState::NotYet(_) => panic!("double-check should catch added tx"),
        }
    }

    #[tokio::test]
    async fn test_concurrent_add_and_subscribe() {
        for iteration in 0..50 {
            let transactions_state = TransactionsState::new();
            let query_results = QueryTransactionsResults::new(transactions_state);

            let tx_execution_id = create_test_tx_execution_id(iteration as u8);
            let tx_contents = create_test_tx_queue_contents(tx_execution_id);

            let qr_for_add = query_results.clone();
            let qr_for_check = query_results.clone();

            // Spawn add task
            let add_handle = tokio::spawn(async move {
                qr_for_add.add_accepted_tx(&tx_contents).unwrap();
            });

            // Spawn check task
            let check_handle = tokio::spawn(async move {
                match qr_for_check.is_tx_received(&tx_execution_id) {
                    AcceptedState::Yes => true,
                    AcceptedState::NotYet(mut rx) => {
                        match tokio::time::timeout(Duration::from_millis(500), rx.recv()).await {
                            Ok(Ok(true)) => true,
                            Ok(Ok(false)) => false,
                            Ok(Err(_)) => qr_for_check.is_tx_received_now(&tx_execution_id),
                            Err(_) => qr_for_check.is_tx_received_now(&tx_execution_id),
                        }
                    }
                }
            });

            let (_, check_result) = tokio::join!(add_handle, check_handle);
            assert!(
                check_result.unwrap(),
                "iteration {iteration}: subscriber should always see tx",
            );
        }
    }

    #[tokio::test]
    async fn test_multiple_subscribers_all_notified() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(1);

        // Create multiple subscribers
        let mut receivers = Vec::new();
        for _ in 0..5 {
            match query_results.is_tx_received(&tx_execution_id) {
                AcceptedState::NotYet(rx) => receivers.push(rx),
                AcceptedState::Yes => panic!("should be NotYet before add"),
            }
        }

        // Add the transaction
        let tx_contents = create_test_tx_queue_contents(tx_execution_id);
        query_results.add_accepted_tx(&tx_contents).unwrap();

        // All receivers should get notification
        for mut rx in receivers {
            let result = tokio::time::timeout(Duration::from_millis(100), rx.recv()).await;
            assert!(
                result.is_ok(),
                "all subscribers should receive notification"
            );
        }
    }

    #[tokio::test]
    async fn test_add_before_subscribe_still_works() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(1);
        let tx_contents = create_test_tx_queue_contents(tx_execution_id);

        // Add first (no subscribers yet)
        query_results.add_accepted_tx(&tx_contents).unwrap();

        // Now subscribe - should get Yes immediately via state check
        match query_results.is_tx_received(&tx_execution_id) {
            AcceptedState::Yes => {}
            AcceptedState::NotYet(_) => panic!("should return Yes for already-added tx"),
        }
    }

    #[tokio::test]
    async fn test_stress_concurrent_operations() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let num_txs = 100;
        let mut handles = Vec::new();

        for i in 0..num_txs {
            let qr = query_results.clone();
            let tx_execution_id = create_test_tx_execution_id((i % 256) as u8);
            let tx_contents = create_test_tx_queue_contents(tx_execution_id);

            let handle = tokio::spawn(async move {
                // Random delay to create more race conditions
                if i % 2 == 0 {
                    tokio::time::sleep(Duration::from_micros(i as u64 * 10)).await;
                }

                if i % 3 == 0 {
                    qr.add_accepted_tx(&tx_contents).unwrap();
                    true
                } else {
                    match qr.is_tx_received(&tx_execution_id) {
                        AcceptedState::Yes => true,
                        AcceptedState::NotYet(mut rx) => {
                            matches!(
                                tokio::time::timeout(Duration::from_millis(50), rx.recv()).await,
                                Ok(Ok(true))
                            )
                        }
                    }
                }
            });

            handles.push(handle);
        }

        let results: Vec<bool> = futures::future::join_all(handles)
            .await
            .into_iter()
            .map(|r| r.unwrap())
            .collect();

        let success_count = results.iter().filter(|&&r| r).count();
        assert!(
            success_count >= num_txs / 3,
            "at least adders should succeed"
        );
    }

    #[tokio::test]
    async fn test_no_deadlock_under_contention() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(1);
        let tx_contents = create_test_tx_queue_contents(tx_execution_id);

        let result = tokio::time::timeout(Duration::from_secs(5), async {
            let mut handles = Vec::new();

            for i in 0..100 {
                let qr = query_results.clone();
                let tc = tx_contents.clone();
                let tx_id = tx_execution_id;

                let handle = tokio::spawn(async move {
                    if i % 2 == 0 {
                        let _ = qr.add_accepted_tx(&tc);
                    } else {
                        let _ = qr.is_tx_received(&tx_id);
                    }
                });

                handles.push(handle);
            }

            futures::future::join_all(handles).await
        })
        .await;

        assert!(
            result.is_ok(),
            "operations should complete without deadlock"
        );
    }

    #[tokio::test]
    async fn test_cleanup_respects_active_waiters() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(1);
        let tx_contents = create_test_tx_queue_contents(tx_execution_id);

        // Get a receiver and hold it
        let mut receiver = match query_results.is_tx_received(&tx_execution_id) {
            AcceptedState::NotYet(rx) => rx,
            AcceptedState::Yes => panic!("should be NotYet"),
        };

        // Wait long enough for the cleanup task to run multiple times
        tokio::time::sleep(Duration::from_millis(TRANSACTION_RECEIVE_WAIT * 3)).await;

        // Entry should still exist because we have an active receiver
        assert!(
            query_results.has_pending_receive(&tx_execution_id),
            "entry should not be cleaned up while receiver is active"
        );

        // Add should still work
        query_results.add_accepted_tx(&tx_contents).unwrap();

        // Receiver should get notification
        let result = tokio::time::timeout(Duration::from_millis(100), receiver.recv()).await;
        assert!(
            result.is_ok(),
            "active receiver should still get notification after cleanup cycles"
        );
    }

    #[tokio::test]
    async fn test_is_tx_received_now() {
        let transactions_state = TransactionsState::new();
        let query_results = QueryTransactionsResults::new(transactions_state);

        let tx_execution_id = create_test_tx_execution_id(1);
        let tx_contents = create_test_tx_queue_contents(tx_execution_id);

        // Before add
        assert!(!query_results.is_tx_received_now(&tx_execution_id));

        // After add
        query_results.add_accepted_tx(&tx_contents).unwrap();
        assert!(query_results.is_tx_received_now(&tx_execution_id));
    }
}
