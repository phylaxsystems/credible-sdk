use std::sync::Mutex;
use std::collections::HashSet;
use dashmap::DashMap;
use tokio::{sync::{
    broadcast,
    oneshot
}, task::JoinHandle};

use crate::{
    engine::queue::TxQueueContents,
    execution_ids::TxExecutionId,
    transactions_state::{
        RequestTransactionResult,
        TransactionsState,
    },
};
use std::sync::Arc;

#[derive(Debug)]
/// Represents the state of a transaction, we either have received a transaction
/// in which case we return `Yes` or we havent yet, in which case we 
enum AcceptedState {
    Yes,
    NotYet(broadcast::Receiver<bool>),
}

/// Wrapper for `TransactionsState` for read-only transactions results.
/// `QueryTransactionsResults` is a wrapper on top of `TransactionState` exposing only methods to read
/// and requests results generated by the engine.
///
/// If a result is not immediatelly available, it will respond with a channel that can be awaited on
/// and will be completed once the tx is in `self.transactions_state`.
#[derive(Clone, Debug)]
pub struct QueryTransactionsResults {
    transactions_state: Arc<TransactionsState>,
    pending_requests: Arc<DashMap<TxExecutionId, broadcast::Sender<bool>>>,
    bg_task_handles: Arc<Mutex<Vec<JoinHandle<()>>>>,
}

impl QueryTransactionsResults {
    pub fn new(transactions_state: Arc<TransactionsState>) -> Self {
        Self { 
            transactions_state,
            pending_requests: Arc::new(DashMap::new()),
            bg_task_handles: Arc::new(Vec::new().into()),
        }
    }

    /// Adds accepted tx to `transactions_state` and sends a message to all
    /// waiting channels that the transaction was accepted.
    /// TODO: need to add proper error types here
    pub fn add_accepted_tx(&self, tx_queue_contents: &TxQueueContents) {
        // Add to `transactions_state` first
        self.transactions_state.add_accepted_tx(tx_queue_contents);

        // Next, we send that we have received it to all receivers
        // We dont have to worry about cleanup because the bg task
        // we created should do it for us!
        let tx = match tx_queue_contents {
            TxQueueContents::Tx(tx, _) => tx,
            _ => return,
        };
        if let Some(sender) = self.pending_requests.get(&tx.tx_execution_id) {
            sender.send(true);
        }
    }

    /// Spawns a helper task cleans up pendong requests with no receivers.
    fn spawn_cleanup_task(&self, tx_execution_id: &TxExecutionId, sender: broadcast::Sender<bool>) {
        // We dont need to spawn a new bg task because one exists already
        if self.pending_requests.contains_key(tx_execution_id) {
            return;
        }

        let pending_clone = self.pending_requests.clone();
        let execution_id_clone = tx_execution_id.clone();
        let task = tokio::task::spawn(async move {
            // this completes when there are no senders left
            sender.closed().await;
            // clean up the channel
            pending_clone.remove(&execution_id_clone);
        });

        // Add task to joinhandles so we can kill on drop !!!TODO!!!
        let mut lock = self.bg_task_handles.lock().map_err(|_| {}).unwrap();
        lock.push(task);
    }

    /// Checks to see if transaction has been received in the transport.
    /// Returns `AcceptedState::Yes` if it was, and if not, it will return
    /// a `AcceptedState::NotYet` with broadcast receiver.
    ///
    /// This will return `true` once we see it.
    pub fn is_tx_received(&self, tx_execution_id: &TxExecutionId) -> AcceptedState {
        if self.transactions_state.is_tx_received(tx_execution_id) {
            return AcceptedState::Yes;
        }

        // Check if we already have a channel which we can return
        if let Some(channel) = self.pending_requests.get(tx_execution_id) {
            let receiver = channel.subscribe();
            return AcceptedState::NotYet(receiver);
        }

        // If we dont, we have to create a new channel and insert it
        let (tx, rx) = broadcast::channel(1);
        self.pending_requests.insert(*tx_execution_id, tx);

        return AcceptedState::NotYet(rx);
    }

    pub fn request_transaction_result(
        &self,
        tx_execution_id: &TxExecutionId,
    ) -> RequestTransactionResult {
        self.transactions_state
            .request_transaction_result(tx_execution_id)
    }
}
